[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "total_ordering",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "singledispatch",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "TracebackType",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "getmro",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isclass",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "isclass",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "local",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Event",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "collections.abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections.abc",
        "description": "collections.abc",
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "enum",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "enum",
        "description": "enum",
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "linecache",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "linecache",
        "description": "linecache",
        "detail": "linecache",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AnyStr",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableMapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableSequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "MutableSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "get_type_hints",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "overload",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NoReturn",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "FrozenSet",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NewType",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsInt",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BinaryIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "itemgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "attrgetter",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "or_",
        "importPath": "operator",
        "description": "operator",
        "isExtraImport": true,
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "AbstractContextManager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.converters",
        "description": "attr.converters",
        "isExtraImport": true,
        "detail": "attr.converters",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.exceptions",
        "description": "attr.exceptions",
        "isExtraImport": true,
        "detail": "attr.exceptions",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.filters",
        "description": "attr.filters",
        "isExtraImport": true,
        "detail": "attr.filters",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.setters",
        "description": "attr.setters",
        "isExtraImport": true,
        "detail": "attr.setters",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "attr.validators",
        "description": "attr.validators",
        "isExtraImport": true,
        "detail": "attr.validators",
        "documentation": {}
    },
    {
        "label": "BsonConverter",
        "importPath": "cattrs.preconf.bson",
        "description": "cattrs.preconf.bson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.bson",
        "description": "cattrs.preconf.bson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.bson",
        "description": "cattrs.preconf.bson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.json",
        "description": "cattrs.preconf.json",
        "isExtraImport": true,
        "detail": "cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "JsonConverter",
        "importPath": "cattrs.preconf.json",
        "description": "cattrs.preconf.json",
        "isExtraImport": true,
        "detail": "cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.json",
        "description": "cattrs.preconf.json",
        "isExtraImport": true,
        "detail": "cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.msgpack",
        "description": "cattrs.preconf.msgpack",
        "isExtraImport": true,
        "detail": "cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.msgpack",
        "description": "cattrs.preconf.msgpack",
        "isExtraImport": true,
        "detail": "cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "MsgpackConverter",
        "importPath": "cattrs.preconf.msgpack",
        "description": "cattrs.preconf.msgpack",
        "isExtraImport": true,
        "detail": "cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.orjson",
        "description": "cattrs.preconf.orjson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.orjson",
        "description": "cattrs.preconf.orjson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "OrjsonConverter",
        "importPath": "cattrs.preconf.orjson",
        "description": "cattrs.preconf.orjson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.pyyaml",
        "description": "cattrs.preconf.pyyaml",
        "isExtraImport": true,
        "detail": "cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.pyyaml",
        "description": "cattrs.preconf.pyyaml",
        "isExtraImport": true,
        "detail": "cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "PyyamlConverter",
        "importPath": "cattrs.preconf.pyyaml",
        "description": "cattrs.preconf.pyyaml",
        "isExtraImport": true,
        "detail": "cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.tomlkit",
        "description": "cattrs.preconf.tomlkit",
        "isExtraImport": true,
        "detail": "cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.tomlkit",
        "description": "cattrs.preconf.tomlkit",
        "isExtraImport": true,
        "detail": "cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "TomlkitConverter",
        "importPath": "cattrs.preconf.tomlkit",
        "description": "cattrs.preconf.tomlkit",
        "isExtraImport": true,
        "detail": "cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "importPath": "cattrs.preconf.ujson",
        "description": "cattrs.preconf.ujson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "importPath": "cattrs.preconf.ujson",
        "description": "cattrs.preconf.ujson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "UjsonConverter",
        "importPath": "cattrs.preconf.ujson",
        "description": "cattrs.preconf.ujson",
        "isExtraImport": true,
        "detail": "cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "BaseConverter",
        "importPath": "cattrs.converters",
        "description": "cattrs.converters",
        "isExtraImport": true,
        "detail": "cattrs.converters",
        "documentation": {}
    },
    {
        "label": "Converter",
        "importPath": "cattrs.converters",
        "description": "cattrs.converters",
        "isExtraImport": true,
        "detail": "cattrs.converters",
        "documentation": {}
    },
    {
        "label": "GenConverter",
        "importPath": "cattrs.converters",
        "description": "cattrs.converters",
        "isExtraImport": true,
        "detail": "cattrs.converters",
        "documentation": {}
    },
    {
        "label": "UnstructureStrategy",
        "importPath": "cattrs.converters",
        "description": "cattrs.converters",
        "isExtraImport": true,
        "detail": "cattrs.converters",
        "documentation": {}
    },
    {
        "label": "create_uniq_field_dis_func",
        "importPath": "cattrs.disambiguators",
        "description": "cattrs.disambiguators",
        "isExtraImport": true,
        "detail": "cattrs.disambiguators",
        "documentation": {}
    },
    {
        "label": "FunctionDispatch",
        "importPath": "cattrs.dispatch",
        "description": "cattrs.dispatch",
        "isExtraImport": true,
        "detail": "cattrs.dispatch",
        "documentation": {}
    },
    {
        "label": "MultiStrategyDispatch",
        "importPath": "cattrs.dispatch",
        "description": "cattrs.dispatch",
        "isExtraImport": true,
        "detail": "cattrs.dispatch",
        "documentation": {}
    },
    {
        "label": "BaseValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ClassValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ForbiddenExtraKeysError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "IterableValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "StructureHandlerNotFoundError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "IterableValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "StructureHandlerNotFoundError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ClassValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ForbiddenExtraKeysError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "IterableValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "StructureHandlerNotFoundError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ClassValidationError",
        "importPath": "cattrs.errors",
        "description": "cattrs.errors",
        "isExtraImport": true,
        "detail": "cattrs.errors",
        "documentation": {}
    },
    {
        "label": "AttributeOverride",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_dict_structure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_dict_unstructure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_hetero_tuple_unstructure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_iterable_unstructure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_mapping_structure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_mapping_unstructure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "override",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_mapping_structure_fn",
        "importPath": "cattrs.gen",
        "description": "cattrs.gen",
        "isExtraImport": true,
        "detail": "cattrs.gen",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85decode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "b85encode",
        "importPath": "base64",
        "description": "base64",
        "isExtraImport": true,
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CODEC_OPTIONS",
        "importPath": "bson",
        "description": "bson",
        "isExtraImport": true,
        "detail": "bson",
        "documentation": {}
    },
    {
        "label": "CodecOptions",
        "importPath": "bson",
        "description": "bson",
        "isExtraImport": true,
        "detail": "bson",
        "documentation": {}
    },
    {
        "label": "ObjectId",
        "importPath": "bson",
        "description": "bson",
        "isExtraImport": true,
        "detail": "bson",
        "documentation": {}
    },
    {
        "label": "decode",
        "importPath": "bson",
        "description": "bson",
        "isExtraImport": true,
        "detail": "bson",
        "documentation": {}
    },
    {
        "label": "encode",
        "importPath": "bson",
        "description": "bson",
        "isExtraImport": true,
        "detail": "bson",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_mapping",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_mapping",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "FrozenSetSubscriptable",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_mapping",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "AbstractSet",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "get_origin",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "ExceptionGroup",
        "importPath": "cattrs._compat",
        "description": "cattrs._compat",
        "isExtraImport": true,
        "detail": "cattrs._compat",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "msgpack",
        "description": "msgpack",
        "isExtraImport": true,
        "detail": "msgpack",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "msgpack",
        "description": "msgpack",
        "isExtraImport": true,
        "detail": "msgpack",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "orjson",
        "description": "orjson",
        "isExtraImport": true,
        "detail": "orjson",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "orjson",
        "description": "orjson",
        "isExtraImport": true,
        "detail": "orjson",
        "documentation": {}
    },
    {
        "label": "safe_dump",
        "importPath": "yaml",
        "description": "yaml",
        "isExtraImport": true,
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "safe_load",
        "importPath": "yaml",
        "description": "yaml",
        "isExtraImport": true,
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "tomlkit",
        "description": "tomlkit",
        "isExtraImport": true,
        "detail": "tomlkit",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "tomlkit",
        "description": "tomlkit",
        "isExtraImport": true,
        "detail": "tomlkit",
        "documentation": {}
    },
    {
        "label": "dumps",
        "importPath": "ujson",
        "description": "ujson",
        "isExtraImport": true,
        "detail": "ujson",
        "documentation": {}
    },
    {
        "label": "loads",
        "importPath": "ujson",
        "description": "ujson",
        "isExtraImport": true,
        "detail": "ujson",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "MISSING",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "is_dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "attr",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "attr",
        "description": "attr",
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "NOTHING",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "Factory",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "resolve_types",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "has",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "resolve_types",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "NOTHING",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "fields",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "NOTHING",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "frozen",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "resolve_types",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "textwrap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "textwrap",
        "description": "textwrap",
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "attrs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "attrs",
        "description": "attrs",
        "detail": "attrs",
        "documentation": {}
    },
    {
        "label": "cattrs",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cattrs",
        "description": "cattrs",
        "detail": "cattrs",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "abc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "abc",
        "description": "abc",
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "zip_longest",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "EXTENSION_SUFFIXES",
        "importPath": "importlib.machinery",
        "description": "importlib.machinery",
        "isExtraImport": true,
        "detail": "importlib.machinery",
        "documentation": {}
    },
    {
        "label": "SourceFileLoader",
        "importPath": "importlib.machinery",
        "description": "importlib.machinery",
        "isExtraImport": true,
        "detail": "importlib.machinery",
        "documentation": {}
    },
    {
        "label": "lsprotocol.types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_CODE_ACTION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_CODE_LENS",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_COMPLETION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DECLARATION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DEFINITION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_COLOR",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_HIGHLIGHT",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_LINK",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_SYMBOL",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_FOLDING_RANGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_FORMATTING",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_HOVER",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_IMPLEMENTATION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_ON_TYPE_FORMATTING",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_RANGE_FORMATTING",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_REFERENCES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_RENAME",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SELECTION_RANGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SIGNATURE_HELP",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_PREPARE_CALL_HIERARCHY",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_CLOSE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_OPEN",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_SAVE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_LINKED_EDITING_RANGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_MONIKER",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SEMANTIC_TOKENS_FULL",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_WILL_SAVE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_TYPE_DEFINITION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_CREATE_FILES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_DELETE_FILES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_RENAME_FILES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_SYMBOL",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WILL_CREATE_FILES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WILL_DELETE_FILES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WILL_RENAME_FILES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientCapabilities",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ImplementationOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SaveOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensRegistrationOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensOptionsFullType1",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ServerCapabilities",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ServerCapabilitiesWorkspaceType",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSyncOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeDefinitionOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationOptions",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFoldersServerCapabilities",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PROGRESS",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_WORK_DONE_PROGRESS_CANCEL",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_WORK_DONE_PROGRESS_CREATE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ProgressParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ProgressToken",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressBegin",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressEnd",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressReport",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressCancelParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressCreateParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CANCEL_REQUEST",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CLIENT_REGISTER_CAPABILITY",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CLIENT_UNREGISTER_CAPABILITY",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "EXIT",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "INITIALIZE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "INITIALIZED",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "METHOD_TO_TYPES",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LOG_TRACE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SET_TRACE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SHUTDOWN",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_CHANGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_CLOSE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_OPEN",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_PUBLISH_DIAGNOSTICS",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_LOG_MESSAGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_SHOW_DOCUMENT",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_SHOW_MESSAGE",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_APPLY_EDIT",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_CONFIGURATION",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_EXECUTE_COMMAND",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_SEMANTIC_TOKENS_REFRESH",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ApplyWorkspaceEditParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ConfigurationParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Diagnostic",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeTextDocumentParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeWorkspaceFoldersParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidCloseTextDocumentParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidOpenTextDocumentParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeResult",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LogMessageParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LogTraceParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MessageType",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PublishDiagnosticsParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RegistrationParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ResponseErrorMessage",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SetTraceParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowDocumentParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowMessageParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TraceValues",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "UnregistrationParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceApplyEditResponse",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceEdit",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeResultServerInfoType",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientCapabilities",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ConfigurationParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Diagnostic",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MessageType",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RegistrationParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ServerCapabilities",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowDocumentParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSyncKind",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "UnregistrationParams",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceApplyEditResponse",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceEdit",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Range",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentContentChangeEvent",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentContentChangeEvent_Type1",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentItem",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSyncKind",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "VersionedTextDocumentIdentifier",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFolder",
        "importPath": "lsprotocol.types",
        "description": "lsprotocol.types",
        "isExtraImport": true,
        "detail": "lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "ATTR_COMMAND_TYPE",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_EXECUTE_IN_THREAD",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_FEATURE_TYPE",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_REGISTERED_NAME",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_REGISTERED_TYPE",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "PARAM_LS",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_FEATURE_TYPE",
        "importPath": "pygls.constants",
        "description": "pygls.constants",
        "isExtraImport": true,
        "detail": "pygls.constants",
        "documentation": {}
    },
    {
        "label": "CommandAlreadyRegisteredError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureAlreadyRegisteredError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "ThreadDecoratorError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcException",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcInternalError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcInvalidParams",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcMethodNotFound",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcRequestCancelled",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureNotificationError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureRequestError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "PyglsError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcException",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureRequestError",
        "importPath": "pygls.exceptions",
        "description": "pygls.exceptions",
        "isExtraImport": true,
        "detail": "pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "get_method_options_type",
        "importPath": "pygls.lsp",
        "description": "pygls.lsp",
        "isExtraImport": true,
        "detail": "pygls.lsp",
        "documentation": {}
    },
    {
        "label": "is_instance",
        "importPath": "pygls.lsp",
        "description": "pygls.lsp",
        "isExtraImport": true,
        "detail": "pygls.lsp",
        "documentation": {}
    },
    {
        "label": "ConfigCallbackType",
        "importPath": "pygls.lsp",
        "description": "pygls.lsp",
        "isExtraImport": true,
        "detail": "pygls.lsp",
        "documentation": {}
    },
    {
        "label": "ShowDocumentCallbackType",
        "importPath": "pygls.lsp",
        "description": "pygls.lsp",
        "isExtraImport": true,
        "detail": "pygls.lsp",
        "documentation": {}
    },
    {
        "label": "ConfigCallbackType",
        "importPath": "pygls.lsp",
        "description": "pygls.lsp",
        "isExtraImport": true,
        "detail": "pygls.lsp",
        "documentation": {}
    },
    {
        "label": "ShowDocumentCallbackType",
        "importPath": "pygls.lsp",
        "description": "pygls.lsp",
        "isExtraImport": true,
        "detail": "pygls.lsp",
        "documentation": {}
    },
    {
        "label": "Future",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "Future",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "Future",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "Future",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "LanguageServerProtocol",
        "importPath": "pygls.protocol",
        "description": "pygls.protocol",
        "isExtraImport": true,
        "detail": "pygls.protocol",
        "documentation": {}
    },
    {
        "label": "LanguageServerProtocol",
        "importPath": "pygls.protocol",
        "description": "pygls.protocol",
        "isExtraImport": true,
        "detail": "pygls.protocol",
        "documentation": {}
    },
    {
        "label": "default_converter",
        "importPath": "pygls.protocol",
        "description": "pygls.protocol",
        "isExtraImport": true,
        "detail": "pygls.protocol",
        "documentation": {}
    },
    {
        "label": "converters",
        "importPath": "lsprotocol",
        "description": "lsprotocol",
        "isExtraImport": true,
        "detail": "lsprotocol",
        "documentation": {}
    },
    {
        "label": "ServerCapabilitiesBuilder",
        "importPath": "pygls.capabilities",
        "description": "pygls.capabilities",
        "isExtraImport": true,
        "detail": "pygls.capabilities",
        "documentation": {}
    },
    {
        "label": "FeatureManager",
        "importPath": "pygls.feature_manager",
        "description": "pygls.feature_manager",
        "isExtraImport": true,
        "detail": "pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "assign_help_attrs",
        "importPath": "pygls.feature_manager",
        "description": "pygls.feature_manager",
        "isExtraImport": true,
        "detail": "pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "is_thread_function",
        "importPath": "pygls.feature_manager",
        "description": "pygls.feature_manager",
        "isExtraImport": true,
        "detail": "pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "from_fs_path",
        "importPath": "pygls.uris",
        "description": "pygls.uris",
        "isExtraImport": true,
        "detail": "pygls.uris",
        "documentation": {}
    },
    {
        "label": "to_fs_path",
        "importPath": "pygls.uris",
        "description": "pygls.uris",
        "isExtraImport": true,
        "detail": "pygls.uris",
        "documentation": {}
    },
    {
        "label": "uri_scheme",
        "importPath": "pygls.uris",
        "description": "pygls.uris",
        "isExtraImport": true,
        "detail": "pygls.uris",
        "documentation": {}
    },
    {
        "label": "Workspace",
        "importPath": "pygls.workspace",
        "description": "pygls.workspace",
        "isExtraImport": true,
        "detail": "pygls.workspace",
        "documentation": {}
    },
    {
        "label": "Workspace",
        "importPath": "pygls.workspace",
        "description": "pygls.workspace",
        "isExtraImport": true,
        "detail": "pygls.workspace",
        "documentation": {}
    },
    {
        "label": "IS_WIN",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "IS_PYODIDE",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "IS_WIN",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "protocol",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "server",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "uris",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "workspace",
        "importPath": "pygls",
        "description": "pygls",
        "isExtraImport": true,
        "detail": "pygls",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "pygls.progress",
        "description": "pygls.progress",
        "isExtraImport": true,
        "detail": "pygls.progress",
        "documentation": {}
    },
    {
        "label": "parse",
        "importPath": "urllib",
        "description": "urllib",
        "isExtraImport": true,
        "detail": "urllib",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "MetaPathFinder",
        "importPath": "importlib.abc",
        "description": "importlib.abc",
        "isExtraImport": true,
        "detail": "importlib.abc",
        "documentation": {}
    },
    {
        "label": "cache_from_source",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "decode_source",
        "importPath": "importlib.util",
        "description": "importlib.util",
        "isExtraImport": true,
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "install_import_hook",
        "importPath": "typeguard.importhook",
        "description": "typeguard.importhook",
        "isExtraImport": true,
        "detail": "typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "jsonrpc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jsonrpc",
        "description": "jsonrpc",
        "detail": "jsonrpc",
        "documentation": {}
    },
    {
        "label": "utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "utils",
        "description": "utils",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "MethodDispatcher",
        "importPath": "pyls_jsonrpc.dispatchers",
        "description": "pyls_jsonrpc.dispatchers",
        "isExtraImport": true,
        "detail": "pyls_jsonrpc.dispatchers",
        "documentation": {}
    },
    {
        "label": "Endpoint",
        "importPath": "pyls_jsonrpc.endpoint",
        "description": "pyls_jsonrpc.endpoint",
        "isExtraImport": true,
        "detail": "pyls_jsonrpc.endpoint",
        "documentation": {}
    },
    {
        "label": "JsonRpcStreamReader",
        "importPath": "pyls_jsonrpc.streams",
        "description": "pyls_jsonrpc.streams",
        "isExtraImport": true,
        "detail": "pyls_jsonrpc.streams",
        "documentation": {}
    },
    {
        "label": "JsonRpcStreamWriter",
        "importPath": "pyls_jsonrpc.streams",
        "description": "pyls_jsonrpc.streams",
        "isExtraImport": true,
        "detail": "pyls_jsonrpc.streams",
        "documentation": {}
    },
    {
        "label": "choice",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "assert_that",
        "importPath": "hamcrest",
        "description": "hamcrest",
        "isExtraImport": true,
        "detail": "hamcrest",
        "documentation": {}
    },
    {
        "label": "is_",
        "importPath": "hamcrest",
        "description": "hamcrest",
        "isExtraImport": true,
        "detail": "hamcrest",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "nox",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nox",
        "description": "nox",
        "detail": "nox",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir] + os.environ.get(\"PATH\", \"\").split(os.pathsep))\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"../lib/python3.8/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path.decode(\"utf-8\") if \"\" else path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".nox.setup.bin.activate_this",
        "description": ".nox.setup.bin.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".nox.setup.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "cmp_using",
        "kind": 2,
        "importPath": "bundled.libs.attr._cmp",
        "description": "bundled.libs.attr._cmp",
        "peekOfCode": "def cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):\n    \"\"\"",
        "detail": "bundled.libs.attr._cmp",
        "documentation": {}
    },
    {
        "label": "_operation_names",
        "kind": 5,
        "importPath": "bundled.libs.attr._cmp",
        "description": "bundled.libs.attr._cmp",
        "peekOfCode": "_operation_names = {\"eq\": \"==\", \"lt\": \"<\", \"le\": \"<=\", \"gt\": \">\", \"ge\": \">=\"}\ndef cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):",
        "detail": "bundled.libs.attr._cmp",
        "documentation": {}
    },
    {
        "label": "_AnnotationExtractor",
        "kind": 6,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "class _AnnotationExtractor:\n    \"\"\"\n    Extract type annotations from a callable, returning None whenever there\n    is none.\n    \"\"\"\n    __slots__ = [\"sig\"]\n    def __init__(self, callable):\n        try:\n            self.sig = inspect.signature(callable)\n        except (ValueError, TypeError):  # inspect failed",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "just_warn",
        "kind": 2,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "def just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )\nclass _AnnotationExtractor:\n    \"\"\"",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "make_set_closure_cell",
        "kind": 2,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "def make_set_closure_cell():\n    \"\"\"Return a function of two arguments (cell, value) which sets\n    the value stored in the closure cell `cell` to `value`.\n    \"\"\"\n    # pypy makes this easy. (It also supports the logic below, but\n    # why not do the easy/fast thing?)\n    if PYPY:\n        def set_closure_cell(cell, value):\n            cell.__setstate__((value,))\n        return set_closure_cell",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "PYPY",
        "kind": 5,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "PYPY = platform.python_implementation() == \"PyPy\"\nPY310 = sys.version_info[:2] >= (3, 10)\nPY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\ndef just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "PY310",
        "kind": 5,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "PY310 = sys.version_info[:2] >= (3, 10)\nPY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\ndef just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "PY_3_12_PLUS",
        "kind": 5,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "PY_3_12_PLUS = sys.version_info[:2] >= (3, 12)\ndef just_warn(*args, **kw):\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )\nclass _AnnotationExtractor:",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "set_closure_cell",
        "kind": 5,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "set_closure_cell = make_set_closure_cell()\n# Thread-local global to track attrs instances which are already being repr'd.\n# This is needed because there is no other (thread-safe) way to pass info\n# about the instances that are already being repr'd through the call stack\n# in order to ensure we don't perform infinite recursion.\n#\n# For instance, if an instance contains a dict which contains that instance,\n# we need to know that we're already repr'ing the outside instance from within\n# the dict's repr() call.\n#",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "repr_context",
        "kind": 5,
        "importPath": "bundled.libs.attr._compat",
        "description": "bundled.libs.attr._compat",
        "peekOfCode": "repr_context = threading.local()",
        "detail": "bundled.libs.attr._compat",
        "documentation": {}
    },
    {
        "label": "set_run_validators",
        "kind": 2,
        "importPath": "bundled.libs.attr._config",
        "description": "bundled.libs.attr._config",
        "peekOfCode": "def set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):\n        raise TypeError(\"'run' must be bool.\")\n    global _run_validators",
        "detail": "bundled.libs.attr._config",
        "documentation": {}
    },
    {
        "label": "get_run_validators",
        "kind": 2,
        "importPath": "bundled.libs.attr._config",
        "description": "bundled.libs.attr._config",
        "peekOfCode": "def get_run_validators():\n    \"\"\"\n    Return whether or not validators are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.get_disabled()`\n        instead.\n    \"\"\"\n    return _run_validators",
        "detail": "bundled.libs.attr._config",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.attr._config",
        "description": "bundled.libs.attr._config",
        "peekOfCode": "__all__ = [\"set_run_validators\", \"get_run_validators\"]\n_run_validators = True\ndef set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):",
        "detail": "bundled.libs.attr._config",
        "documentation": {}
    },
    {
        "label": "_run_validators",
        "kind": 5,
        "importPath": "bundled.libs.attr._config",
        "description": "bundled.libs.attr._config",
        "peekOfCode": "_run_validators = True\ndef set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    .. deprecated:: 21.3.0 It will not be removed, but it also will not be\n        moved to new ``attrs`` namespace. Use `attrs.validators.set_disabled()`\n        instead.\n    \"\"\"\n    if not isinstance(run, bool):\n        raise TypeError(\"'run' must be bool.\")",
        "detail": "bundled.libs.attr._config",
        "documentation": {}
    },
    {
        "label": "asdict",
        "kind": 2,
        "importPath": "bundled.libs.attr._funcs",
        "description": "bundled.libs.attr._funcs",
        "peekOfCode": "def asdict(\n    inst,\n    recurse=True,\n    filter=None,\n    dict_factory=dict,\n    retain_collection_types=False,\n    value_serializer=None,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a dict.",
        "detail": "bundled.libs.attr._funcs",
        "documentation": {}
    },
    {
        "label": "astuple",
        "kind": 2,
        "importPath": "bundled.libs.attr._funcs",
        "description": "bundled.libs.attr._funcs",
        "peekOfCode": "def astuple(\n    inst,\n    recurse=True,\n    filter=None,\n    tuple_factory=tuple,\n    retain_collection_types=False,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a tuple.\n    Optionally recurse into other ``attrs``-decorated classes.",
        "detail": "bundled.libs.attr._funcs",
        "documentation": {}
    },
    {
        "label": "has",
        "kind": 2,
        "importPath": "bundled.libs.attr._funcs",
        "description": "bundled.libs.attr._funcs",
        "peekOfCode": "def has(cls):\n    \"\"\"\n    Check whether *cls* is a class with ``attrs`` attributes.\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n    :rtype: bool\n    \"\"\"\n    return getattr(cls, \"__attrs_attrs__\", None) is not None\ndef assoc(inst, **changes):\n    \"\"\"",
        "detail": "bundled.libs.attr._funcs",
        "documentation": {}
    },
    {
        "label": "assoc",
        "kind": 2,
        "importPath": "bundled.libs.attr._funcs",
        "description": "bundled.libs.attr._funcs",
        "peekOfCode": "def assoc(inst, **changes):\n    \"\"\"\n    Copy *inst* and apply *changes*.\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n    :return: A copy of inst with *changes* incorporated.\n    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't\n        be found on *cls*.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.",
        "detail": "bundled.libs.attr._funcs",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "bundled.libs.attr._funcs",
        "description": "bundled.libs.attr._funcs",
        "peekOfCode": "def evolve(inst, **changes):\n    \"\"\"\n    Create a new instance, based on *inst* with *changes* applied.\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n    :return: A copy of inst with *changes* incorporated.\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.",
        "detail": "bundled.libs.attr._funcs",
        "documentation": {}
    },
    {
        "label": "resolve_types",
        "kind": 2,
        "importPath": "bundled.libs.attr._funcs",
        "description": "bundled.libs.attr._funcs",
        "peekOfCode": "def resolve_types(cls, globalns=None, localns=None, attribs=None):\n    \"\"\"\n    Resolve any strings and forward annotations in type annotations.\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only\n    use them for static type checking.\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, e.g. if the name only exists\n    inside a method, you may pass *globalns* or *localns* to specify other\n    dictionaries in which to look up these names. See the docs of",
        "detail": "bundled.libs.attr._funcs",
        "documentation": {}
    },
    {
        "label": "_Nothing",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"\n    NOTHING = enum.auto()\n    def __repr__(self):",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_CacheHashWrapper",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class _CacheHashWrapper(int):\n    \"\"\"\n    An integer subclass that pickles / copies as None\n    This is used for non-slots classes with ``cache_hash=True``, to avoid\n    serializing a potentially (even likely) invalid hash value. Since ``None``\n    is the default value for uncalculated hashes, whenever this is copied,\n    the copy's value for the hash should automatically reset.\n    See GH #613 for more details.\n    \"\"\"\n    def __reduce__(self, _none_constructor=type(None), _args=()):",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_ClassBuilder",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class _ClassBuilder:\n    \"\"\"\n    Iteratively build *one* class.\n    \"\"\"\n    __slots__ = (\n        \"_attr_names\",\n        \"_attrs\",\n        \"_base_attr_map\",\n        \"_base_names\",\n        \"_cache_hash\",",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class Attribute:\n    \"\"\"\n    *Read-only* representation of an attribute.\n    The class has *all* arguments of `attr.ib` (except for ``factory``\n    which is only syntactic sugar for ``default=Factory(...)`` plus the\n    following:\n    - ``name`` (`str`): The name of the attribute.\n    - ``alias`` (`str`): The __init__ parameter name of the attribute, after\n      any explicit overrides and default private-attribute-name handling.\n    - ``inherited`` (`bool`): Whether or not that attribute has been inherited",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_CountingAttr",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class _CountingAttr:\n    \"\"\"\n    Intermediate representation of attributes that uses a counter to preserve\n    the order in which the attributes have been defined.\n    *Internal* data structure of the attrs library.  Running into is most\n    likely the result of a bug like a forgotten `@attr.s` decorator.\n    \"\"\"\n    __slots__ = (\n        \"counter\",\n        \"_default\",",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "Factory",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class Factory:\n    \"\"\"\n    Stores a factory callable.\n    If passed as the default value to `attrs.field`, the factory is used to\n    generate a new value.\n    :param callable factory: A callable that takes either none or exactly one\n        mandatory positional argument depending on *takes_self*.\n    :param bool takes_self: Pass the partially initialized instance that is\n        being initialized as a positional argument.\n    .. versionadded:: 17.1.0  *takes_self*",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_AndValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "class _AndValidator:\n    \"\"\"\n    Compose many validators to a single one.\n    \"\"\"\n    _validators = attrib()\n    def __call__(self, inst, attr, value):\n        for v in self._validators:\n            v(inst, attr, value)\ndef and_(*validators):\n    \"\"\"",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "attrib",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def attrib(\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    cmp=None,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "attrs",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def attrs(\n    maybe_cls=None,\n    these=None,\n    repr_ns=None,\n    repr=None,\n    cmp=None,\n    hash=None,\n    init=None,\n    slots=False,\n    frozen=False,",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "fields",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def fields(cls):\n    \"\"\"\n    Return the tuple of ``attrs`` attributes for a class.\n    The tuple also allows accessing the fields by their names (see below for\n    examples).\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n    :rtype: tuple (with name accessors) of `attrs.Attribute`",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "fields_dict",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def fields_dict(cls):\n    \"\"\"\n    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n    keys are the attribute names.\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n    :rtype: dict\n    .. versionadded:: 18.1.0",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "validate",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def validate(inst):\n    \"\"\"\n    Validate all attributes on *inst* that have a validator.\n    Leaves all exceptions through.\n    :param inst: Instance of a class with ``attrs`` attributes.\n    \"\"\"\n    if _config._run_validators is False:\n        return\n    for a in fields(inst.__class__):\n        v = a.validator",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "make_class",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def make_class(name, attrs, bases=(object,), **attributes_arguments):\n    \"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n    :param str name: The name for the new class.\n    :param attrs: A list of names or a dictionary of mappings of names to\n        attributes.\n        The order is deduced from the order of the names or attributes inside\n        *attrs*.  Otherwise the order of the definition of the attributes is\n        used.\n    :type attrs: `list` or `dict`",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "and_",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def and_(*validators):\n    \"\"\"\n    A validator that composes multiple validators into one.\n    When called on a value, it runs all wrapped validators.\n    :param callables validators: Arbitrary number of validators.\n    .. versionadded:: 17.1.0\n    \"\"\"\n    vals = []\n    for validator in validators:\n        vals.extend(",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "def pipe(*converters):\n    \"\"\"\n    A converter that composes multiple converters into one.\n    When called on a value, it runs all wrapped converters, returning the\n    *last* value.\n    Type annotations will be inferred from the wrapped converters', if\n    they have any.\n    :param callables converters: Arbitrary number of converters.\n    .. versionadded:: 20.1.0\n    \"\"\"",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_obj_setattr",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_obj_setattr = object.__setattr__\n_init_converter_pat = \"__attr_converter_%s\"\n_init_factory_pat = \"__attr_factory_%s\"\n_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_init_converter_pat",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_init_converter_pat = \"__attr_converter_%s\"\n_init_factory_pat = \"__attr_factory_%s\"\n_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_init_factory_pat",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_init_factory_pat = \"__attr_factory_%s\"\n_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field\n# (when slots=True)",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_classvar_prefixes",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_classvar_prefixes = (\n    \"typing.ClassVar\",\n    \"t.ClassVar\",\n    \"ClassVar\",\n    \"typing_extensions.ClassVar\",\n)\n# we don't use a double-underscore prefix because that triggers\n# name mangling when trying to create a slot for the field\n# (when slots=True)\n_hash_cache_field = \"_attrs_cached_hash\"",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_hash_cache_field",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_hash_cache_field = \"_attrs_cached_hash\"\n_empty_metadata_singleton = types.MappingProxyType({})\n# Unique object for unequivocal getattr() defaults.\n_sentinel = object()\n_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_empty_metadata_singleton",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_empty_metadata_singleton = types.MappingProxyType({})\n# Unique object for unequivocal getattr() defaults.\n_sentinel = object()\n_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_sentinel",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_sentinel = object()\n_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_ng_default_on_setattr",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_ng_default_on_setattr = setters.pipe(setters.convert, setters.validate)\nclass _Nothing(enum.Enum):\n    \"\"\"\n    Sentinel to indicate the lack of a value when ``None`` is ambiguous.\n    If extending attrs, you can use ``typing.Literal[NOTHING]`` to show\n    that a value may be ``NOTHING``.\n    .. versionchanged:: 21.1.0 ``bool(NOTHING)`` is now False.\n    .. versionchanged:: 22.2.0 ``NOTHING`` is now an ``enum.Enum`` variant.\n    \"\"\"\n    NOTHING = enum.auto()",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "NOTHING",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "NOTHING = _Nothing.NOTHING\n\"\"\"\nSentinel to indicate the lack of a value when ``None`` is ambiguous.\n\"\"\"\nclass _CacheHashWrapper(int):\n    \"\"\"\n    An integer subclass that pickles / copies as None\n    This is used for non-slots classes with ``cache_hash=True``, to avoid\n    serializing a potentially (even likely) invalid hash value. Since ``None``\n    is the default value for uncalculated hashes, whenever this is copied,",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_Attributes",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_Attributes = _make_attr_tuple_class(\n    \"_Attributes\",\n    [\n        # all attributes to build dunder methods for\n        \"attrs\",\n        # attributes that have been inherited\n        \"base_attrs\",\n        # map inherited attributes to their originating classes\n        \"base_attrs_map\",\n    ],",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_attrs",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_attrs = attrs\n\"\"\"\nInternal alias so we can use it in functions that take an argument called\n*attrs*.\n\"\"\"\ndef _has_frozen_base_class(cls):\n    \"\"\"\n    Check whether *cls* has a frozen ancestor by looking at its\n    __setattr__.\n    \"\"\"",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_a",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_a = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=(name != \"metadata\"),",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "Attribute",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "Attribute = _add_hash(\n    _add_eq(\n        _add_repr(Attribute, attrs=_a),\n        attrs=[a for a in _a if a.name != \"inherited\"],\n    ),\n    attrs=[a for a in _a if a.hash and a.name != \"inherited\"],\n)\nclass _CountingAttr:\n    \"\"\"\n    Intermediate representation of attributes that uses a counter to preserve",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_CountingAttr",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_CountingAttr = _add_eq(_add_repr(_CountingAttr))\nclass Factory:\n    \"\"\"\n    Stores a factory callable.\n    If passed as the default value to `attrs.field`, the factory is used to\n    generate a new value.\n    :param callable factory: A callable that takes either none or exactly one\n        mandatory positional argument depending on *takes_self*.\n    :param bool takes_self: Pass the partially initialized instance that is\n        being initialized as a positional argument.",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "_f",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "_f = [\n    Attribute(\n        name=name,\n        default=NOTHING,\n        validator=None,\n        repr=True,\n        cmp=None,\n        eq=True,\n        order=False,\n        hash=True,",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "Factory",
        "kind": 5,
        "importPath": "bundled.libs.attr._make",
        "description": "bundled.libs.attr._make",
        "peekOfCode": "Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)\ndef make_class(name, attrs, bases=(object,), **attributes_arguments):\n    \"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n    :param str name: The name for the new class.\n    :param attrs: A list of names or a dictionary of mappings of names to\n        attributes.\n        The order is deduced from the order of the names or attributes inside\n        *attrs*.  Otherwise the order of the definition of the attributes is\n        used.",
        "detail": "bundled.libs.attr._make",
        "documentation": {}
    },
    {
        "label": "define",
        "kind": 2,
        "importPath": "bundled.libs.attr._next_gen",
        "description": "bundled.libs.attr._next_gen",
        "peekOfCode": "def define(\n    maybe_cls=None,\n    *,\n    these=None,\n    repr=None,\n    unsafe_hash=None,\n    hash=None,\n    init=None,\n    slots=True,\n    frozen=False,",
        "detail": "bundled.libs.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "field",
        "kind": 2,
        "importPath": "bundled.libs.attr._next_gen",
        "description": "bundled.libs.attr._next_gen",
        "peekOfCode": "def field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    converter=None,\n    factory=None,",
        "detail": "bundled.libs.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "asdict",
        "kind": 2,
        "importPath": "bundled.libs.attr._next_gen",
        "description": "bundled.libs.attr._next_gen",
        "peekOfCode": "def asdict(inst, *, recurse=True, filter=None, value_serializer=None):\n    \"\"\"\n    Same as `attr.asdict`, except that collections types are always retained\n    and dict is always used as *dict_factory*.\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _asdict(\n        inst=inst,\n        recurse=recurse,\n        filter=filter,",
        "detail": "bundled.libs.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "astuple",
        "kind": 2,
        "importPath": "bundled.libs.attr._next_gen",
        "description": "bundled.libs.attr._next_gen",
        "peekOfCode": "def astuple(inst, *, recurse=True, filter=None):\n    \"\"\"\n    Same as `attr.astuple`, except that collections types are always retained\n    and `tuple` is always used as the *tuple_factory*.\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _astuple(\n        inst=inst, recurse=recurse, filter=filter, retain_collection_types=True\n    )",
        "detail": "bundled.libs.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "mutable",
        "kind": 5,
        "importPath": "bundled.libs.attr._next_gen",
        "description": "bundled.libs.attr._next_gen",
        "peekOfCode": "mutable = define\nfrozen = partial(define, frozen=True, on_setattr=None)\ndef field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,",
        "detail": "bundled.libs.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "frozen",
        "kind": 5,
        "importPath": "bundled.libs.attr._next_gen",
        "description": "bundled.libs.attr._next_gen",
        "peekOfCode": "frozen = partial(define, frozen=True, on_setattr=None)\ndef field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    converter=None,",
        "detail": "bundled.libs.attr._next_gen",
        "documentation": {}
    },
    {
        "label": "VersionInfo",
        "kind": 6,
        "importPath": "bundled.libs.attr._version_info",
        "description": "bundled.libs.attr._version_info",
        "peekOfCode": "class VersionInfo:\n    \"\"\"\n    A version object that can be compared to tuple of length 1--4:\n    >>> attr.VersionInfo(19, 1, 0, \"final\")  <= (19, 2)\n    True\n    >>> attr.VersionInfo(19, 1, 0, \"final\") < (19, 1, 1)\n    True\n    >>> vi = attr.VersionInfo(19, 2, 0, \"final\")\n    >>> vi < (19, 1, 1)\n    False",
        "detail": "bundled.libs.attr._version_info",
        "documentation": {}
    },
    {
        "label": "optional",
        "kind": 2,
        "importPath": "bundled.libs.attr.converters",
        "description": "bundled.libs.attr.converters",
        "peekOfCode": "def optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to ``None``.\n    Type annotations will be inferred from the wrapped converter's, if it\n    has any.\n    :param callable converter: the converter that is used for non-``None``\n        values.\n    .. versionadded:: 17.1.0\n    \"\"\"",
        "detail": "bundled.libs.attr.converters",
        "documentation": {}
    },
    {
        "label": "default_if_none",
        "kind": 2,
        "importPath": "bundled.libs.attr.converters",
        "description": "bundled.libs.attr.converters",
        "peekOfCode": "def default_if_none(default=NOTHING, factory=None):\n    \"\"\"\n    A converter that allows to replace ``None`` values by *default* or the\n    result of *factory*.\n    :param default: Value to be used if ``None`` is passed. Passing an instance\n       of `attrs.Factory` is supported, however the ``takes_self`` option\n       is *not*.\n    :param callable factory: A callable that takes no parameters whose result\n       is used if ``None`` is passed.\n    :raises TypeError: If **neither** *default* or *factory* is passed.",
        "detail": "bundled.libs.attr.converters",
        "documentation": {}
    },
    {
        "label": "to_bool",
        "kind": 2,
        "importPath": "bundled.libs.attr.converters",
        "description": "bundled.libs.attr.converters",
        "peekOfCode": "def to_bool(val):\n    \"\"\"\n    Convert \"boolean\" strings (e.g., from env. vars.) to real booleans.\n    Values mapping to :code:`True`:\n    - :code:`True`\n    - :code:`\"true\"` / :code:`\"t\"`\n    - :code:`\"yes\"` / :code:`\"y\"`\n    - :code:`\"on\"`\n    - :code:`\"1\"`\n    - :code:`1`",
        "detail": "bundled.libs.attr.converters",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.attr.converters",
        "description": "bundled.libs.attr.converters",
        "peekOfCode": "__all__ = [\n    \"default_if_none\",\n    \"optional\",\n    \"pipe\",\n    \"to_bool\",\n]\ndef optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to ``None``.",
        "detail": "bundled.libs.attr.converters",
        "documentation": {}
    },
    {
        "label": "FrozenError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class FrozenError(AttributeError):\n    \"\"\"\n    A frozen/immutable instance or attribute have been attempted to be\n    modified.\n    It mirrors the behavior of ``namedtuples`` by using the same error message\n    and subclassing `AttributeError`.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    msg = \"can't set attribute\"\n    args = [msg]",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "FrozenInstanceError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class FrozenInstanceError(FrozenError):\n    \"\"\"\n    A frozen instance has been attempted to be modified.\n    .. versionadded:: 16.1.0\n    \"\"\"\nclass FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n    .. versionadded:: 20.1.0\n    \"\"\"",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "FrozenAttributeError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n    .. versionadded:: 20.1.0\n    \"\"\"\nclass AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An ``attrs`` function couldn't find an attribute that the user asked for.\n    .. versionadded:: 16.2.0\n    \"\"\"",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "AttrsAttributeNotFoundError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An ``attrs`` function couldn't find an attribute that the user asked for.\n    .. versionadded:: 16.2.0\n    \"\"\"\nclass NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-``attrs`` class has been passed into an ``attrs`` function.\n    .. versionadded:: 16.2.0\n    \"\"\"",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "NotAnAttrsClassError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-``attrs`` class has been passed into an ``attrs`` function.\n    .. versionadded:: 16.2.0\n    \"\"\"\nclass DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set using ``attr.ib()`` and is attempted to be reset\n    using the decorator.\n    .. versionadded:: 17.1.0",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "DefaultAlreadySetError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set using ``attr.ib()`` and is attempted to be reset\n    using the decorator.\n    .. versionadded:: 17.1.0\n    \"\"\"\nclass UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n    annotation.",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "UnannotatedAttributeError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n    annotation.\n    .. versionadded:: 17.3.0\n    \"\"\"\nclass PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an ``attrs`` feature that requires a newer Python\n    version.",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "PythonTooOldError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an ``attrs`` feature that requires a newer Python\n    version.\n    .. versionadded:: 18.2.0\n    \"\"\"\nclass NotCallableError(TypeError):\n    \"\"\"\n    A ``attr.ib()`` requiring a callable has been set with a value\n    that is not callable.",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "NotCallableError",
        "kind": 6,
        "importPath": "bundled.libs.attr.exceptions",
        "description": "bundled.libs.attr.exceptions",
        "peekOfCode": "class NotCallableError(TypeError):\n    \"\"\"\n    A ``attr.ib()`` requiring a callable has been set with a value\n    that is not callable.\n    .. versionadded:: 19.2.0\n    \"\"\"\n    def __init__(self, msg, value):\n        super(TypeError, self).__init__(msg, value)\n        self.msg = msg\n        self.value = value",
        "detail": "bundled.libs.attr.exceptions",
        "documentation": {}
    },
    {
        "label": "include",
        "kind": 2,
        "importPath": "bundled.libs.attr.filters",
        "description": "bundled.libs.attr.filters",
        "peekOfCode": "def include(*what):\n    \"\"\"\n    Include *what*.\n    :param what: What to include.\n    :type what: `list` of `type` or `attrs.Attribute`\\\\ s\n    :rtype: `callable`\n    \"\"\"\n    cls, attrs = _split_what(what)\n    def include_(attribute, value):\n        return value.__class__ in cls or attribute in attrs",
        "detail": "bundled.libs.attr.filters",
        "documentation": {}
    },
    {
        "label": "exclude",
        "kind": 2,
        "importPath": "bundled.libs.attr.filters",
        "description": "bundled.libs.attr.filters",
        "peekOfCode": "def exclude(*what):\n    \"\"\"\n    Exclude *what*.\n    :param what: What to exclude.\n    :type what: `list` of classes or `attrs.Attribute`\\\\ s.\n    :rtype: `callable`\n    \"\"\"\n    cls, attrs = _split_what(what)\n    def exclude_(attribute, value):\n        return value.__class__ not in cls and attribute not in attrs",
        "detail": "bundled.libs.attr.filters",
        "documentation": {}
    },
    {
        "label": "pipe",
        "kind": 2,
        "importPath": "bundled.libs.attr.setters",
        "description": "bundled.libs.attr.setters",
        "peekOfCode": "def pipe(*setters):\n    \"\"\"\n    Run all *setters* and return the return value of the last one.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    def wrapped_pipe(instance, attrib, new_value):\n        rv = new_value\n        for setter in setters:\n            rv = setter(instance, attrib, rv)\n        return rv",
        "detail": "bundled.libs.attr.setters",
        "documentation": {}
    },
    {
        "label": "frozen",
        "kind": 2,
        "importPath": "bundled.libs.attr.setters",
        "description": "bundled.libs.attr.setters",
        "peekOfCode": "def frozen(_, __, ___):\n    \"\"\"\n    Prevent an attribute to be modified.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    raise FrozenAttributeError()\ndef validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n    .. versionadded:: 20.1.0",
        "detail": "bundled.libs.attr.setters",
        "documentation": {}
    },
    {
        "label": "validate",
        "kind": 2,
        "importPath": "bundled.libs.attr.setters",
        "description": "bundled.libs.attr.setters",
        "peekOfCode": "def validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    if _config._run_validators is False:\n        return new_value\n    v = attrib.validator\n    if not v:\n        return new_value",
        "detail": "bundled.libs.attr.setters",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "bundled.libs.attr.setters",
        "description": "bundled.libs.attr.setters",
        "peekOfCode": "def convert(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s converter -- if it has one --  on *new_value* and return the\n    result.\n    .. versionadded:: 20.1.0\n    \"\"\"\n    c = attrib.converter\n    if c:\n        return c(new_value)\n    return new_value",
        "detail": "bundled.libs.attr.setters",
        "documentation": {}
    },
    {
        "label": "NO_OP",
        "kind": 5,
        "importPath": "bundled.libs.attr.setters",
        "description": "bundled.libs.attr.setters",
        "peekOfCode": "NO_OP = object()",
        "detail": "bundled.libs.attr.setters",
        "documentation": {}
    },
    {
        "label": "_InstanceOfValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _InstanceOfValidator:\n    type = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not isinstance(value, self.type):\n            raise TypeError(\n                \"'{name}' must be {type!r} (got {value!r} that is a \"\n                \"{actual!r}).\".format(",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_MatchesReValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _MatchesReValidator:\n    pattern = attrib()\n    match_func = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.match_func(value):\n            raise ValueError(\n                \"'{name}' must match regex {pattern!r}\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_ProvidesValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _ProvidesValidator:\n    interface = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.interface.providedBy(value):\n            raise TypeError(\n                \"'{name}' must provide {interface!r} which {value!r} \"\n                \"doesn't.\".format(",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_OptionalValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _OptionalValidator:\n    validator = attrib()\n    def __call__(self, inst, attr, value):\n        if value is None:\n            return\n        self.validator(inst, attr, value)\n    def __repr__(self):\n        return \"<optional validator for {what} or None>\".format(\n            what=repr(self.validator)\n        )",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_InValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _InValidator:\n    options = attrib()\n    def __call__(self, inst, attr, value):\n        try:\n            in_options = value in self.options\n        except TypeError:  # e.g. `1 in \"abc\"`\n            in_options = False\n        if not in_options:\n            raise ValueError(\n                \"'{name}' must be in {options!r} (got {value!r})\".format(",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_IsCallableValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _IsCallableValidator:\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not callable(value):\n            message = (\n                \"'{name}' must be callable \"\n                \"(got {value!r} that is a {actual!r}).\"\n            )",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_DeepIterable",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _DeepIterable:\n    member_validator = attrib(validator=is_callable())\n    iterable_validator = attrib(\n        default=None, validator=optional(is_callable())\n    )\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.iterable_validator is not None:",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_DeepMapping",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _DeepMapping:\n    key_validator = attrib(validator=is_callable())\n    value_validator = attrib(validator=is_callable())\n    mapping_validator = attrib(default=None, validator=optional(is_callable()))\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if self.mapping_validator is not None:\n            self.mapping_validator(inst, attr, value)",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_NumberValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _NumberValidator:\n    bound = attrib()\n    compare_op = attrib()\n    compare_func = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not self.compare_func(value, self.bound):\n            raise ValueError(",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_MaxLengthValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _MaxLengthValidator:\n    max_length = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) > self.max_length:\n            raise ValueError(\n                \"Length of '{name}' must be <= {max}: {len}\".format(\n                    name=attr.name, max=self.max_length, len=len(value)",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_MinLengthValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _MinLengthValidator:\n    min_length = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if len(value) < self.min_length:\n            raise ValueError(\n                \"Length of '{name}' must be => {min}: {len}\".format(\n                    name=attr.name, min=self.min_length, len=len(value)",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_SubclassOfValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _SubclassOfValidator:\n    type = attrib()\n    def __call__(self, inst, attr, value):\n        \"\"\"\n        We use a callable class to be able to change the ``__repr__``.\n        \"\"\"\n        if not issubclass(value, self.type):\n            raise TypeError(\n                \"'{name}' must be a subclass of {type!r} \"\n                \"(got {value!r}).\".format(",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "_NotValidator",
        "kind": 6,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "class _NotValidator:\n    validator = attrib()\n    msg = attrib(\n        converter=default_if_none(\n            \"not_ validator child '{validator!r}' \"\n            \"did not raise a captured error\"\n        )\n    )\n    exc_types = attrib(\n        validator=deep_iterable(",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "set_disabled",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def set_disabled(disabled):\n    \"\"\"\n    Globally disable or enable running validators.\n    By default, they are run.\n    :param disabled: If ``True``, disable running all validators.\n    :type disabled: bool\n    .. warning::\n        This function is not thread-safe!\n    .. versionadded:: 21.3.0\n    \"\"\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "get_disabled",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def get_disabled():\n    \"\"\"\n    Return a bool indicating whether validators are currently disabled or not.\n    :return: ``True`` if validators are currently disabled.\n    :rtype: bool\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return not get_run_validators()\n@contextmanager\ndef disabled():",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "disabled",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def disabled():\n    \"\"\"\n    Context manager that disables running validators within its context.\n    .. warning::\n        This context manager is not thread-safe!\n    .. versionadded:: 21.3.0\n    \"\"\"\n    set_run_validators(False)\n    try:\n        yield",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "instance_of",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def instance_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `isinstance` therefore it's also valid to pass a tuple of types).\n    :param type: The type to check for.\n    :type type: type or tuple of type\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected type, and the value it\n        got.",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "matches_re",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def matches_re(regex, flags=0, func=None):\n    r\"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string that doesn't match *regex*.\n    :param regex: a regex string or precompiled pattern to match against\n    :param int flags: flags that will be passed to the underlying re function\n        (default 0)\n    :param callable func: which underlying `re` function to call. Valid options\n        are `re.fullmatch`, `re.search`, and `re.match`; the default ``None``\n        means `re.fullmatch`. For performance reasons, the pattern is always",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "provides",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def provides(interface):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with an object that does not provide the requested *interface* (checks are\n    performed using ``interface.providedBy(value)`` (see `zope.interface\n    <https://zopeinterface.readthedocs.io/en/latest/>`_).\n    :param interface: The interface to check for.\n    :type interface: ``zope.interface.Interface``\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attrs.Attribute`), the expected interface, and the",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "optional",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def optional(validator):\n    \"\"\"\n    A validator that makes an attribute optional.  An optional attribute is one\n    which can be set to ``None`` in addition to satisfying the requirements of\n    the sub-validator.\n    :param validator: A validator (or a list of validators) that is used for\n        non-``None`` values.\n    :type validator: callable or `list` of callables.\n    .. versionadded:: 15.1.0\n    .. versionchanged:: 17.1.0 *validator* can be a list of validators.",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "in_",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def in_(options):\n    \"\"\"\n    A validator that raises a `ValueError` if the initializer is called\n    with a value that does not belong in the options provided.  The check is\n    performed using ``value in options``.\n    :param options: Allowed options.\n    :type options: list, tuple, `enum.Enum`, ...\n    :raises ValueError: With a human readable error message, the attribute (of\n       type `attrs.Attribute`), the expected options, and the value it\n       got.",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "is_callable",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def is_callable():\n    \"\"\"\n    A validator that raises a `attr.exceptions.NotCallableError` if the\n    initializer is called with a value for this particular attribute\n    that is not callable.\n    .. versionadded:: 19.1.0\n    :raises `attr.exceptions.NotCallableError`: With a human readable error\n        message containing the attribute (`attrs.Attribute`) name,\n        and the value it got.\n    \"\"\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "deep_iterable",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def deep_iterable(member_validator, iterable_validator=None):\n    \"\"\"\n    A validator that performs deep validation of an iterable.\n    :param member_validator: Validator(s) to apply to iterable members\n    :param iterable_validator: Validator to apply to iterable itself\n        (optional)\n    .. versionadded:: 19.1.0\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    if isinstance(member_validator, (list, tuple)):",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "deep_mapping",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def deep_mapping(key_validator, value_validator, mapping_validator=None):\n    \"\"\"\n    A validator that performs deep validation of a dictionary.\n    :param key_validator: Validator to apply to dictionary keys\n    :param value_validator: Validator to apply to dictionary values\n    :param mapping_validator: Validator to apply to top-level mapping\n        attribute (optional)\n    .. versionadded:: 19.1.0\n    :raises TypeError: if any sub-validators fail\n    \"\"\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "lt",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def lt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number larger or equal to *val*.\n    :param val: Exclusive upper bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<\", operator.lt)\ndef le(val):\n    \"\"\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "le",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def le(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number greater than *val*.\n    :param val: Inclusive upper bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \"<=\", operator.le)\ndef ge(val):\n    \"\"\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "ge",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def ge(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller than *val*.\n    :param val: Inclusive lower bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">=\", operator.ge)\ndef gt(val):\n    \"\"\"",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "gt",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def gt(val):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a number smaller or equal to *val*.\n    :param val: Exclusive lower bound for values\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _NumberValidator(val, \">\", operator.gt)\n@attrs(repr=False, frozen=True, slots=True)\nclass _MaxLengthValidator:",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "max_len",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def max_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is longer than *length*.\n    :param int length: Maximum length of the string or iterable\n    .. versionadded:: 21.3.0\n    \"\"\"\n    return _MaxLengthValidator(length)\n@attrs(repr=False, frozen=True, slots=True)\nclass _MinLengthValidator:",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "min_len",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def min_len(length):\n    \"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string or iterable that is shorter than *length*.\n    :param int length: Minimum length of the string or iterable\n    .. versionadded:: 22.1.0\n    \"\"\"\n    return _MinLengthValidator(length)\n@attrs(repr=False, slots=True, hash=True)\nclass _SubclassOfValidator:",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "not_",
        "kind": 2,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "def not_(validator, *, msg=None, exc_types=(ValueError, TypeError)):\n    \"\"\"\n    A validator that wraps and logically 'inverts' the validator passed to it.\n    It will raise a `ValueError` if the provided validator *doesn't* raise a\n    `ValueError` or `TypeError` (by default), and will suppress the exception\n    if the provided validator *does*.\n    Intended to be used with existing validators to compose logic without\n    needing to create inverted variants, for example, ``not_(in_(...))``.\n    :param validator: A validator to be logically inverted.\n    :param msg: Message to raise if validator fails.",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.attr.validators",
        "description": "bundled.libs.attr.validators",
        "peekOfCode": "__all__ = [\n    \"and_\",\n    \"deep_iterable\",\n    \"deep_mapping\",\n    \"disabled\",\n    \"ge\",\n    \"get_disabled\",\n    \"gt\",\n    \"in_\",\n    \"instance_of\",",
        "detail": "bundled.libs.attr.validators",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.bson",
        "description": "bundled.libs.cattr.preconf.bson",
        "peekOfCode": "__all__ = [\"BsonConverter\", \"configure_converter\", \"make_converter\"]",
        "detail": "bundled.libs.cattr.preconf.bson",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.json",
        "description": "bundled.libs.cattr.preconf.json",
        "peekOfCode": "__all__ = [\"configure_converter\", \"JsonConverter\", \"make_converter\"]",
        "detail": "bundled.libs.cattr.preconf.json",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.msgpack",
        "description": "bundled.libs.cattr.preconf.msgpack",
        "peekOfCode": "__all__ = [\"configure_converter\", \"make_converter\", \"MsgpackConverter\"]",
        "detail": "bundled.libs.cattr.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.orjson",
        "description": "bundled.libs.cattr.preconf.orjson",
        "peekOfCode": "__all__ = [\"configure_converter\", \"make_converter\", \"OrjsonConverter\"]",
        "detail": "bundled.libs.cattr.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.pyyaml",
        "description": "bundled.libs.cattr.preconf.pyyaml",
        "peekOfCode": "__all__ = [\"configure_converter\", \"make_converter\", \"PyyamlConverter\"]",
        "detail": "bundled.libs.cattr.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.tomlkit",
        "description": "bundled.libs.cattr.preconf.tomlkit",
        "peekOfCode": "__all__ = [\"configure_converter\", \"make_converter\", \"TomlkitConverter\"]",
        "detail": "bundled.libs.cattr.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.preconf.ujson",
        "description": "bundled.libs.cattr.preconf.ujson",
        "peekOfCode": "__all__ = [\"configure_converter\", \"make_converter\", UjsonConverter]",
        "detail": "bundled.libs.cattr.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.converters",
        "description": "bundled.libs.cattr.converters",
        "peekOfCode": "__all__ = [\"BaseConverter\", \"Converter\", \"GenConverter\", \"UnstructureStrategy\"]",
        "detail": "bundled.libs.cattr.converters",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.disambiguators",
        "description": "bundled.libs.cattr.disambiguators",
        "peekOfCode": "__all__ = [\"create_uniq_field_dis_func\"]",
        "detail": "bundled.libs.cattr.disambiguators",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.dispatch",
        "description": "bundled.libs.cattr.dispatch",
        "peekOfCode": "__all__ = [\"FunctionDispatch\", \"MultiStrategyDispatch\"]",
        "detail": "bundled.libs.cattr.dispatch",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.errors",
        "description": "bundled.libs.cattr.errors",
        "peekOfCode": "__all__ = [\n    \"BaseValidationError\",\n    \"ClassValidationError\",\n    \"ForbiddenExtraKeysError\",\n    \"IterableValidationError\",\n    \"StructureHandlerNotFoundError\",\n]",
        "detail": "bundled.libs.cattr.errors",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.cattr.gen",
        "description": "bundled.libs.cattr.gen",
        "peekOfCode": "__all__ = [\n    \"AttributeOverride\",\n    \"make_dict_structure_fn\",\n    \"make_dict_unstructure_fn\",\n    \"make_hetero_tuple_unstructure_fn\",\n    \"make_iterable_unstructure_fn\",\n    \"make_mapping_structure_fn\",\n    \"make_mapping_unstructure_fn\",\n    \"override\",\n]",
        "detail": "bundled.libs.cattr.gen",
        "documentation": {}
    },
    {
        "label": "Base85Bytes",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.bson",
        "description": "bundled.libs.cattrs.preconf.bson",
        "peekOfCode": "class Base85Bytes(bytes):\n    \"\"\"A subclass to help with binary key encoding/decoding.\"\"\"\nclass BsonConverter(Converter):\n    def dumps(\n        self,\n        obj: Any,\n        unstructure_as=None,\n        check_keys: bool = False,\n        codec_options: CodecOptions = DEFAULT_CODEC_OPTIONS,\n    ) -> bytes:",
        "detail": "bundled.libs.cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "BsonConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.bson",
        "description": "bundled.libs.cattrs.preconf.bson",
        "peekOfCode": "class BsonConverter(Converter):\n    def dumps(\n        self,\n        obj: Any,\n        unstructure_as=None,\n        check_keys: bool = False,\n        codec_options: CodecOptions = DEFAULT_CODEC_OPTIONS,\n    ) -> bytes:\n        return encode(\n            self.unstructure(obj, unstructure_as=unstructure_as),",
        "detail": "bundled.libs.cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.bson",
        "description": "bundled.libs.cattrs.preconf.bson",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the bson library.\n    * sets are serialized as lists\n    * byte mapping keys are base85-encoded into strings when unstructuring, and reverse\n    * non-string, non-byte mapping keys are coerced into strings when unstructuring\n    * a deserialization hook is registered for bson.ObjectId by default\n    \"\"\"\n    def gen_unstructure_mapping(cl: Any, unstructure_to=None):\n        key_handler = str",
        "detail": "bundled.libs.cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.bson",
        "description": "bundled.libs.cattrs.preconf.bson",
        "peekOfCode": "def make_converter(*args, **kwargs) -> BsonConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        AbstractSet: list,\n    }\n    res = BsonConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.bson",
        "description": "bundled.libs.cattrs.preconf.bson",
        "peekOfCode": "T = TypeVar(\"T\")\nclass Base85Bytes(bytes):\n    \"\"\"A subclass to help with binary key encoding/decoding.\"\"\"\nclass BsonConverter(Converter):\n    def dumps(\n        self,\n        obj: Any,\n        unstructure_as=None,\n        check_keys: bool = False,\n        codec_options: CodecOptions = DEFAULT_CODEC_OPTIONS,",
        "detail": "bundled.libs.cattrs.preconf.bson",
        "documentation": {}
    },
    {
        "label": "JsonConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.json",
        "description": "bundled.libs.cattrs.preconf.json",
        "peekOfCode": "class JsonConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: Union[bytes, str], cl: Type[T], **kwargs) -> T:\n        return self.structure(loads(data, **kwargs), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the stdlib json module.\n    * bytes are serialized as base64 strings\n    * datetimes are serialized as ISO 8601",
        "detail": "bundled.libs.cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.json",
        "description": "bundled.libs.cattrs.preconf.json",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the stdlib json module.\n    * bytes are serialized as base64 strings\n    * datetimes are serialized as ISO 8601\n    * counters are serialized as dicts\n    * sets are serialized as lists\n    \"\"\"\n    converter.register_unstructure_hook(\n        bytes, lambda v: (b85encode(v) if v else b\"\").decode(\"utf8\")",
        "detail": "bundled.libs.cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.json",
        "description": "bundled.libs.cattrs.preconf.json",
        "peekOfCode": "def make_converter(*args, **kwargs) -> JsonConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        AbstractSet: list,\n        Counter: dict,\n    }\n    res = JsonConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.json",
        "description": "bundled.libs.cattrs.preconf.json",
        "peekOfCode": "T = TypeVar(\"T\")\nclass JsonConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: Union[bytes, str], cl: Type[T], **kwargs) -> T:\n        return self.structure(loads(data, **kwargs), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the stdlib json module.\n    * bytes are serialized as base64 strings",
        "detail": "bundled.libs.cattrs.preconf.json",
        "documentation": {}
    },
    {
        "label": "MsgpackConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.msgpack",
        "description": "bundled.libs.cattrs.preconf.msgpack",
        "peekOfCode": "class MsgpackConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> bytes:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: bytes, cl: Type[T], **kwargs) -> T:\n        return self.structure(loads(data, **kwargs), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the msgpack library.\n    * datetimes are serialized as timestamp floats\n    * sets are serialized as lists",
        "detail": "bundled.libs.cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.msgpack",
        "description": "bundled.libs.cattrs.preconf.msgpack",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the msgpack library.\n    * datetimes are serialized as timestamp floats\n    * sets are serialized as lists\n    \"\"\"\n    converter.register_unstructure_hook(datetime, lambda v: v.timestamp())\n    converter.register_structure_hook(\n        datetime, lambda v, _: datetime.fromtimestamp(v, timezone.utc)\n    )",
        "detail": "bundled.libs.cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.msgpack",
        "description": "bundled.libs.cattrs.preconf.msgpack",
        "peekOfCode": "def make_converter(*args, **kwargs) -> MsgpackConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        AbstractSet: list,\n    }\n    res = MsgpackConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.msgpack",
        "description": "bundled.libs.cattrs.preconf.msgpack",
        "peekOfCode": "T = TypeVar(\"T\")\nclass MsgpackConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> bytes:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: bytes, cl: Type[T], **kwargs) -> T:\n        return self.structure(loads(data, **kwargs), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the msgpack library.\n    * datetimes are serialized as timestamp floats",
        "detail": "bundled.libs.cattrs.preconf.msgpack",
        "documentation": {}
    },
    {
        "label": "OrjsonConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.orjson",
        "description": "bundled.libs.cattrs.preconf.orjson",
        "peekOfCode": "class OrjsonConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> bytes:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: bytes, cl: Type[T]) -> T:\n        return self.structure(loads(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the orjson library.\n    * bytes are serialized as base85 strings\n    * datetimes are serialized as ISO 8601",
        "detail": "bundled.libs.cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.orjson",
        "description": "bundled.libs.cattrs.preconf.orjson",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the orjson library.\n    * bytes are serialized as base85 strings\n    * datetimes are serialized as ISO 8601\n    * sets are serialized as lists\n    * string enum mapping keys have special handling\n    * mapping keys are coerced into strings when unstructuring\n    \"\"\"\n    converter.register_unstructure_hook(",
        "detail": "bundled.libs.cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.orjson",
        "description": "bundled.libs.cattrs.preconf.orjson",
        "peekOfCode": "def make_converter(*args, **kwargs) -> OrjsonConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        AbstractSet: list,\n    }\n    res = OrjsonConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.orjson",
        "description": "bundled.libs.cattrs.preconf.orjson",
        "peekOfCode": "T = TypeVar(\"T\")\nclass OrjsonConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> bytes:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: bytes, cl: Type[T]) -> T:\n        return self.structure(loads(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the orjson library.\n    * bytes are serialized as base85 strings",
        "detail": "bundled.libs.cattrs.preconf.orjson",
        "documentation": {}
    },
    {
        "label": "PyyamlConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.pyyaml",
        "description": "bundled.libs.cattrs.preconf.pyyaml",
        "peekOfCode": "class PyyamlConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return safe_dump(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: str, cl: Type[T]) -> T:\n        return self.structure(safe_load(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the pyyaml library.\n    * frozensets are serialized as lists\n    * string enums are converted into strings explicitly",
        "detail": "bundled.libs.cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.pyyaml",
        "description": "bundled.libs.cattrs.preconf.pyyaml",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the pyyaml library.\n    * frozensets are serialized as lists\n    * string enums are converted into strings explicitly\n    \"\"\"\n    converter.register_unstructure_hook(\n        str, lambda v: v if v.__class__ is str else v.value\n    )\n    converter.register_structure_hook(datetime, validate_datetime)",
        "detail": "bundled.libs.cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.pyyaml",
        "description": "bundled.libs.cattrs.preconf.pyyaml",
        "peekOfCode": "def make_converter(*args, **kwargs) -> PyyamlConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        FrozenSetSubscriptable: list,\n    }\n    res = PyyamlConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.pyyaml",
        "description": "bundled.libs.cattrs.preconf.pyyaml",
        "peekOfCode": "T = TypeVar(\"T\")\nclass PyyamlConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return safe_dump(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: str, cl: Type[T]) -> T:\n        return self.structure(safe_load(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the pyyaml library.\n    * frozensets are serialized as lists",
        "detail": "bundled.libs.cattrs.preconf.pyyaml",
        "documentation": {}
    },
    {
        "label": "TomlkitConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.tomlkit",
        "description": "bundled.libs.cattrs.preconf.tomlkit",
        "peekOfCode": "class TomlkitConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: str, cl: Type[T]) -> T:\n        return self.structure(loads(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the tomlkit library.\n    * bytes are serialized as base85 strings\n    * sets are serialized as lists",
        "detail": "bundled.libs.cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.tomlkit",
        "description": "bundled.libs.cattrs.preconf.tomlkit",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the tomlkit library.\n    * bytes are serialized as base85 strings\n    * sets are serialized as lists\n    * tuples are serializas as lists\n    * mapping keys are coerced into strings when unstructuring\n    \"\"\"\n    converter.register_structure_hook(bytes, lambda v, _: b85decode(v))\n    converter.register_unstructure_hook(",
        "detail": "bundled.libs.cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.tomlkit",
        "description": "bundled.libs.cattrs.preconf.tomlkit",
        "peekOfCode": "def make_converter(*args, **kwargs) -> TomlkitConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        AbstractSet: list,\n        tuple: list,\n    }\n    res = TomlkitConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.tomlkit",
        "description": "bundled.libs.cattrs.preconf.tomlkit",
        "peekOfCode": "T = TypeVar(\"T\")\n_enum_value_getter = attrgetter(\"_value_\")\nclass TomlkitConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: str, cl: Type[T]) -> T:\n        return self.structure(loads(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the tomlkit library.",
        "detail": "bundled.libs.cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "_enum_value_getter",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.tomlkit",
        "description": "bundled.libs.cattrs.preconf.tomlkit",
        "peekOfCode": "_enum_value_getter = attrgetter(\"_value_\")\nclass TomlkitConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: str, cl: Type[T]) -> T:\n        return self.structure(loads(data), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the tomlkit library.\n    * bytes are serialized as base85 strings",
        "detail": "bundled.libs.cattrs.preconf.tomlkit",
        "documentation": {}
    },
    {
        "label": "UjsonConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.preconf.ujson",
        "description": "bundled.libs.cattrs.preconf.ujson",
        "peekOfCode": "class UjsonConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: AnyStr, cl: Type[T], **kwargs) -> T:\n        return self.structure(loads(data, **kwargs), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the ujson library.\n    * bytes are serialized as base64 strings\n    * datetimes are serialized as ISO 8601",
        "detail": "bundled.libs.cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "configure_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.ujson",
        "description": "bundled.libs.cattrs.preconf.ujson",
        "peekOfCode": "def configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the ujson library.\n    * bytes are serialized as base64 strings\n    * datetimes are serialized as ISO 8601\n    * sets are serialized as lists\n    \"\"\"\n    converter.register_unstructure_hook(\n        bytes, lambda v: (b85encode(v) if v else b\"\").decode(\"utf8\")\n    )",
        "detail": "bundled.libs.cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "make_converter",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.preconf.ujson",
        "description": "bundled.libs.cattrs.preconf.ujson",
        "peekOfCode": "def make_converter(*args, **kwargs) -> UjsonConverter:\n    kwargs[\"unstruct_collection_overrides\"] = {\n        **kwargs.get(\"unstruct_collection_overrides\", {}),\n        AbstractSet: list,\n    }\n    res = UjsonConverter(*args, **kwargs)\n    configure_converter(res)\n    return res",
        "detail": "bundled.libs.cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.preconf.ujson",
        "description": "bundled.libs.cattrs.preconf.ujson",
        "peekOfCode": "T = TypeVar(\"T\")\nclass UjsonConverter(Converter):\n    def dumps(self, obj: Any, unstructure_as=None, **kwargs) -> str:\n        return dumps(self.unstructure(obj, unstructure_as=unstructure_as), **kwargs)\n    def loads(self, data: AnyStr, cl: Type[T], **kwargs) -> T:\n        return self.structure(loads(data, **kwargs), cl)\ndef configure_converter(converter: BaseConverter):\n    \"\"\"\n    Configure the converter for use with the ujson library.\n    * bytes are serialized as base64 strings",
        "detail": "bundled.libs.cattrs.preconf.ujson",
        "documentation": {}
    },
    {
        "label": "has",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def has(cls):\n    return hasattr(cls, \"__attrs_attrs__\") or hasattr(cls, \"__dataclass_fields__\")\ndef has_with_generic(cls):\n    \"\"\"Test whether the class if a normal or generic attrs or dataclass.\"\"\"\n    return has(cls) or has(get_origin(cls))\ndef fields(type):\n    try:\n        return type.__attrs_attrs__\n    except AttributeError:\n        try:",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "has_with_generic",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def has_with_generic(cls):\n    \"\"\"Test whether the class if a normal or generic attrs or dataclass.\"\"\"\n    return has(cls) or has(get_origin(cls))\ndef fields(type):\n    try:\n        return type.__attrs_attrs__\n    except AttributeError:\n        try:\n            return dataclass_fields(type)\n        except AttributeError:",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "fields",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def fields(type):\n    try:\n        return type.__attrs_attrs__\n    except AttributeError:\n        try:\n            return dataclass_fields(type)\n        except AttributeError:\n            raise Exception(\"Not an attrs or dataclass class.\")\ndef adapted_fields(cl) -> List[Attribute]:\n    \"\"\"Return the attrs format of `fields()` for attrs and dataclasses.\"\"\"",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "adapted_fields",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def adapted_fields(cl) -> List[Attribute]:\n    \"\"\"Return the attrs format of `fields()` for attrs and dataclasses.\"\"\"\n    if is_dataclass(cl):\n        attrs = dataclass_fields(cl)\n        if any(isinstance(a.type, str) for a in attrs):\n            # Do this conditionally in case `get_type_hints` fails, so\n            # users can resolve on their own first.\n            type_hints = get_type_hints(cl)\n        else:\n            type_hints = {}",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_hetero_tuple",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def is_hetero_tuple(type: Any) -> bool:\n    origin = getattr(type, \"__origin__\", None)\n    return origin is tuple and ... not in type.__args__\ndef is_protocol(type: Any) -> bool:\n    return issubclass(type, Protocol) and getattr(type, \"_is_protocol\", False)\nOriginAbstractSet = AbcSet\nOriginMutableSet = AbcMutableSet\nif is_py37 or is_py38:\n    Set = TypingSet\n    AbstractSet = TypingAbstractSet",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_protocol",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def is_protocol(type: Any) -> bool:\n    return issubclass(type, Protocol) and getattr(type, \"_is_protocol\", False)\nOriginAbstractSet = AbcSet\nOriginMutableSet = AbcMutableSet\nif is_py37 or is_py38:\n    Set = TypingSet\n    AbstractSet = TypingAbstractSet\n    MutableSet = TypingMutableSet\n    Sequence = TypingSequence\n    MutableSequence = TypingMutableSequence",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_generic_attrs",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "def is_generic_attrs(type):\n    return is_generic(type) and has(type.__origin__)",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "version_info",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "version_info = sys.version_info[0:3]\nis_py37 = version_info[:2] == (3, 7)\nis_py38 = version_info[:2] == (3, 8)\nis_py39_plus = version_info[:2] >= (3, 9)\nis_py310_plus = version_info[:2] >= (3, 10)\nif is_py37:\n    def get_args(cl):\n        return cl.__args__\n    def get_origin(cl):\n        return getattr(cl, \"__origin__\", None)",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_py37",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "is_py37 = version_info[:2] == (3, 7)\nis_py38 = version_info[:2] == (3, 8)\nis_py39_plus = version_info[:2] >= (3, 9)\nis_py310_plus = version_info[:2] >= (3, 10)\nif is_py37:\n    def get_args(cl):\n        return cl.__args__\n    def get_origin(cl):\n        return getattr(cl, \"__origin__\", None)\n    from typing_extensions import Protocol",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_py38",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "is_py38 = version_info[:2] == (3, 8)\nis_py39_plus = version_info[:2] >= (3, 9)\nis_py310_plus = version_info[:2] >= (3, 10)\nif is_py37:\n    def get_args(cl):\n        return cl.__args__\n    def get_origin(cl):\n        return getattr(cl, \"__origin__\", None)\n    from typing_extensions import Protocol\nelse:",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_py39_plus",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "is_py39_plus = version_info[:2] >= (3, 9)\nis_py310_plus = version_info[:2] >= (3, 10)\nif is_py37:\n    def get_args(cl):\n        return cl.__args__\n    def get_origin(cl):\n        return getattr(cl, \"__origin__\", None)\n    from typing_extensions import Protocol\nelse:\n    from typing import Protocol, get_args, get_origin  # NOQA",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "is_py310_plus",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "is_py310_plus = version_info[:2] >= (3, 10)\nif is_py37:\n    def get_args(cl):\n        return cl.__args__\n    def get_origin(cl):\n        return getattr(cl, \"__origin__\", None)\n    from typing_extensions import Protocol\nelse:\n    from typing import Protocol, get_args, get_origin  # NOQA\nif \"ExceptionGroup\" not in dir(builtins):",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "OriginAbstractSet",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "OriginAbstractSet = AbcSet\nOriginMutableSet = AbcMutableSet\nif is_py37 or is_py38:\n    Set = TypingSet\n    AbstractSet = TypingAbstractSet\n    MutableSet = TypingMutableSet\n    Sequence = TypingSequence\n    MutableSequence = TypingMutableSequence\n    MutableMapping = TypingMutableMapping\n    Mapping = TypingMapping",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "OriginMutableSet",
        "kind": 5,
        "importPath": "bundled.libs.cattrs._compat",
        "description": "bundled.libs.cattrs._compat",
        "peekOfCode": "OriginMutableSet = AbcMutableSet\nif is_py37 or is_py38:\n    Set = TypingSet\n    AbstractSet = TypingAbstractSet\n    MutableSet = TypingMutableSet\n    Sequence = TypingSequence\n    MutableSequence = TypingMutableSequence\n    MutableMapping = TypingMutableMapping\n    Mapping = TypingMapping\n    FrozenSetSubscriptable = FrozenSet",
        "detail": "bundled.libs.cattrs._compat",
        "documentation": {}
    },
    {
        "label": "deep_copy_with",
        "kind": 2,
        "importPath": "bundled.libs.cattrs._generics",
        "description": "bundled.libs.cattrs._generics",
        "peekOfCode": "def deep_copy_with(t, mapping: Mapping[str, Any]):\n    args = get_args(t)\n    rest = ()\n    if is_annotated(t) and args:\n        # If we're dealing with `Annotated`, we only map the first type parameter\n        rest = tuple(args[1:])\n        args = (args[0],)\n    new_args = (\n        tuple(\n            mapping[a.__name__]",
        "detail": "bundled.libs.cattrs._generics",
        "documentation": {}
    },
    {
        "label": "UnstructureStrategy",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "class UnstructureStrategy(Enum):\n    \"\"\"`attrs` classes unstructuring strategies.\"\"\"\n    AS_DICT = \"asdict\"\n    AS_TUPLE = \"astuple\"\ndef _subclass(typ: Type) -> Callable[[Type], bool]:\n    \"\"\"a shortcut\"\"\"\n    return lambda cls: issubclass(cls, typ)\ndef is_attrs_union(typ: Type) -> bool:\n    return is_union_type(typ) and all(has(get_origin(e) or e) for e in typ.__args__)\ndef is_attrs_union_or_none(typ: Type) -> bool:",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "BaseConverter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "class BaseConverter:\n    \"\"\"Converts between structured and unstructured data.\"\"\"\n    __slots__ = (\n        \"_dis_func_cache\",\n        \"_unstructure_func\",\n        \"_unstructure_attrs\",\n        \"_structure_attrs\",\n        \"_dict_factory\",\n        \"_union_struct_registry\",\n        \"_structure_func\",",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "Converter",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "class Converter(BaseConverter):\n    \"\"\"A converter which generates specialized un/structuring functions.\"\"\"\n    __slots__ = (\n        \"omit_if_default\",\n        \"forbid_extra_keys\",\n        \"type_overrides\",\n        \"_unstruct_collection_overrides\",\n        \"_struct_copy_skip\",\n        \"_unstruct_copy_skip\",\n    )",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "is_attrs_union",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "def is_attrs_union(typ: Type) -> bool:\n    return is_union_type(typ) and all(has(get_origin(e) or e) for e in typ.__args__)\ndef is_attrs_union_or_none(typ: Type) -> bool:\n    return is_union_type(typ) and all(\n        e is NoneType or has(get_origin(e) or e) for e in typ.__args__\n    )\ndef is_optional(typ: Type) -> bool:\n    return is_union_type(typ) and NoneType in typ.__args__ and len(typ.__args__) == 2\ndef is_literal_containing_enums(typ: Type) -> bool:\n    return is_literal(typ) and any(isinstance(val, Enum) for val in typ.__args__)",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "is_attrs_union_or_none",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "def is_attrs_union_or_none(typ: Type) -> bool:\n    return is_union_type(typ) and all(\n        e is NoneType or has(get_origin(e) or e) for e in typ.__args__\n    )\ndef is_optional(typ: Type) -> bool:\n    return is_union_type(typ) and NoneType in typ.__args__ and len(typ.__args__) == 2\ndef is_literal_containing_enums(typ: Type) -> bool:\n    return is_literal(typ) and any(isinstance(val, Enum) for val in typ.__args__)\nclass BaseConverter:\n    \"\"\"Converts between structured and unstructured data.\"\"\"",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "is_optional",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "def is_optional(typ: Type) -> bool:\n    return is_union_type(typ) and NoneType in typ.__args__ and len(typ.__args__) == 2\ndef is_literal_containing_enums(typ: Type) -> bool:\n    return is_literal(typ) and any(isinstance(val, Enum) for val in typ.__args__)\nclass BaseConverter:\n    \"\"\"Converts between structured and unstructured data.\"\"\"\n    __slots__ = (\n        \"_dis_func_cache\",\n        \"_unstructure_func\",\n        \"_unstructure_attrs\",",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "is_literal_containing_enums",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "def is_literal_containing_enums(typ: Type) -> bool:\n    return is_literal(typ) and any(isinstance(val, Enum) for val in typ.__args__)\nclass BaseConverter:\n    \"\"\"Converts between structured and unstructured data.\"\"\"\n    __slots__ = (\n        \"_dis_func_cache\",\n        \"_unstructure_func\",\n        \"_unstructure_attrs\",\n        \"_structure_attrs\",\n        \"_dict_factory\",",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "NoneType",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "NoneType = type(None)\nT = TypeVar(\"T\")\nV = TypeVar(\"V\")\nclass UnstructureStrategy(Enum):\n    \"\"\"`attrs` classes unstructuring strategies.\"\"\"\n    AS_DICT = \"asdict\"\n    AS_TUPLE = \"astuple\"\ndef _subclass(typ: Type) -> Callable[[Type], bool]:\n    \"\"\"a shortcut\"\"\"\n    return lambda cls: issubclass(cls, typ)",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "T = TypeVar(\"T\")\nV = TypeVar(\"V\")\nclass UnstructureStrategy(Enum):\n    \"\"\"`attrs` classes unstructuring strategies.\"\"\"\n    AS_DICT = \"asdict\"\n    AS_TUPLE = \"astuple\"\ndef _subclass(typ: Type) -> Callable[[Type], bool]:\n    \"\"\"a shortcut\"\"\"\n    return lambda cls: issubclass(cls, typ)\ndef is_attrs_union(typ: Type) -> bool:",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "V",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "V = TypeVar(\"V\")\nclass UnstructureStrategy(Enum):\n    \"\"\"`attrs` classes unstructuring strategies.\"\"\"\n    AS_DICT = \"asdict\"\n    AS_TUPLE = \"astuple\"\ndef _subclass(typ: Type) -> Callable[[Type], bool]:\n    \"\"\"a shortcut\"\"\"\n    return lambda cls: issubclass(cls, typ)\ndef is_attrs_union(typ: Type) -> bool:\n    return is_union_type(typ) and all(has(get_origin(e) or e) for e in typ.__args__)",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "GenConverter",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.converters",
        "description": "bundled.libs.cattrs.converters",
        "peekOfCode": "GenConverter = Converter",
        "detail": "bundled.libs.cattrs.converters",
        "documentation": {}
    },
    {
        "label": "create_uniq_field_dis_func",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.disambiguators",
        "description": "bundled.libs.cattrs.disambiguators",
        "peekOfCode": "def create_uniq_field_dis_func(\n    *classes: Type[Any],\n) -> Callable[[Mapping[Any, Any]], Optional[Type[Any]]]:\n    \"\"\"Given attr classes, generate a disambiguation function.\n    The function is based on unique fields.\"\"\"\n    if len(classes) < 2:\n        raise ValueError(\"At least two classes required.\")\n    cls_and_attrs = [\n        (cl, set(at.name for at in fields(get_origin(cl) or cl))) for cl in classes\n    ]",
        "detail": "bundled.libs.cattrs.disambiguators",
        "documentation": {}
    },
    {
        "label": "_DispatchNotFound",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.dispatch",
        "description": "bundled.libs.cattrs.dispatch",
        "peekOfCode": "class _DispatchNotFound:\n    \"\"\"A dummy object to help signify a dispatch not found.\"\"\"\n    pass\nclass MultiStrategyDispatch:\n    \"\"\"\n    MultiStrategyDispatch uses a combination of exact-match dispatch,\n    singledispatch, and FunctionDispatch.\n    \"\"\"\n    __slots__ = (\n        \"_direct_dispatch\",",
        "detail": "bundled.libs.cattrs.dispatch",
        "documentation": {}
    },
    {
        "label": "MultiStrategyDispatch",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.dispatch",
        "description": "bundled.libs.cattrs.dispatch",
        "peekOfCode": "class MultiStrategyDispatch:\n    \"\"\"\n    MultiStrategyDispatch uses a combination of exact-match dispatch,\n    singledispatch, and FunctionDispatch.\n    \"\"\"\n    __slots__ = (\n        \"_direct_dispatch\",\n        \"_function_dispatch\",\n        \"_single_dispatch\",\n        \"_generators\",",
        "detail": "bundled.libs.cattrs.dispatch",
        "documentation": {}
    },
    {
        "label": "FunctionDispatch",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.dispatch",
        "description": "bundled.libs.cattrs.dispatch",
        "peekOfCode": "class FunctionDispatch:\n    \"\"\"\n    FunctionDispatch is similar to functools.singledispatch, but\n    instead dispatches based on functions that take the type of the\n    first argument in the method, and return True or False.\n    objects that help determine dispatch should be instantiated objects.\n    \"\"\"\n    _handler_pairs: list = attr.ib(factory=list)\n    def register(self, can_handle: Callable[[Any], bool], func, is_generator=False):\n        self._handler_pairs.insert(0, (can_handle, func, is_generator))",
        "detail": "bundled.libs.cattrs.dispatch",
        "documentation": {}
    },
    {
        "label": "StructureHandlerNotFoundError",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.errors",
        "description": "bundled.libs.cattrs.errors",
        "peekOfCode": "class StructureHandlerNotFoundError(Exception):\n    \"\"\"Error raised when structuring cannot find a handler for converting inputs into :attr:`type_`.\"\"\"\n    def __init__(self, message: str, type_: Type) -> None:\n        super().__init__(message)\n        self.type_ = type_\nclass BaseValidationError(ExceptionGroup):\n    cl: Type\n    def __new__(cls, message, excs, cl: Type):\n        obj = super().__new__(cls, message, excs)\n        obj.cl = cl",
        "detail": "bundled.libs.cattrs.errors",
        "documentation": {}
    },
    {
        "label": "BaseValidationError",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.errors",
        "description": "bundled.libs.cattrs.errors",
        "peekOfCode": "class BaseValidationError(ExceptionGroup):\n    cl: Type\n    def __new__(cls, message, excs, cl: Type):\n        obj = super().__new__(cls, message, excs)\n        obj.cl = cl\n        return obj\n    def derive(self, excs):\n        return ClassValidationError(self.message, excs, self.cl)\nclass IterableValidationError(BaseValidationError):\n    \"\"\"Raised when structuring an iterable.\"\"\"",
        "detail": "bundled.libs.cattrs.errors",
        "documentation": {}
    },
    {
        "label": "IterableValidationError",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.errors",
        "description": "bundled.libs.cattrs.errors",
        "peekOfCode": "class IterableValidationError(BaseValidationError):\n    \"\"\"Raised when structuring an iterable.\"\"\"\n    pass\nclass ClassValidationError(BaseValidationError):\n    \"\"\"Raised when validating a class if any attributes are invalid.\"\"\"\n    pass\nclass ForbiddenExtraKeysError(Exception):\n    \"\"\"Raised when `forbid_extra_keys` is activated and such extra keys are detected during structuring.\n    The attribute `extra_fields` is a sequence of those extra keys, which were the cause of this error,\n    and `cl` is the class which was structured with those extra keys.",
        "detail": "bundled.libs.cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ClassValidationError",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.errors",
        "description": "bundled.libs.cattrs.errors",
        "peekOfCode": "class ClassValidationError(BaseValidationError):\n    \"\"\"Raised when validating a class if any attributes are invalid.\"\"\"\n    pass\nclass ForbiddenExtraKeysError(Exception):\n    \"\"\"Raised when `forbid_extra_keys` is activated and such extra keys are detected during structuring.\n    The attribute `extra_fields` is a sequence of those extra keys, which were the cause of this error,\n    and `cl` is the class which was structured with those extra keys.\n    \"\"\"\n    def __init__(\n        self, message: Optional[str], cl: Type, extra_fields: Set[str]",
        "detail": "bundled.libs.cattrs.errors",
        "documentation": {}
    },
    {
        "label": "ForbiddenExtraKeysError",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.errors",
        "description": "bundled.libs.cattrs.errors",
        "peekOfCode": "class ForbiddenExtraKeysError(Exception):\n    \"\"\"Raised when `forbid_extra_keys` is activated and such extra keys are detected during structuring.\n    The attribute `extra_fields` is a sequence of those extra keys, which were the cause of this error,\n    and `cl` is the class which was structured with those extra keys.\n    \"\"\"\n    def __init__(\n        self, message: Optional[str], cl: Type, extra_fields: Set[str]\n    ) -> None:\n        self.cl = cl\n        self.extra_fields = extra_fields",
        "detail": "bundled.libs.cattrs.errors",
        "documentation": {}
    },
    {
        "label": "AttributeOverride",
        "kind": 6,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "class AttributeOverride:\n    omit_if_default: Optional[bool] = None\n    rename: Optional[str] = None\n    omit: bool = False  # Omit the field completely.\ndef override(\n    omit_if_default: Optional[bool] = None,\n    rename: Optional[str] = None,\n    omit: bool = False,\n):\n    return AttributeOverride(omit_if_default=omit_if_default, rename=rename, omit=omit)",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "override",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def override(\n    omit_if_default: Optional[bool] = None,\n    rename: Optional[str] = None,\n    omit: bool = False,\n):\n    return AttributeOverride(omit_if_default=omit_if_default, rename=rename, omit=omit)\n_neutral = AttributeOverride()\n_already_generating = local()\nT = TypeVar(\"T\")\ndef make_dict_unstructure_fn(",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_dict_unstructure_fn",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def make_dict_unstructure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    _cattrs_omit_if_default: bool = False,\n    _cattrs_use_linecache: bool = True,\n    **kwargs: AttributeOverride,\n) -> Callable[[T], Dict[str, Any]]:\n    \"\"\"\n    Generate a specialized dict unstructuring function for an attrs class or a\n    dataclass.",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_dict_structure_fn",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def make_dict_structure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    _cattrs_forbid_extra_keys: bool = False,\n    _cattrs_use_linecache: bool = True,\n    _cattrs_prefer_attrib_converters: bool = False,\n    _cattrs_detailed_validation: bool = True,\n    **kwargs: AttributeOverride,\n) -> DictStructureFn[T]:\n    \"\"\"Generate a specialized dict structuring function for an attrs class.\"\"\"",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_iterable_unstructure_fn",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def make_iterable_unstructure_fn(\n    cl: Any, converter: \"BaseConverter\", unstructure_to: Any = None\n) -> IterableUnstructureFn:\n    \"\"\"Generate a specialized unstructure function for an iterable.\"\"\"\n    handler = converter.unstructure\n    fn_name = \"unstructure_iterable\"\n    # Let's try fishing out the type args\n    # Unspecified tuples have `__args__` as empty tuples, so guard\n    # against IndexError.\n    if getattr(cl, \"__args__\", None) not in (None, ()):",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_hetero_tuple_unstructure_fn",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def make_hetero_tuple_unstructure_fn(\n    cl: Any, converter: \"BaseConverter\", unstructure_to: Any = None\n) -> HeteroTupleUnstructureFn:\n    \"\"\"Generate a specialized unstructure function for a heterogenous tuple.\"\"\"\n    fn_name = \"unstructure_tuple\"\n    type_args = get_args(cl)\n    # We can do the dispatch here and now.\n    handlers = [\n        converter._unstructure_func.dispatch(type_arg) for type_arg in type_args\n    ]",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_mapping_unstructure_fn",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def make_mapping_unstructure_fn(\n    cl: Any,\n    converter: \"BaseConverter\",\n    unstructure_to: Any = None,\n    key_handler: Optional[Callable[[Any, Optional[Any]], Any]] = None,\n) -> MappingUnstructureFn:\n    \"\"\"Generate a specialized unstructure function for a mapping.\"\"\"\n    kh = key_handler or converter.unstructure\n    val_handler = converter.unstructure\n    fn_name = \"unstructure_mapping\"",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "make_mapping_structure_fn",
        "kind": 2,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "def make_mapping_structure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    structure_to: Type = dict,\n    key_type=NOTHING,\n    val_type=NOTHING,\n    detailed_validation: bool = True,\n) -> MappingStructureFn[T]:\n    \"\"\"Generate a specialized unstructure function for a mapping.\"\"\"\n    fn_name = \"structure_mapping\"",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "_neutral",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "_neutral = AttributeOverride()\n_already_generating = local()\nT = TypeVar(\"T\")\ndef make_dict_unstructure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    _cattrs_omit_if_default: bool = False,\n    _cattrs_use_linecache: bool = True,\n    **kwargs: AttributeOverride,\n) -> Callable[[T], Dict[str, Any]]:",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "_already_generating",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "_already_generating = local()\nT = TypeVar(\"T\")\ndef make_dict_unstructure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    _cattrs_omit_if_default: bool = False,\n    _cattrs_use_linecache: bool = True,\n    **kwargs: AttributeOverride,\n) -> Callable[[T], Dict[str, Any]]:\n    \"\"\"",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "T = TypeVar(\"T\")\ndef make_dict_unstructure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    _cattrs_omit_if_default: bool = False,\n    _cattrs_use_linecache: bool = True,\n    **kwargs: AttributeOverride,\n) -> Callable[[T], Dict[str, Any]]:\n    \"\"\"\n    Generate a specialized dict unstructuring function for an attrs class or a",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "DictStructureFn",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "DictStructureFn = Callable[[Mapping[str, Any], Any], T]\ndef make_dict_structure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    _cattrs_forbid_extra_keys: bool = False,\n    _cattrs_use_linecache: bool = True,\n    _cattrs_prefer_attrib_converters: bool = False,\n    _cattrs_detailed_validation: bool = True,\n    **kwargs: AttributeOverride,\n) -> DictStructureFn[T]:",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "IterableUnstructureFn",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "IterableUnstructureFn = Callable[[Iterable[Any]], Any]\ndef make_iterable_unstructure_fn(\n    cl: Any, converter: \"BaseConverter\", unstructure_to: Any = None\n) -> IterableUnstructureFn:\n    \"\"\"Generate a specialized unstructure function for an iterable.\"\"\"\n    handler = converter.unstructure\n    fn_name = \"unstructure_iterable\"\n    # Let's try fishing out the type args\n    # Unspecified tuples have `__args__` as empty tuples, so guard\n    # against IndexError.",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "HeteroTupleUnstructureFn",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "HeteroTupleUnstructureFn = Callable[[Tuple[Any, ...]], Any]\ndef make_hetero_tuple_unstructure_fn(\n    cl: Any, converter: \"BaseConverter\", unstructure_to: Any = None\n) -> HeteroTupleUnstructureFn:\n    \"\"\"Generate a specialized unstructure function for a heterogenous tuple.\"\"\"\n    fn_name = \"unstructure_tuple\"\n    type_args = get_args(cl)\n    # We can do the dispatch here and now.\n    handlers = [\n        converter._unstructure_func.dispatch(type_arg) for type_arg in type_args",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "MappingUnstructureFn",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "MappingUnstructureFn = Callable[[Mapping[Any, Any]], Any]\ndef make_mapping_unstructure_fn(\n    cl: Any,\n    converter: \"BaseConverter\",\n    unstructure_to: Any = None,\n    key_handler: Optional[Callable[[Any, Optional[Any]], Any]] = None,\n) -> MappingUnstructureFn:\n    \"\"\"Generate a specialized unstructure function for a mapping.\"\"\"\n    kh = key_handler or converter.unstructure\n    val_handler = converter.unstructure",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "MappingStructureFn",
        "kind": 5,
        "importPath": "bundled.libs.cattrs.gen",
        "description": "bundled.libs.cattrs.gen",
        "peekOfCode": "MappingStructureFn = Callable[[Mapping[Any, Any], Any], T]\ndef make_mapping_structure_fn(\n    cl: Type[T],\n    converter: \"BaseConverter\",\n    structure_to: Type = dict,\n    key_type=NOTHING,\n    val_type=NOTHING,\n    detailed_validation: bool = True,\n) -> MappingStructureFn[T]:\n    \"\"\"Generate a specialized unstructure function for a mapping.\"\"\"",
        "detail": "bundled.libs.cattrs.gen",
        "documentation": {}
    },
    {
        "label": "_Catcher",
        "kind": 6,
        "importPath": "bundled.libs.exceptiongroup._catch",
        "description": "bundled.libs.exceptiongroup._catch",
        "peekOfCode": "class _Catcher:\n    def __init__(self, handler_map: Mapping[tuple[type[BaseException], ...], _Handler]):\n        self._handler_map = handler_map\n    def __enter__(self) -> None:\n        pass\n    def __exit__(\n        self,\n        etype: type[BaseException] | None,\n        exc: BaseException | None,\n        tb: TracebackType | None,",
        "detail": "bundled.libs.exceptiongroup._catch",
        "documentation": {}
    },
    {
        "label": "catch",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._catch",
        "description": "bundled.libs.exceptiongroup._catch",
        "peekOfCode": "def catch(\n    __handlers: Mapping[type[BaseException] | Iterable[type[BaseException]], _Handler]\n) -> AbstractContextManager[None]:\n    if not isinstance(__handlers, Mapping):\n        raise TypeError(\"the argument must be a mapping\")\n    handler_map: dict[\n        tuple[type[BaseException], ...], Callable[[BaseExceptionGroup]]\n    ] = {}\n    for type_or_iterable, handler in __handlers.items():\n        iterable: tuple[type[BaseException]]",
        "detail": "bundled.libs.exceptiongroup._catch",
        "documentation": {}
    },
    {
        "label": "BaseExceptionGroup",
        "kind": 6,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):\n    \"\"\"A combination of multiple unrelated exceptions.\"\"\"\n    def __new__(\n        cls, __message: str, __exceptions: Sequence[_BaseExceptionT_co]\n    ) -> Self:\n        if not isinstance(__message, str):\n            raise TypeError(f\"argument 1 must be str, not {type(__message)}\")\n        if not isinstance(__exceptions, Sequence):\n            raise TypeError(\"second argument (exceptions) must be a sequence\")\n        if not __exceptions:",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "ExceptionGroup",
        "kind": 6,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):\n    def __new__(cls, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> Self:\n        return super().__new__(cls, __message, __exceptions)\n    if TYPE_CHECKING:\n        @property\n        def exceptions(\n            self,\n        ) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]:\n            ...\n        @overload  # type: ignore[override]",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "check_direct_subclass",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "def check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False\ndef get_condition_filter(\n    condition: type[_BaseExceptionT]\n    | tuple[type[_BaseExceptionT], ...]",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "get_condition_filter",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "def get_condition_filter(\n    condition: type[_BaseExceptionT]\n    | tuple[type[_BaseExceptionT], ...]\n    | Callable[[_BaseExceptionT_co], bool]\n) -> Callable[[_BaseExceptionT_co], bool]:\n    if isclass(condition) and issubclass(\n        cast(Type[BaseException], condition), BaseException\n    ):\n        return partial(check_direct_subclass, parents=(condition,))\n    elif isinstance(condition, tuple):",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_BaseExceptionT_co",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "_BaseExceptionT_co = TypeVar(\"_BaseExceptionT_co\", bound=BaseException, covariant=True)\n_BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_BaseExceptionT",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "_BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_ExceptionT_co",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "_ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True)\n_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False\ndef get_condition_filter(",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_ExceptionT",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._exceptions",
        "description": "bundled.libs.exceptiongroup._exceptions",
        "peekOfCode": "_ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\ndef check_direct_subclass(\n    exc: BaseException, parents: tuple[type[BaseException]]\n) -> bool:\n    for cls in getmro(exc.__class__)[:-1]:\n        if cls in parents:\n            return True\n    return False\ndef get_condition_filter(\n    condition: type[_BaseExceptionT]",
        "detail": "bundled.libs.exceptiongroup._exceptions",
        "documentation": {}
    },
    {
        "label": "_ExceptionPrintContext",
        "kind": 6,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "class _ExceptionPrintContext:\n    def __init__(self):\n        self.seen = set()\n        self.exception_group_depth = 0\n        self.need_close = False\n    def indent(self):\n        return \" \" * (2 * self.exception_group_depth)\n    def emit(self, text_gen, margin_char=None):\n        if margin_char is None:\n            margin_char = \"|\"",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "PatchedTracebackException",
        "kind": 6,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "class PatchedTracebackException(traceback.TracebackException):\n    def __init__(\n        self,\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: TracebackType | None,\n        *,\n        limit: int | None = None,\n        lookup_lines: bool = True,\n        capture_locals: bool = False,",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "exceptiongroup_excepthook",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "def exceptiongroup_excepthook(\n    etype: type[BaseException], value: BaseException, tb: TracebackType | None\n) -> None:\n    sys.stderr.write(\"\".join(traceback.format_exception(etype, value, tb)))\nclass PatchedTracebackException(traceback.TracebackException):\n    def __init__(\n        self,\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: TracebackType | None,",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "format_exception_only",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "def format_exception_only(__exc: BaseException) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, None, compact=True\n        ).format_exception_only()\n    )\n@format_exception_only.register\ndef _(__exc: type, value: BaseException) -> List[str]:\n    return format_exception_only(value)\n@singledispatch",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "format_exception",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "def format_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    chain: bool = True,\n) -> List[str]:\n    return list(\n        PatchedTracebackException(\n            type(__exc), __exc, __exc.__traceback__, limit=limit, compact=True\n        ).format(chain=chain)\n    )",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "print_exception",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "def print_exception(\n    __exc: BaseException,\n    limit: Optional[int] = None,\n    file: Any = None,\n    chain: bool = True,\n) -> None:\n    if file is None:\n        file = sys.stderr\n    for line in PatchedTracebackException(\n        type(__exc), __exc, __exc.__traceback__, limit=limit",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "print_exc",
        "kind": 2,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "def print_exc(\n    limit: Optional[int] = None,\n    file: Any | None = None,\n    chain: bool = True,\n) -> None:\n    value = sys.exc_info()[1]\n    print_exception(value, limit, file, chain)\n# Python levenshtein edit distance code for NameError/AttributeError\n# suggestions, backported from 3.12\n_MAX_CANDIDATE_ITEMS = 750",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "max_group_width",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "max_group_width = 15\nmax_group_depth = 10\n_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "max_group_depth",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "max_group_depth = 10\n_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_cause_message",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_cause_message = (\n    \"\\nThe above exception was the direct cause of the following exception:\\n\\n\"\n)\n_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:\n        line = f\"{etype}\\n\"",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_context_message",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_context_message = (\n    \"\\nDuring handling of the above exception, another exception occurred:\\n\\n\"\n)\ndef _format_final_exc_line(etype, value):\n    valuestr = _safe_string(value, \"exception\")\n    if value is None or not valuestr:\n        line = f\"{etype}\\n\"\n    else:\n        line = f\"{etype}: {valuestr}\\n\"\n    return line",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "traceback_exception_original_format",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "traceback_exception_original_format = traceback.TracebackException.format\ntraceback_exception_original_format_exception_only = (\n    traceback.TracebackException.format_exception_only\n)\ntraceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "traceback_exception_original_format_exception_only",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "traceback_exception_original_format_exception_only = (\n    traceback.TracebackException.format_exception_only\n)\ntraceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "traceback_exception_format_syntax_error",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "traceback_exception_format_syntax_error = getattr(\n    traceback.TracebackException, \"_format_syntax_error\", None\n)\nif sys.excepthook is sys.__excepthook__:\n    traceback.TracebackException.__init__ = (  # type: ignore[assignment]\n        PatchedTracebackException.__init__\n    )\n    traceback.TracebackException.format = (  # type: ignore[assignment]\n        PatchedTracebackException.format\n    )",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_MAX_CANDIDATE_ITEMS",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_MAX_CANDIDATE_ITEMS = 750\n_MAX_STRING_SIZE = 40\n_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_MAX_STRING_SIZE",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_MAX_STRING_SIZE = 40\n_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_MOVE_COST",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_MOVE_COST = 2\n_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\ndef _compute_suggestion_error(exc_value, tb):",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_CASE_COST",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_CASE_COST = 1\n_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\ndef _compute_suggestion_error(exc_value, tb):\n    wrong_name = getattr(exc_value, \"name\", None)",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "_SENTINEL",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._formatting",
        "description": "bundled.libs.exceptiongroup._formatting",
        "peekOfCode": "_SENTINEL = object()\ndef _substitution_cost(ch_a, ch_b):\n    if ch_a == ch_b:\n        return 0\n    if ch_a.lower() == ch_b.lower():\n        return _CASE_COST\n    return _MOVE_COST\ndef _compute_suggestion_error(exc_value, tb):\n    wrong_name = getattr(exc_value, \"name\", None)\n    if wrong_name is None or not isinstance(wrong_name, str):",
        "detail": "bundled.libs.exceptiongroup._formatting",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._version",
        "description": "bundled.libs.exceptiongroup._version",
        "peekOfCode": "__version__ = version = '1.1.0'\n__version_tuple__ = version_tuple = (1, 1, 0)",
        "detail": "bundled.libs.exceptiongroup._version",
        "documentation": {}
    },
    {
        "label": "__version_tuple__",
        "kind": 5,
        "importPath": "bundled.libs.exceptiongroup._version",
        "description": "bundled.libs.exceptiongroup._version",
        "peekOfCode": "__version_tuple__ = version_tuple = (1, 1, 0)",
        "detail": "bundled.libs.exceptiongroup._version",
        "documentation": {}
    },
    {
        "label": "register_hooks",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol._hooks",
        "description": "bundled.libs.lsprotocol._hooks",
        "peekOfCode": "def register_hooks(converter: cattrs.Converter) -> cattrs.Converter:\n    _resolve_forward_references()\n    converter = _register_capabilities_hooks(converter)\n    converter = _register_required_structure_hooks(converter)\n    return _register_custom_property_hooks(converter)\ndef _register_capabilities_hooks(converter: cattrs.Converter) -> cattrs.Converter:\n    def _text_document_sync_hook(\n        object_: Any, _: type\n    ) -> Union[OptionalPrimitive, lsp_types.TextDocumentSyncOptions]:\n        if object_ is None:",
        "detail": "bundled.libs.lsprotocol._hooks",
        "documentation": {}
    },
    {
        "label": "LSPAny",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol._hooks",
        "description": "bundled.libs.lsprotocol._hooks",
        "peekOfCode": "LSPAny = lsp_types.LSPAny\nOptionalPrimitive = Optional[Union[bool, int, str, float]]\n# Flag to ensure we only resolve forward references once.\n_resolved_forward_references = False\ndef _resolve_forward_references() -> None:\n    \"\"\"Resolve forward references for faster processing with cattrs.\"\"\"\n    global _resolved_forward_references\n    if not _resolved_forward_references:\n        def _filter(p: Tuple[str, Union[type, object]]) -> bool:\n            return isinstance(p[1], type) and attrs.has(p[1])",
        "detail": "bundled.libs.lsprotocol._hooks",
        "documentation": {}
    },
    {
        "label": "OptionalPrimitive",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol._hooks",
        "description": "bundled.libs.lsprotocol._hooks",
        "peekOfCode": "OptionalPrimitive = Optional[Union[bool, int, str, float]]\n# Flag to ensure we only resolve forward references once.\n_resolved_forward_references = False\ndef _resolve_forward_references() -> None:\n    \"\"\"Resolve forward references for faster processing with cattrs.\"\"\"\n    global _resolved_forward_references\n    if not _resolved_forward_references:\n        def _filter(p: Tuple[str, Union[type, object]]) -> bool:\n            return isinstance(p[1], type) and attrs.has(p[1])\n        # Creating a concrete list here because `resolve_types` mutates the provided map.",
        "detail": "bundled.libs.lsprotocol._hooks",
        "documentation": {}
    },
    {
        "label": "_resolved_forward_references",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol._hooks",
        "description": "bundled.libs.lsprotocol._hooks",
        "peekOfCode": "_resolved_forward_references = False\ndef _resolve_forward_references() -> None:\n    \"\"\"Resolve forward references for faster processing with cattrs.\"\"\"\n    global _resolved_forward_references\n    if not _resolved_forward_references:\n        def _filter(p: Tuple[str, Union[type, object]]) -> bool:\n            return isinstance(p[1], type) and attrs.has(p[1])\n        # Creating a concrete list here because `resolve_types` mutates the provided map.\n        items = list(filter(_filter, lsp_types.ALL_TYPES_MAP.items()))\n        for _, value in items:",
        "detail": "bundled.libs.lsprotocol._hooks",
        "documentation": {}
    },
    {
        "label": "get_converter",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.converters",
        "description": "bundled.libs.lsprotocol.converters",
        "peekOfCode": "def get_converter(\n    converter: Optional[cattrs.Converter] = None,\n) -> cattrs.Converter:\n    \"\"\"Adds cattrs hooks for LSP lsp_types to the given converter.\"\"\"\n    if converter is None:\n        converter = cattrs.Converter()\n    return _hooks.register_hooks(converter)",
        "detail": "bundled.libs.lsprotocol.converters",
        "documentation": {}
    },
    {
        "label": "SemanticTokenTypes",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokenTypes(str, enum.Enum):\n    \"\"\"A set of predefined token types. This set is not fixed an clients can\n    specify additional token types via the corresponding client capabilities.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    Namespace = \"namespace\"\n    Type = \"type\"\n    \"\"\"Represents a generic type.\n    Acts as a fallback for types which can't be mapped to a specific",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokenModifiers",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokenModifiers(str, enum.Enum):\n    \"\"\"A set of predefined token modifiers. This set is not fixed an clients\n    can specify additional token types via the corresponding client\n    capabilities.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    Declaration = \"declaration\"\n    Definition = \"definition\"\n    Readonly = \"readonly\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentDiagnosticReportKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentDiagnosticReportKind(str, enum.Enum):\n    \"\"\"The document diagnostic report kinds.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    Full = \"full\"\n    \"\"\"A diagnostic report with a full set of problems.\"\"\"\n    Unchanged = \"unchanged\"\n    \"\"\"A report indicating that the last returned report is still accurate.\"\"\"\nclass ErrorCodes(int, enum.Enum):",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ErrorCodes",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ErrorCodes(int, enum.Enum):\n    \"\"\"Predefined error codes.\"\"\"\n    ParseError = -32700\n    InvalidRequest = -32600\n    MethodNotFound = -32601\n    InvalidParams = -32602\n    InternalError = -32603\n    ServerNotInitialized = -32002\n    \"\"\"Error code indicating that a server received a notification or request\n    before the server has received the `initialize` request.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LSPErrorCodes",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LSPErrorCodes(int, enum.Enum):\n    RequestFailed = -32803\n    \"\"\"A request failed but it was syntactically correct, e.g the method name\n    was known and the parameters were valid. The error message should contain\n    human readable information about why the request failed.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    ServerCancelled = -32802\n    \"\"\"The server cancelled the request. This error code should only be used",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeKind(str, enum.Enum):\n    \"\"\"A set of predefined range kinds.\"\"\"\n    Comment = \"comment\"\n    \"\"\"Folding range for a comment.\"\"\"\n    Imports = \"imports\"\n    \"\"\"Folding range for an import or include.\"\"\"\n    Region = \"region\"\n    \"\"\"Folding range for a region (e.g. `#region`)\"\"\"\n@enum.unique\nclass SymbolKind(int, enum.Enum):",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SymbolKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SymbolKind(int, enum.Enum):\n    \"\"\"A symbol kind.\"\"\"\n    File = 1\n    Module = 2\n    Namespace = 3\n    Package = 4\n    Class = 5\n    Method = 6\n    Property = 7\n    Field = 8",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SymbolTag",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SymbolTag(int, enum.Enum):\n    \"\"\"Symbol tags are extra annotations that tweak the rendering of a symbol.\n    @since 3.16\n    \"\"\"\n    # Since: 3.16\n    Deprecated = 1\n    \"\"\"Render a symbol as obsolete, usually using a strike-out.\"\"\"\n@enum.unique\nclass UniquenessLevel(str, enum.Enum):\n    \"\"\"Moniker uniqueness level to define scope of the moniker.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "UniquenessLevel",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class UniquenessLevel(str, enum.Enum):\n    \"\"\"Moniker uniqueness level to define scope of the moniker.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    Document = \"document\"\n    \"\"\"The moniker is only unique inside a document.\"\"\"\n    Project = \"project\"\n    \"\"\"The moniker is unique inside a project for which a dump got created.\"\"\"\n    Group = \"group\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MonikerKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MonikerKind(str, enum.Enum):\n    \"\"\"The moniker kind.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    Import = \"import\"\n    \"\"\"The moniker represent a symbol that is imported into a project.\"\"\"\n    Export = \"export\"\n    \"\"\"The moniker represents a symbol that is exported from a project.\"\"\"\n    Local = \"local\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintKind(int, enum.Enum):\n    \"\"\"Inlay hint kinds.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    Type = 1\n    \"\"\"An inlay hint that for a type annotation.\"\"\"\n    Parameter = 2\n    \"\"\"An inlay hint that is for a parameter.\"\"\"\n@enum.unique",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MessageType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MessageType(int, enum.Enum):\n    \"\"\"The message type.\"\"\"\n    Error = 1\n    \"\"\"An error message.\"\"\"\n    Warning = 2\n    \"\"\"A warning message.\"\"\"\n    Info = 3\n    \"\"\"An information message.\"\"\"\n    Log = 4\n    \"\"\"A log message.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSyncKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSyncKind(int, enum.Enum):\n    \"\"\"Defines how the host (editor) should sync document changes to the\n    language server.\"\"\"\n    None_ = 0\n    \"\"\"Documents should not be synced at all.\"\"\"\n    Full = 1\n    \"\"\"Documents are synced by always sending the full content of the\n    document.\"\"\"\n    Incremental = 2\n    \"\"\"Documents are synced by sending the full content on open.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSaveReason",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSaveReason(int, enum.Enum):\n    \"\"\"Represents reasons why a text document is saved.\"\"\"\n    Manual = 1\n    \"\"\"Manually triggered, e.g. by the user pressing save, by starting\n    debugging, or by an API call.\"\"\"\n    AfterDelay = 2\n    \"\"\"Automatic after a delay.\"\"\"\n    FocusOut = 3\n    \"\"\"When the editor lost focus.\"\"\"\n@enum.unique",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionItemKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionItemKind(int, enum.Enum):\n    \"\"\"The kind of a completion entry.\"\"\"\n    Text = 1\n    Method = 2\n    Function = 3\n    Constructor = 4\n    Field = 5\n    Variable = 6\n    Class = 7\n    Interface = 8",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionItemTag",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionItemTag(int, enum.Enum):\n    \"\"\"Completion item tags are extra annotations that tweak the rendering of a\n    completion item.\n    @since 3.15.0\n    \"\"\"\n    # Since: 3.15.0\n    Deprecated = 1\n    \"\"\"Render a completion as obsolete, usually using a strike-out.\"\"\"\n@enum.unique\nclass InsertTextFormat(int, enum.Enum):",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InsertTextFormat",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InsertTextFormat(int, enum.Enum):\n    \"\"\"Defines whether the insert text in a completion item should be\n    interpreted as plain text or a snippet.\"\"\"\n    PlainText = 1\n    \"\"\"The primary text to be inserted is treated as a plain string.\"\"\"\n    Snippet = 2\n    \"\"\"The primary text to be inserted is treated as a snippet.\n    A snippet can define tab stops and placeholders with `$1`, `$2`\n    and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n    the end of the snippet. Placeholders with equal identifiers are linked,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InsertTextMode",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InsertTextMode(int, enum.Enum):\n    \"\"\"How whitespace and indentation is handled during completion item\n    insertion.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    AsIs = 1\n    \"\"\"The insertion or replace strings is taken as it is.\n    If the value is multi line the lines below the cursor will be\n    inserted using the indentation defined in the string value. The",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentHighlightKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentHighlightKind(int, enum.Enum):\n    \"\"\"A document highlight kind.\"\"\"\n    Text = 1\n    \"\"\"A textual occurrence.\"\"\"\n    Read = 2\n    \"\"\"Read-access of a symbol, like reading a variable.\"\"\"\n    Write = 3\n    \"\"\"Write-access of a symbol, like writing to a variable.\"\"\"\n@enum.unique\nclass CodeActionKind(str, enum.Enum):",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionKind(str, enum.Enum):\n    \"\"\"A set of predefined code action kinds.\"\"\"\n    Empty = \"\"\n    \"\"\"Empty kind.\"\"\"\n    QuickFix = \"quickfix\"\n    \"\"\"Base kind for quickfix actions: 'quickfix'.\"\"\"\n    Refactor = \"refactor\"\n    \"\"\"Base kind for refactoring actions: 'refactor'.\"\"\"\n    RefactorExtract = \"refactor.extract\"\n    \"\"\"Base kind for refactoring extraction actions: 'refactor.extract'.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TraceValues",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TraceValues(str, enum.Enum):\n    Off = \"off\"\n    \"\"\"Turn tracing off.\"\"\"\n    Messages = \"messages\"\n    \"\"\"Trace messages only.\"\"\"\n    Verbose = \"verbose\"\n    \"\"\"Verbose message tracing.\"\"\"\n@enum.unique\nclass MarkupKind(str, enum.Enum):\n    \"\"\"Describes the content type that a client supports in various result",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MarkupKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MarkupKind(str, enum.Enum):\n    \"\"\"Describes the content type that a client supports in various result\n    literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n    Please note that `MarkupKinds` must not start with a `$`. This kinds\n    are reserved for internal usage.\n    \"\"\"\n    PlainText = \"plaintext\"\n    \"\"\"Plain text is supported as a content format.\"\"\"\n    Markdown = \"markdown\"\n    \"\"\"Markdown is supported as a content format.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PositionEncodingKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PositionEncodingKind(str, enum.Enum):\n    \"\"\"A set of predefined position encoding kinds.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    Utf8 = \"utf-8\"\n    \"\"\"Character offsets count UTF-8 code units.\"\"\"\n    Utf16 = \"utf-16\"\n    \"\"\"Character offsets count UTF-16 code units.\n    This is the default and must always be supported by servers",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileChangeType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileChangeType(int, enum.Enum):\n    \"\"\"The file event type.\"\"\"\n    Created = 1\n    \"\"\"The file got created.\"\"\"\n    Changed = 2\n    \"\"\"The file got changed.\"\"\"\n    Deleted = 3\n    \"\"\"The file got deleted.\"\"\"\n@enum.unique\nclass WatchKind(int, enum.Enum):",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WatchKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WatchKind(int, enum.Enum):\n    Create = 1\n    \"\"\"Interested in create events.\"\"\"\n    Change = 2\n    \"\"\"Interested in change events.\"\"\"\n    Delete = 4\n    \"\"\"Interested in delete events.\"\"\"\n@enum.unique\nclass DiagnosticSeverity(int, enum.Enum):\n    \"\"\"The diagnostic's severity.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticSeverity",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticSeverity(int, enum.Enum):\n    \"\"\"The diagnostic's severity.\"\"\"\n    Error = 1\n    \"\"\"Reports an error.\"\"\"\n    Warning = 2\n    \"\"\"Reports a warning.\"\"\"\n    Information = 3\n    \"\"\"Reports an information.\"\"\"\n    Hint = 4\n    \"\"\"Reports a hint.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticTag",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticTag(int, enum.Enum):\n    \"\"\"The diagnostic tags.\n    @since 3.15.0\n    \"\"\"\n    # Since: 3.15.0\n    Unnecessary = 1\n    \"\"\"Unused or unnecessary code.\n    Clients are allowed to render diagnostics with this tag faded out\n    instead of having an error squiggle.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionTriggerKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionTriggerKind(int, enum.Enum):\n    \"\"\"How a completion was triggered.\"\"\"\n    Invoked = 1\n    \"\"\"Completion was triggered by typing an identifier (24x7 code complete),\n    manual invocation (e.g Ctrl+Space) or via API.\"\"\"\n    TriggerCharacter = 2\n    \"\"\"Completion was triggered by a trigger character specified by the\n    `triggerCharacters` properties of the `CompletionRegistrationOptions`.\"\"\"\n    TriggerForIncompleteCompletions = 3\n    \"\"\"Completion was re-triggered as current completion list is incomplete.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpTriggerKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpTriggerKind(int, enum.Enum):\n    \"\"\"How a signature help was triggered.\n    @since 3.15.0\n    \"\"\"\n    # Since: 3.15.0\n    Invoked = 1\n    \"\"\"Signature help was invoked manually by the user or by a command.\"\"\"\n    TriggerCharacter = 2\n    \"\"\"Signature help was triggered by a trigger character.\"\"\"\n    ContentChange = 3",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionTriggerKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionTriggerKind(int, enum.Enum):\n    \"\"\"The reason why code actions were requested.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    Invoked = 1\n    \"\"\"Code actions were explicitly requested by the user or by an\n    extension.\"\"\"\n    Automatic = 2\n    \"\"\"Code actions were requested automatically.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationPatternKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationPatternKind(str, enum.Enum):\n    \"\"\"A pattern kind describing if a glob pattern matches a file a folder or\n    both.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    File = \"file\"\n    \"\"\"The pattern matches a file only.\"\"\"\n    Folder = \"folder\"\n    \"\"\"The pattern matches a folder only.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookCellKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookCellKind(int, enum.Enum):\n    \"\"\"A notebook cell kind.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    Markup = 1\n    \"\"\"A markup-cell is formatted source that is used for display.\"\"\"\n    Code = 2\n    \"\"\"A code-cell is source code.\"\"\"\n@enum.unique",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ResourceOperationKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ResourceOperationKind(str, enum.Enum):\n    Create = \"create\"\n    \"\"\"Supports creating new files and folders.\"\"\"\n    Rename = \"rename\"\n    \"\"\"Supports renaming existing files and folders.\"\"\"\n    Delete = \"delete\"\n    \"\"\"Supports deleting existing files and folders.\"\"\"\n@enum.unique\nclass FailureHandlingKind(str, enum.Enum):\n    Abort = \"abort\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FailureHandlingKind",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FailureHandlingKind(str, enum.Enum):\n    Abort = \"abort\"\n    \"\"\"Applying the workspace change is simply aborted if one of the changes\n    provided fails.\n    All operations executed before the failing operation stay executed.\n    \"\"\"\n    Transactional = \"transactional\"\n    \"\"\"All operations are executed transactional.\n    That means they either all succeed or no changes at all are applied\n    to the workspace.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PrepareSupportDefaultBehavior",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PrepareSupportDefaultBehavior(int, enum.Enum):\n    Identifier = 1\n    \"\"\"The client's default behavior is to select the identifier according the\n    to language's syntax rule.\"\"\"\n@enum.unique\nclass TokenFormat(str, enum.Enum):\n    Relative = \"relative\"\nDefinition = Union[\"Location\", List[\"Location\"]]\n\"\"\"The definition of a symbol represented as one or many locations. For most\nprogramming languages there is only one location at which a symbol is defined.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TokenFormat",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TokenFormat(str, enum.Enum):\n    Relative = \"relative\"\nDefinition = Union[\"Location\", List[\"Location\"]]\n\"\"\"The definition of a symbol represented as one or many locations. For most\nprogramming languages there is only one location at which a symbol is defined.\nServers should prefer returning `DefinitionLink` over `Definition` if\nsupported by the client.\n\"\"\"\nDefinitionLink = Union[\"LocationLink\", \"LocationLink\"]\n\"\"\"Information about where a symbol is defined.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PrepareRenameResult_Type1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PrepareRenameResult_Type1:\n    range: \"Range\" = attrs.field()\n    placeholder: str = attrs.field(validator=attrs.validators.instance_of(str))\n@attrs.define\nclass PrepareRenameResult_Type2:\n    default_behavior: bool = attrs.field(validator=attrs.validators.instance_of(bool))\nPrepareRenameResult = Union[\n    \"Range\", \"PrepareRenameResult_Type1\", \"PrepareRenameResult_Type2\"\n]\nProgressToken = Union[int, str]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PrepareRenameResult_Type2",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PrepareRenameResult_Type2:\n    default_behavior: bool = attrs.field(validator=attrs.validators.instance_of(bool))\nPrepareRenameResult = Union[\n    \"Range\", \"PrepareRenameResult_Type1\", \"PrepareRenameResult_Type2\"\n]\nProgressToken = Union[int, str]\nDocumentSelector = List[\"DocumentFilter\"]\n\"\"\"A document selector is the combination of one or many document filters.\n@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**/tsconfig.json' }]`;\nThe use of a string as a document filter is deprecated @since 3.16.0.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentContentChangeEvent_Type1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentContentChangeEvent_Type1:\n    range: \"Range\" = attrs.field()\n    \"\"\"The range of the document that changed.\"\"\"\n    text: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The new text for the provided range.\"\"\"\n    range_length: Optional[int] = attrs.field(\n        validator=attrs.validators.optional(validators.uinteger_validator), default=None\n    )\n    \"\"\"The optional length of the range that got replaced.\n    @deprecated use range instead.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentContentChangeEvent_Type2",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentContentChangeEvent_Type2:\n    text: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The new text of the whole document.\"\"\"\nTextDocumentContentChangeEvent = Union[\n    \"TextDocumentContentChangeEvent_Type1\", \"TextDocumentContentChangeEvent_Type2\"\n]\n\"\"\"An event describing a change to a text document.\nIf only a text is provided it is considered to be the full content of\nthe document.\n\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MarkedString_Type1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MarkedString_Type1:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n    value: str = attrs.field(validator=attrs.validators.instance_of(str))\nMarkedString = Union[str, \"MarkedString_Type1\"]\n\"\"\"MarkedString can be used to render human readable text. It is either a\nmarkdown string or a code-block that provides a language and a code snippet.\nThe language identifier is semantically equal to the optional language\nidentifier in fenced code blocks in GitHub issues. See\nhttps://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-\nhighlighting.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFilter_Type1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFilter_Type1:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A language id, like `typescript`.\"\"\"\n    scheme: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"A Uri scheme, like `file` or `untitled`.\"\"\"\n    pattern: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFilter_Type2",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFilter_Type2:\n    scheme: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A Uri scheme, like `file` or `untitled`.\"\"\"\n    language: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"A language id, like `typescript`.\"\"\"\n    pattern: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFilter_Type3",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFilter_Type3:\n    pattern: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A glob pattern, like `*.{ts,js}`.\"\"\"\n    language: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"A language id, like `typescript`.\"\"\"\n    scheme: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentFilter_Type1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentFilter_Type1:\n    notebook_type: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The type of the enclosing notebook.\"\"\"\n    scheme: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"A Uri scheme, like `file` or `untitled`.\"\"\"\n    pattern: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentFilter_Type2",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentFilter_Type2:\n    scheme: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A Uri scheme, like `file` or `untitled`.\"\"\"\n    notebook_type: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The type of the enclosing notebook.\"\"\"\n    pattern: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentFilter_Type3",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentFilter_Type3:\n    pattern: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A glob pattern.\"\"\"\n    notebook_type: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The type of the enclosing notebook.\"\"\"\n    scheme: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPositionParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPositionParams:\n    \"\"\"A parameter literal used in requests to pass a text document and a\n    position inside that document.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n@attrs.define\nclass WorkDoneProgressParams:\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressParams:\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n@attrs.define\nclass PartialResultParams:\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define\nclass ImplementationParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PartialResultParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PartialResultParams:\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define\nclass ImplementationParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ImplementationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ImplementationParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Location",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Location:\n    \"\"\"Represents a location inside a resource, such as a line inside a text\n    file.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    range: \"Range\" = attrs.field()\n    def __eq__(self, o: object) -> bool:\n        if not isinstance(o, Location):\n            return NotImplemented\n        return (self.uri == o.uri) and (self.range == o.range)\n    def __repr__(self) -> str:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentRegistrationOptions:\n    \"\"\"General text document registration options.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass ImplementationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ImplementationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ImplementationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass StaticRegistrationOptions:\n    \"\"\"Static registration options to be returned in the initialize request.\"\"\"\n    id: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "StaticRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class StaticRegistrationOptions:\n    \"\"\"Static registration options to be returned in the initialize request.\"\"\"\n    id: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The id used to register the request.\n    The id can be used to deregister the request again. See also\n    Registration#id.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ImplementationRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ImplementationRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeDefinitionParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeDefinitionParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeDefinitionOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeDefinitionOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass TypeDefinitionRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeDefinitionRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeDefinitionRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFolder",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceFolder:\n    \"\"\"A workspace folder inside a client.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The associated URI for this workspace folder.\"\"\"\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of the workspace folder.\n    Used to refer to this workspace folder in the user interface.\n    \"\"\"\n@attrs.define\nclass DidChangeWorkspaceFoldersParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeWorkspaceFoldersParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeWorkspaceFoldersParams:\n    \"\"\"The parameters of a `workspace/didChangeWorkspaceFolders`\n    notification.\"\"\"\n    event: \"WorkspaceFoldersChangeEvent\" = attrs.field()\n    \"\"\"The actual workspace folder change event.\"\"\"\n@attrs.define\nclass ConfigurationParams:\n    \"\"\"The parameters of a configuration request.\"\"\"\n    items: List[\"ConfigurationItem\"] = attrs.field()\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ConfigurationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ConfigurationParams:\n    \"\"\"The parameters of a configuration request.\"\"\"\n    items: List[\"ConfigurationItem\"] = attrs.field()\n@attrs.define\nclass DocumentColorParams:\n    \"\"\"Parameters for a DocumentColorRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentColorParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentColorParams:\n    \"\"\"Parameters for a DocumentColorRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ColorInformation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ColorInformation:\n    \"\"\"Represents a color range from a document.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range in the document where this color appears.\"\"\"\n    color: \"Color\" = attrs.field()\n    \"\"\"The actual color value for this color range.\"\"\"\n@attrs.define\nclass DocumentColorOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentColorOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentColorOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass DocumentColorRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentColorRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentColorRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ColorPresentationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ColorPresentationParams:\n    \"\"\"Parameters for a ColorPresentationRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    color: \"Color\" = attrs.field()\n    \"\"\"The color to request presentations for.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range where the color would be inserted.\n    Serves as a context.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ColorPresentation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ColorPresentation:\n    label: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The label of this color presentation.\n    It will be shown on the color picker header. By default this is also\n    the text that is inserted when selecting this color presentation.\n    \"\"\"\n    text_edit: Optional[\"TextEdit\"] = attrs.field(default=None)\n    \"\"\"An edit which is applied to a document when selecting this presentation\n    for the color.\n    When `falsy` the label is used.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeParams:\n    \"\"\"Parameters for a FoldingRangeRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRange",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRange:\n    \"\"\"Represents a folding range.\n    To be valid, start and end line must be bigger than zero and smaller\n    than the number of lines in the document. Clients are free to ignore\n    invalid ranges.\n    \"\"\"\n    start_line: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"The zero-based start line of the range to fold.\n    The folded area starts after the line's last character. To be valid,\n    the end must be zero or larger and smaller than the number of lines",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass FoldingRangeRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeclarationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeclarationParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeclarationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeclarationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass DeclarationRegistrationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeclarationRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeclarationRegistrationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SelectionRangeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SelectionRangeParams:\n    \"\"\"A parameter literal used in selection range requests.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    positions: List[\"Position\"] = attrs.field()\n    \"\"\"The positions inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SelectionRange",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SelectionRange:\n    \"\"\"A selection range represents a part of a selection hierarchy.\n    A selection range may have a parent selection range that contains\n    it.\n    \"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range of this selection range.\"\"\"\n    parent: Optional[\"SelectionRange\"] = attrs.field(default=None)\n    \"\"\"The parent selection range containing this range.\n    Therefore `parent.range` must contain `this.range`.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SelectionRangeOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SelectionRangeOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass SelectionRangeRegistrationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SelectionRangeRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SelectionRangeRegistrationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressCreateParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressCreateParams:\n    token: ProgressToken = attrs.field()\n    \"\"\"The token to be used to report progress.\"\"\"\n@attrs.define\nclass WorkDoneProgressCancelParams:\n    token: ProgressToken = attrs.field()\n    \"\"\"The token to be used to report progress.\"\"\"\n@attrs.define\nclass CallHierarchyPrepareParams:\n    \"\"\"The parameter of a `textDocument/prepareCallHierarchy` request.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressCancelParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressCancelParams:\n    token: ProgressToken = attrs.field()\n    \"\"\"The token to be used to report progress.\"\"\"\n@attrs.define\nclass CallHierarchyPrepareParams:\n    \"\"\"The parameter of a `textDocument/prepareCallHierarchy` request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyPrepareParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyPrepareParams:\n    \"\"\"The parameter of a `textDocument/prepareCallHierarchy` request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyItem",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyItem:\n    \"\"\"Represents programming constructs like functions or constructors in the\n    context of call hierarchy.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of this item.\"\"\"\n    kind: SymbolKind = attrs.field()\n    \"\"\"The kind of this item.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyOptions:\n    \"\"\"Call hierarchy options used during static registration.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyRegistrationOptions:\n    \"\"\"Call hierarchy options used during static or dynamic registration.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyIncomingCallsParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyIncomingCallsParams:\n    \"\"\"The parameter of a `callHierarchy/incomingCalls` request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    item: CallHierarchyItem = attrs.field()\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyIncomingCall",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyIncomingCall:\n    \"\"\"Represents an incoming call, e.g. a caller of a method or constructor.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    from_: CallHierarchyItem = attrs.field()\n    \"\"\"The item that makes the call.\"\"\"\n    from_ranges: List[\"Range\"] = attrs.field()\n    \"\"\"The ranges at which the calls appear.\n    This is relative to the caller denoted by",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyOutgoingCallsParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyOutgoingCallsParams:\n    \"\"\"The parameter of a `callHierarchy/outgoingCalls` request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    item: CallHierarchyItem = attrs.field()\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyOutgoingCall",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyOutgoingCall:\n    \"\"\"Represents an outgoing call, e.g. calling a getter from a method or a\n    method from a constructor etc.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    to: CallHierarchyItem = attrs.field()\n    \"\"\"The item that is called.\"\"\"\n    from_ranges: List[\"Range\"] = attrs.field()\n    \"\"\"The range at which this item is called.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensParams:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokens",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokens:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    data: List[int] = attrs.field()\n    \"\"\"The actual tokens.\"\"\"\n    result_id: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"An optional result id.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensPartialResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensPartialResult:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    data: List[int] = attrs.field()\n@attrs.define\nclass SemanticTokensOptionsFullType1:\n    delta: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensOptionsFullType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensOptionsFullType1:\n    delta: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server supports deltas for full documents.\"\"\"\n@attrs.define\nclass SemanticTokensOptions:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensOptions:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    legend: \"SemanticTokensLegend\" = attrs.field()\n    \"\"\"The legend used by the server.\"\"\"\n    range: Optional[Union[bool, Any]] = attrs.field(default=None)\n    \"\"\"Server supports providing semantic tokens for a specific range of a\n    document.\"\"\"\n    full: Optional[Union[bool, \"SemanticTokensOptionsFullType1\"]] = attrs.field(\n        default=None",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensRegistrationOptionsFullType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensRegistrationOptionsFullType1:\n    delta: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server supports deltas for full documents.\"\"\"\n@attrs.define\nclass SemanticTokensRegistrationOptions:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensRegistrationOptions:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    legend: \"SemanticTokensLegend\" = attrs.field()\n    \"\"\"The legend used by the server.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensDeltaParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensDeltaParams:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    previous_result_id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The result id of a previous response.\n    The result Id can either point to a full response or a delta\n    response depending on what was received last.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensDelta",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensDelta:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    edits: List[\"SemanticTokensEdit\"] = attrs.field()\n    \"\"\"The semantic token edits to transform a previous result into a new\n    result.\"\"\"\n    result_id: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensDeltaPartialResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensDeltaPartialResult:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    edits: List[\"SemanticTokensEdit\"] = attrs.field()\n@attrs.define\nclass SemanticTokensRangeParams:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensRangeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensRangeParams:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range the semantic tokens are requested for.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowDocumentParams:\n    \"\"\"Params to show a document.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The document uri to show.\"\"\"\n    external: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowDocumentResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowDocumentResult:\n    \"\"\"The result of a showDocument request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    success: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"A boolean indicating if the show was successful.\"\"\"\n@attrs.define\nclass LinkedEditingRangeParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LinkedEditingRangeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LinkedEditingRangeParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n@attrs.define\nclass LinkedEditingRanges:\n    \"\"\"The result of a linked editing range request.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LinkedEditingRanges",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LinkedEditingRanges:\n    \"\"\"The result of a linked editing range request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    ranges: List[\"Range\"] = attrs.field()\n    \"\"\"A list of ranges that can be edited together.\n    The ranges must have identical length and contain identical text\n    content. The ranges cannot overlap.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LinkedEditingRangeOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LinkedEditingRangeOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass LinkedEditingRangeRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LinkedEditingRangeRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LinkedEditingRangeRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CreateFilesParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CreateFilesParams:\n    \"\"\"The parameters sent in notifications/requests for user-initiated\n    creation of files.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    files: List[\"FileCreate\"] = attrs.field()\n    \"\"\"An array of all files/folders created in this operation.\"\"\"\n@attrs.define\nclass WorkspaceEdit:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceEdit",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceEdit:\n    \"\"\"A workspace edit represents changes to many resources managed in the\n    workspace. The edit should either provide `changes` or `documentChanges`.\n    If documentChanges are present they are preferred over `changes` if the\n    client can handle versioned document edits.\n    Since version 3.13.0 a workspace edit can contain resource operations as well. If resource\n    operations are present clients need to execute the operations in the order in which they\n    are provided. So a workspace edit for example can consist of the following two changes:\n    (1) a create file a.txt and (2) a text document edit which insert text into file a.txt.\n    An invalid sequence (e.g. (1) delete file a.txt and (2) insert text into file a.txt) will",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationRegistrationOptions:\n    \"\"\"The options to register for file operations.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    filters: List[\"FileOperationFilter\"] = attrs.field()\n    \"\"\"The actual filters.\"\"\"\n@attrs.define\nclass RenameFilesParams:\n    \"\"\"The parameters sent in notifications/requests for user-initiated renames",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameFilesParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameFilesParams:\n    \"\"\"The parameters sent in notifications/requests for user-initiated renames\n    of files.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    files: List[\"FileRename\"] = attrs.field()\n    \"\"\"An array of all files/folders renamed in this operation.\n    When a folder is renamed, only the folder will be included, and not\n    its children.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeleteFilesParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeleteFilesParams:\n    \"\"\"The parameters sent in notifications/requests for user-initiated deletes\n    of files.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    files: List[\"FileDelete\"] = attrs.field()\n    \"\"\"An array of all files/folders deleted in this operation.\"\"\"\n@attrs.define\nclass MonikerParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MonikerParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MonikerParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Moniker",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Moniker:\n    \"\"\"Moniker definition to match LSIF 0.5 moniker definition.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    scheme: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The scheme of the moniker.\n    For example tsc or .Net\n    \"\"\"\n    identifier: str = attrs.field(validator=attrs.validators.instance_of(str))",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MonikerOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MonikerOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass MonikerRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MonikerRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MonikerRegistrationOptions:\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchyPrepareParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchyPrepareParams:\n    \"\"\"The parameter of a `textDocument/prepareTypeHierarchy` request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchyItem",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchyItem:\n    \"\"\"@since 3.17.0\"\"\"\n    # Since: 3.17.0\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of this item.\"\"\"\n    kind: SymbolKind = attrs.field()\n    \"\"\"The kind of this item.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The resource identifier of this item.\"\"\"\n    range: \"Range\" = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchyOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchyOptions:\n    \"\"\"Type hierarchy options used during static registration.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchyRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchyRegistrationOptions:\n    \"\"\"Type hierarchy options used during static or dynamic registration.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchySupertypesParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchySupertypesParams:\n    \"\"\"The parameter of a `typeHierarchy/supertypes` request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    item: TypeHierarchyItem = attrs.field()\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchySubtypesParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchySubtypesParams:\n    \"\"\"The parameter of a `typeHierarchy/subtypes` request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    item: TypeHierarchyItem = attrs.field()\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueParams:\n    \"\"\"A parameter literal used in inline value requests.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The document range for which inline values should be computed.\"\"\"\n    context: \"InlineValueContext\" = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueOptions:\n    \"\"\"Inline value options used during static registration.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueRegistrationOptions:\n    \"\"\"Inline value options used during static or dynamic registration.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintParams:\n    \"\"\"A parameter literal used in inlay hint requests.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The document range for which inlay hints should be computed.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHint",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHint:\n    \"\"\"Inlay hint information.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    position: \"Position\" = attrs.field()\n    \"\"\"The position of this hint.\"\"\"\n    label: Union[str, List[\"InlayHintLabelPart\"]] = attrs.field()\n    \"\"\"The label of this hint. A human readable string or an array of\n    InlayHintLabelPart label parts.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintOptions:\n    \"\"\"Inlay hint options used during static registration.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    resolve_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server provides support to resolve additional information for an",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintRegistrationOptions:\n    \"\"\"Inlay hint options used during static or dynamic registration.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    resolve_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server provides support to resolve additional information for an",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentDiagnosticParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentDiagnosticParams:\n    \"\"\"Parameters of the document diagnostic request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    identifier: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentDiagnosticReportPartialResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentDiagnosticReportPartialResult:\n    \"\"\"A partial result for a document diagnostic report.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    related_documents: Dict[\n        str, Union[\"FullDocumentDiagnosticReport\", \"UnchangedDocumentDiagnosticReport\"]\n    ] = attrs.field()\n@attrs.define\nclass DiagnosticServerCancellationData:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticServerCancellationData",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticServerCancellationData:\n    \"\"\"Cancellation data returned from a diagnostic request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    retrigger_request: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n@attrs.define\nclass DiagnosticOptions:\n    \"\"\"Diagnostic options.\n    @since 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticOptions:\n    \"\"\"Diagnostic options.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    inter_file_dependencies: bool = attrs.field(\n        validator=attrs.validators.instance_of(bool)\n    )\n    \"\"\"Whether the language has inter file dependencies meaning that editing\n    code in one file can result in a different diagnostic set in another file.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticRegistrationOptions:\n    \"\"\"Diagnostic registration options.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    inter_file_dependencies: bool = attrs.field(\n        validator=attrs.validators.instance_of(bool)\n    )\n    \"\"\"Whether the language has inter file dependencies meaning that editing\n    code in one file can result in a different diagnostic set in another file.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticParams:\n    \"\"\"Parameters of the workspace diagnostic request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    previous_result_ids: List[\"PreviousResultId\"] = attrs.field()\n    \"\"\"The currently known diagnostic reports with their previous result\n    ids.\"\"\"\n    identifier: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticReport:\n    \"\"\"A workspace diagnostic report.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    items: List[WorkspaceDocumentDiagnosticReport] = attrs.field()\n@attrs.define\nclass WorkspaceDiagnosticReportPartialResult:\n    \"\"\"A partial result for a workspace diagnostic report.\n    @since 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticReportPartialResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticReportPartialResult:\n    \"\"\"A partial result for a workspace diagnostic report.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    items: List[WorkspaceDocumentDiagnosticReport] = attrs.field()\n@attrs.define\nclass DidOpenNotebookDocumentParams:\n    \"\"\"The params sent in an open notebook document notification.\n    @since 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidOpenNotebookDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidOpenNotebookDocumentParams:\n    \"\"\"The params sent in an open notebook document notification.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    notebook_document: \"NotebookDocument\" = attrs.field()\n    \"\"\"The notebook document that got opened.\"\"\"\n    cell_text_documents: List[\"TextDocumentItem\"] = attrs.field()\n    \"\"\"The text documents that represent the content of a notebook cell.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeNotebookDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeNotebookDocumentParams:\n    \"\"\"The params sent in a change notebook document notification.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    notebook_document: \"VersionedNotebookDocumentIdentifier\" = attrs.field()\n    \"\"\"The notebook document that did change.\n    The version number points to the version after all provided changes\n    have been applied. If only the text document content of a cell\n    changes the notebook version doesn't necessarily have to change.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidSaveNotebookDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidSaveNotebookDocumentParams:\n    \"\"\"The params sent in a save notebook document notification.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    notebook_document: \"NotebookDocumentIdentifier\" = attrs.field()\n    \"\"\"The notebook document that got saved.\"\"\"\n@attrs.define\nclass DidCloseNotebookDocumentParams:\n    \"\"\"The params sent in a close notebook document notification.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidCloseNotebookDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidCloseNotebookDocumentParams:\n    \"\"\"The params sent in a close notebook document notification.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    notebook_document: \"NotebookDocumentIdentifier\" = attrs.field()\n    \"\"\"The notebook document that got closed.\"\"\"\n    cell_text_documents: List[\"TextDocumentIdentifier\"] = attrs.field()\n    \"\"\"The text documents that represent the content of a notebook cell that\n    got closed.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RegistrationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RegistrationParams:\n    registrations: List[\"Registration\"] = attrs.field()\n@attrs.define\nclass UnregistrationParams:\n    unregisterations: List[\"Unregistration\"] = attrs.field()\n@attrs.define\nclass InitializeParamsClientInfoType:\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of the client as defined by the client.\"\"\"\n    version: Optional[str] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "UnregistrationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class UnregistrationParams:\n    unregisterations: List[\"Unregistration\"] = attrs.field()\n@attrs.define\nclass InitializeParamsClientInfoType:\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of the client as defined by the client.\"\"\"\n    version: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeParamsClientInfoType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeParamsClientInfoType:\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of the client as defined by the client.\"\"\"\n    version: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The client's version as defined by the client.\"\"\"\n@attrs.define\nclass _InitializeParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "_InitializeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class _InitializeParams:\n    \"\"\"The initialize parameters.\"\"\"\n    capabilities: \"ClientCapabilities\" = attrs.field()\n    \"\"\"The capabilities provided by the client (editor or tool)\"\"\"\n    process_id: Optional[Union[int, None]] = attrs.field(default=None)\n    \"\"\"The process Id of the parent process that started the server.\n    Is `null` if the process has not been started by another process. If\n    the parent process is not alive then the server should exit.\n    \"\"\"\n    client_info: Optional[\"InitializeParamsClientInfoType\"] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFoldersInitializeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceFoldersInitializeParams:\n    workspace_folders: Optional[Union[List[WorkspaceFolder], None]] = attrs.field(\n        default=None\n    )\n    \"\"\"The workspace folders configured in the client when the server starts.\n    This property is only available if the client supports workspace folders.\n    It can be `null` if the client supports workspace folders but none are\n    configured.\n    @since 3.6.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeParams:\n    capabilities: \"ClientCapabilities\" = attrs.field()\n    \"\"\"The capabilities provided by the client (editor or tool)\"\"\"\n    process_id: Optional[Union[int, None]] = attrs.field(default=None)\n    \"\"\"The process Id of the parent process that started the server.\n    Is `null` if the process has not been started by another process. If\n    the parent process is not alive then the server should exit.\n    \"\"\"\n    client_info: Optional[\"InitializeParamsClientInfoType\"] = attrs.field(default=None)\n    \"\"\"Information about the client.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeResultServerInfoType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeResultServerInfoType:\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of the server as defined by the server.\"\"\"\n    version: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The server's version as defined by the server.\"\"\"\n@attrs.define\nclass InitializeResult:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeResult:\n    \"\"\"The result returned from an initialize request.\"\"\"\n    capabilities: \"ServerCapabilities\" = attrs.field()\n    \"\"\"The capabilities the language server provides.\"\"\"\n    server_info: Optional[\"InitializeResultServerInfoType\"] = attrs.field(default=None)\n    \"\"\"Information about the server.\n    @since 3.15.0\n    \"\"\"\n    # Since: 3.15.0\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeError",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeError:\n    \"\"\"The data type of the ResponseError if the initialize request fails.\"\"\"\n    retry: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"Indicates whether the client execute the following retry logic: (1) show\n    the message provided by the ResponseError to the user (2) user selects\n    retry or cancel (3) if user selected retry the initialize method is sent\n    again.\"\"\"\n@attrs.define\nclass InitializedParams:\n    pass",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializedParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializedParams:\n    pass\n@attrs.define\nclass DidChangeConfigurationParams:\n    \"\"\"The parameters of a change configuration notification.\"\"\"\n    settings: LSPAny = attrs.field()\n    \"\"\"The actual changed settings.\"\"\"\n@attrs.define\nclass DidChangeConfigurationRegistrationOptions:\n    section: Optional[Union[str, List[str]]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeConfigurationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeConfigurationParams:\n    \"\"\"The parameters of a change configuration notification.\"\"\"\n    settings: LSPAny = attrs.field()\n    \"\"\"The actual changed settings.\"\"\"\n@attrs.define\nclass DidChangeConfigurationRegistrationOptions:\n    section: Optional[Union[str, List[str]]] = attrs.field(default=None)\n@attrs.define\nclass ShowMessageParams:\n    \"\"\"The parameters of a notification message.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeConfigurationRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeConfigurationRegistrationOptions:\n    section: Optional[Union[str, List[str]]] = attrs.field(default=None)\n@attrs.define\nclass ShowMessageParams:\n    \"\"\"The parameters of a notification message.\"\"\"\n    type: MessageType = attrs.field()\n    \"\"\"The message type.\n    See {@link MessageType}\n    \"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowMessageParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowMessageParams:\n    \"\"\"The parameters of a notification message.\"\"\"\n    type: MessageType = attrs.field()\n    \"\"\"The message type.\n    See {@link MessageType}\n    \"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The actual message.\"\"\"\n@attrs.define\nclass ShowMessageRequestParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowMessageRequestParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowMessageRequestParams:\n    type: MessageType = attrs.field()\n    \"\"\"The message type.\n    See {@link MessageType}\n    \"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The actual message.\"\"\"\n    actions: Optional[List[\"MessageActionItem\"]] = attrs.field(default=None)\n    \"\"\"The message action items to present.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MessageActionItem",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MessageActionItem:\n    title: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A short title like 'Retry', 'Open Log' etc.\"\"\"\n@attrs.define\nclass LogMessageParams:\n    \"\"\"The log message parameters.\"\"\"\n    type: MessageType = attrs.field()\n    \"\"\"The message type.\n    See {@link MessageType}\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LogMessageParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LogMessageParams:\n    \"\"\"The log message parameters.\"\"\"\n    type: MessageType = attrs.field()\n    \"\"\"The message type.\n    See {@link MessageType}\n    \"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The actual message.\"\"\"\n@attrs.define\nclass DidOpenTextDocumentParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidOpenTextDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidOpenTextDocumentParams:\n    \"\"\"The parameters sent in an open text document notification.\"\"\"\n    text_document: \"TextDocumentItem\" = attrs.field()\n    \"\"\"The document that was opened.\"\"\"\n@attrs.define\nclass DidChangeTextDocumentParams:\n    \"\"\"The change text document notification's parameters.\"\"\"\n    text_document: \"VersionedTextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document that did change.\n    The version number points to the version after all provided content",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeTextDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeTextDocumentParams:\n    \"\"\"The change text document notification's parameters.\"\"\"\n    text_document: \"VersionedTextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document that did change.\n    The version number points to the version after all provided content\n    changes have been applied.\n    \"\"\"\n    content_changes: List[TextDocumentContentChangeEvent] = attrs.field()\n    \"\"\"The actual content changes. The content changes describe single state\n    changes to the document. So if there are two content changes c1 (at array",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentChangeRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentChangeRegistrationOptions:\n    \"\"\"Describe options to be used when registered for text document change\n    events.\"\"\"\n    sync_kind: TextDocumentSyncKind = attrs.field()\n    \"\"\"How documents are synced to the server.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidCloseTextDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidCloseTextDocumentParams:\n    \"\"\"The parameters sent in a close text document notification.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document that was closed.\"\"\"\n@attrs.define\nclass DidSaveTextDocumentParams:\n    \"\"\"The parameters sent in a save text document notification.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document that was saved.\"\"\"\n    text: Optional[str] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidSaveTextDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidSaveTextDocumentParams:\n    \"\"\"The parameters sent in a save text document notification.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document that was saved.\"\"\"\n    text: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"Optional the content when saved.\n    Depends on the includeText value when the save notification was",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SaveOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SaveOptions:\n    \"\"\"Save options.\"\"\"\n    include_text: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The client is supposed to include the content on save.\"\"\"\n@attrs.define\nclass TextDocumentSaveRegistrationOptions:\n    \"\"\"Save registration options.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSaveRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSaveRegistrationOptions:\n    \"\"\"Save registration options.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    include_text: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WillSaveTextDocumentParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WillSaveTextDocumentParams:\n    \"\"\"The parameters sent in a will save text document notification.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document that will be saved.\"\"\"\n    reason: TextDocumentSaveReason = attrs.field()\n    \"\"\"The 'TextDocumentSaveReason'.\"\"\"\n@attrs.define\nclass TextEdit:\n    \"\"\"A text edit applicable to a text document.\"\"\"\n    range: \"Range\" = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextEdit",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextEdit:\n    \"\"\"A text edit applicable to a text document.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range of the text document to be manipulated.\n    To insert text into a document create a range where start === end.\n    \"\"\"\n    new_text: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The string to be inserted.\n    For delete operations use an empty string.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeWatchedFilesParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeWatchedFilesParams:\n    \"\"\"The watched files change notification's parameters.\"\"\"\n    changes: List[\"FileEvent\"] = attrs.field()\n    \"\"\"The actual file events.\"\"\"\n@attrs.define\nclass DidChangeWatchedFilesRegistrationOptions:\n    \"\"\"Describe options to be used when registered for text document change\n    events.\"\"\"\n    watchers: List[\"FileSystemWatcher\"] = attrs.field()\n    \"\"\"The watchers to register.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeWatchedFilesRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeWatchedFilesRegistrationOptions:\n    \"\"\"Describe options to be used when registered for text document change\n    events.\"\"\"\n    watchers: List[\"FileSystemWatcher\"] = attrs.field()\n    \"\"\"The watchers to register.\"\"\"\n@attrs.define\nclass PublishDiagnosticsParams:\n    \"\"\"The publish diagnostic notification's parameters.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The URI for which diagnostic information is reported.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PublishDiagnosticsParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PublishDiagnosticsParams:\n    \"\"\"The publish diagnostic notification's parameters.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The URI for which diagnostic information is reported.\"\"\"\n    diagnostics: List[\"Diagnostic\"] = attrs.field()\n    \"\"\"An array of diagnostic information items.\"\"\"\n    version: Optional[int] = attrs.field(\n        validator=attrs.validators.optional(validators.integer_validator), default=None\n    )\n    \"\"\"Optional the version number of the document the diagnostics are",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionParams:\n    \"\"\"Completion parameters.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    context: Optional[\"CompletionContext\"] = attrs.field(default=None)\n    \"\"\"The completion context.\n    This is only available it the client specifies to send this using\n    the client capability `textDocument.completion.contextSupport ===",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionItem",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionItem:\n    \"\"\"A completion item represents a text snippet that is proposed to complete\n    text that is being typed.\"\"\"\n    label: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The label of this completion item.\n    The label property is also by default the text that\n    is inserted when selecting this completion.\n    If label details are provided the label itself should\n    be an unqualified name of the completion item.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionListItemDefaultsTypeEditRangeType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionListItemDefaultsTypeEditRangeType1:\n    insert: \"Range\" = attrs.field()\n    replace: \"Range\" = attrs.field()\n@attrs.define\nclass CompletionListItemDefaultsType:\n    commit_characters: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"A default commit character set.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionListItemDefaultsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionListItemDefaultsType:\n    commit_characters: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"A default commit character set.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    edit_range: Optional[\n        Union[\"Range\", \"CompletionListItemDefaultsTypeEditRangeType1\"]\n    ] = attrs.field(default=None)\n    \"\"\"A default edit range.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionList",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionList:\n    \"\"\"Represents a collection of completion items to be presented in the\n    editor.\"\"\"\n    is_incomplete: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"This list it not complete. Further typing results in recomputing this\n    list.\n    Recomputed lists have all their items replaced (not appended) in the\n    incomplete completion sessions.\n    \"\"\"\n    items: List[CompletionItem] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionOptionsCompletionItemType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionOptionsCompletionItemType:\n    label_details_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server has support for completion item label details (see also\n    `CompletionItemLabelDetails`) when receiving a completion item in a resolve\n    call.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionOptions:\n    \"\"\"Completion options.\"\"\"\n    trigger_characters: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"Most tools trigger completion request automatically without explicitly\n    requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they\n    do so when the user starts to type an identifier. For example if the user\n    types `c` in a JavaScript file code complete will automatically pop up\n    present `console` besides others as a completion item. Characters that make\n    up identifiers don't need to be listed here.\n    If code complete should automatically be trigger on characters not",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionRegistrationOptionsCompletionItemType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionRegistrationOptionsCompletionItemType:\n    label_details_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server has support for completion item label details (see also\n    `CompletionItemLabelDetails`) when receiving a completion item in a resolve\n    call.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionRegistrationOptions:\n    \"\"\"Registration options for a CompletionRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    trigger_characters: Optional[List[str]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "HoverParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class HoverParams:\n    \"\"\"Parameters for a HoverRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n@attrs.define\nclass Hover:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Hover",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Hover:\n    \"\"\"The result of a hover request.\"\"\"\n    contents: Union[\"MarkupContent\", MarkedString, List[MarkedString]] = attrs.field()\n    \"\"\"The hover's content.\"\"\"\n    range: Optional[\"Range\"] = attrs.field(default=None)\n    \"\"\"An optional range inside the text document that is used to visualize the\n    hover, e.g. by changing the background color.\"\"\"\n@attrs.define\nclass HoverOptions:\n    \"\"\"Hover options.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "HoverOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class HoverOptions:\n    \"\"\"Hover options.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass HoverRegistrationOptions:\n    \"\"\"Registration options for a HoverRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "HoverRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class HoverRegistrationOptions:\n    \"\"\"Registration options for a HoverRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpParams:\n    \"\"\"Parameters for a SignatureHelpRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    context: Optional[\"SignatureHelpContext\"] = attrs.field(default=None)\n    \"\"\"The signature help context. This is only available if the client\n    specifies to send this using the client capability\n    `textDocument.signatureHelp.contextSupport === true`",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelp",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelp:\n    \"\"\"Signature help represents the signature of something callable.\n    There can be multiple signature but only one active and only one\n    active parameter.\n    \"\"\"\n    signatures: List[\"SignatureInformation\"] = attrs.field()\n    \"\"\"One or more signatures.\"\"\"\n    active_signature: Optional[int] = attrs.field(\n        validator=attrs.validators.optional(validators.uinteger_validator), default=None\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpOptions:\n    \"\"\"Server Capabilities for a SignatureHelpRequest.\"\"\"\n    trigger_characters: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"List of characters that trigger signature help automatically.\"\"\"\n    retrigger_characters: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"List of characters that re-trigger signature help.\n    These trigger characters are only active when signature help is already showing. All trigger characters\n    are also counted as re-trigger characters.\n    @since 3.15.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpRegistrationOptions:\n    \"\"\"Registration options for a SignatureHelpRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    trigger_characters: Optional[List[str]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DefinitionParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DefinitionParams:\n    \"\"\"Parameters for a DefinitionRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DefinitionOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DefinitionOptions:\n    \"\"\"Server Capabilities for a DefinitionRequest.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass DefinitionRegistrationOptions:\n    \"\"\"Registration options for a DefinitionRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DefinitionRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DefinitionRegistrationOptions:\n    \"\"\"Registration options for a DefinitionRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ReferenceParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ReferenceParams:\n    \"\"\"Parameters for a ReferencesRequest.\"\"\"\n    context: \"ReferenceContext\" = attrs.field()\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ReferenceOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ReferenceOptions:\n    \"\"\"Reference options.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass ReferenceRegistrationOptions:\n    \"\"\"Registration options for a ReferencesRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ReferenceRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ReferenceRegistrationOptions:\n    \"\"\"Registration options for a ReferencesRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentHighlightParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentHighlightParams:\n    \"\"\"Parameters for a DocumentHighlightRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentHighlight",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentHighlight:\n    \"\"\"A document highlight is a range inside a text document which deserves\n    special attention.\n    Usually a document highlight is visualized by changing the\n    background color of its range.\n    \"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range this highlight applies to.\"\"\"\n    kind: Optional[DocumentHighlightKind] = attrs.field(default=None)\n    \"\"\"The highlight kind, default is text.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentHighlightOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentHighlightOptions:\n    \"\"\"Provider options for a DocumentHighlightRequest.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass DocumentHighlightRegistrationOptions:\n    \"\"\"Registration options for a DocumentHighlightRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentHighlightRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentHighlightRegistrationOptions:\n    \"\"\"Registration options for a DocumentHighlightRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbolParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbolParams:\n    \"\"\"Parameters for a DocumentSymbolRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "BaseSymbolInformation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class BaseSymbolInformation:\n    \"\"\"A base for all symbol information.\"\"\"\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of this symbol.\"\"\"\n    kind: SymbolKind = attrs.field()\n    \"\"\"The kind of this symbol.\"\"\"\n    tags: Optional[List[SymbolTag]] = attrs.field(default=None)\n    \"\"\"Tags for this symbol.\n    @since 3.16.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SymbolInformation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SymbolInformation:\n    \"\"\"Represents information about programming constructs like variables,\n    classes, interfaces etc.\"\"\"\n    location: Location = attrs.field()\n    \"\"\"The location of this symbol. The location's range is used by a tool to\n    reveal the location in the editor. If the symbol is selected in the tool\n    the range's start information is used to position the cursor. So the range\n    usually spans more than the actual symbol's name and does normally include\n    things like visibility modifiers.\n    The range doesn't have to denote a node range in the sense of an",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbol",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbol:\n    \"\"\"Represents programming constructs like variables, classes, interfaces\n    etc.\n    that appear in a document. Document symbols can be hierarchical and\n    they have two ranges: one that encloses its definition and one that\n    points to its most interesting range, e.g. the range of an\n    identifier.\n    \"\"\"\n    name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of this symbol.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbolOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbolOptions:\n    \"\"\"Provider options for a DocumentSymbolRequest.\"\"\"\n    label: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"A human-readable string that is shown when multiple outlines trees are\n    shown for the same document.\n    @since 3.16.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbolRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbolRegistrationOptions:\n    \"\"\"Registration options for a DocumentSymbolRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    label: Optional[str] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionParams:\n    \"\"\"The parameters of a CodeActionRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document in which the command was invoked.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range for which the command was invoked.\"\"\"\n    context: \"CodeActionContext\" = attrs.field()\n    \"\"\"Context carrying additional information.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Command:\n    \"\"\"Represents a reference to a command.\n    Provides a title which will be used to represent a command in the UI\n    and, optionally, an array of arguments which will be passed to the\n    command handler function when invoked.\n    \"\"\"\n    title: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"Title of the command, like `save`.\"\"\"\n    command: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The identifier of the actual command handler.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionDisabledType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionDisabledType:\n    reason: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"Human readable description of why the code action is currently disabled.\n    This is displayed in the code actions UI.\n    \"\"\"\n@attrs.define\nclass CodeAction:\n    \"\"\"A code action represents a change that can be performed in code, e.g. to\n    fix a problem or to refactor code.\n    A CodeAction must set either `edit` and/or a `command`. If both are",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeAction",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeAction:\n    \"\"\"A code action represents a change that can be performed in code, e.g. to\n    fix a problem or to refactor code.\n    A CodeAction must set either `edit` and/or a `command`. If both are\n    supplied, the `edit` is applied first, then the `command` is\n    executed.\n    \"\"\"\n    title: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A short, human-readable, title for this code action.\"\"\"\n    kind: Optional[Union[CodeActionKind, str]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionOptions:\n    \"\"\"Provider options for a CodeActionRequest.\"\"\"\n    code_action_kinds: Optional[List[Union[CodeActionKind, str]]] = attrs.field(\n        default=None\n    )\n    \"\"\"CodeActionKinds that this server may return.\n    The list of kinds may be generic, such as `CodeActionKind.Refactor`,\n    or the server may list out every specific kind they provide.\n    \"\"\"\n    resolve_provider: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionRegistrationOptions:\n    \"\"\"Registration options for a CodeActionRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    code_action_kinds: Optional[List[Union[CodeActionKind, str]]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolParams:\n    \"\"\"The parameters of a WorkspaceSymbolRequest.\"\"\"\n    query: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A query string to filter symbols by.\n    Clients may send an empty string here to request all symbols.\n    \"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolLocationType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolLocationType1:\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n@attrs.define\nclass WorkspaceSymbol:\n    \"\"\"A special workspace symbol that supports locations without a range.\n    See also SymbolInformation.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    location: Union[Location, \"WorkspaceSymbolLocationType1\"] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbol",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbol:\n    \"\"\"A special workspace symbol that supports locations without a range.\n    See also SymbolInformation.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    location: Union[Location, \"WorkspaceSymbolLocationType1\"] = attrs.field()\n    \"\"\"The location of the symbol. Whether a server is allowed to return a\n    location without a range depends on the client capability\n    `workspace.symbol.resolveSupport`.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolOptions:\n    \"\"\"Server capabilities for a WorkspaceSymbolRequest.\"\"\"\n    resolve_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server provides support to resolve additional information for a\n    workspace symbol.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolRegistrationOptions:\n    \"\"\"Registration options for a WorkspaceSymbolRequest.\"\"\"\n    resolve_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server provides support to resolve additional information for a\n    workspace symbol.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensParams:\n    \"\"\"The parameters of a CodeLensRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document to request code lens for.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLens",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLens:\n    \"\"\"A code lens represents a command that should be shown along with source\n    text, like the number of references, a way to run tests, etc.\n    A code lens is _unresolved_ when no command is associated to it. For\n    performance reasons the creation of a code lens and resolving should\n    be done in two stages.\n    \"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range in which this code lens is valid.\n    Should only span a single line.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensOptions:\n    \"\"\"Code Lens provider options of a CodeLensRequest.\"\"\"\n    resolve_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Code lens has a resolve provider as well.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensRegistrationOptions:\n    \"\"\"Registration options for a CodeLensRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    resolve_provider: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLinkParams:\n    \"\"\"The parameters of a DocumentLinkRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document to provide document links for.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLink",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLink:\n    \"\"\"A document link is a range in a text document that links to an internal\n    or external resource, like another text document or a web site.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range this link applies to.\"\"\"\n    target: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The uri this link points to.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLinkOptions:\n    \"\"\"Provider options for a DocumentLinkRequest.\"\"\"\n    resolve_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Document links have a resolve provider as well.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLinkRegistrationOptions:\n    \"\"\"Registration options for a DocumentLinkRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    resolve_provider: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentFormattingParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentFormattingParams:\n    \"\"\"The parameters of a DocumentFormattingRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document to format.\"\"\"\n    options: \"FormattingOptions\" = attrs.field()\n    \"\"\"The format options.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n@attrs.define\nclass DocumentFormattingOptions:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentFormattingOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentFormattingOptions:\n    \"\"\"Provider options for a DocumentFormattingRequest.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass DocumentFormattingRegistrationOptions:\n    \"\"\"Registration options for a DocumentFormattingRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentFormattingRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentFormattingRegistrationOptions:\n    \"\"\"Registration options for a DocumentFormattingRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentRangeFormattingParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentRangeFormattingParams:\n    \"\"\"The parameters of a DocumentRangeFormattingRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document to format.\"\"\"\n    range: \"Range\" = attrs.field()\n    \"\"\"The range to format.\"\"\"\n    options: \"FormattingOptions\" = attrs.field()\n    \"\"\"The format options.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentRangeFormattingOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentRangeFormattingOptions:\n    \"\"\"Provider options for a DocumentRangeFormattingRequest.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass DocumentRangeFormattingRegistrationOptions:\n    \"\"\"Registration options for a DocumentRangeFormattingRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentRangeFormattingRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentRangeFormattingRegistrationOptions:\n    \"\"\"Registration options for a DocumentRangeFormattingRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    work_done_progress: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentOnTypeFormattingParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentOnTypeFormattingParams:\n    \"\"\"The parameters of a DocumentOnTypeFormattingRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document to format.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position around which the on type formatting should happen.\n    This is not necessarily the exact position where the character\n    denoted by the property `ch` got typed.\n    \"\"\"\n    ch: str = attrs.field(validator=attrs.validators.instance_of(str))",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentOnTypeFormattingOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentOnTypeFormattingOptions:\n    \"\"\"Provider options for a DocumentOnTypeFormattingRequest.\"\"\"\n    first_trigger_character: str = attrs.field(\n        validator=attrs.validators.instance_of(str)\n    )\n    \"\"\"A character on which formatting should be triggered, like `{`.\"\"\"\n    more_trigger_character: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"More trigger characters.\"\"\"\n@attrs.define\nclass DocumentOnTypeFormattingRegistrationOptions:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentOnTypeFormattingRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentOnTypeFormattingRegistrationOptions:\n    \"\"\"Registration options for a DocumentOnTypeFormattingRequest.\"\"\"\n    first_trigger_character: str = attrs.field(\n        validator=attrs.validators.instance_of(str)\n    )\n    \"\"\"A character on which formatting should be triggered, like `{`.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameParams:\n    \"\"\"The parameters of a RenameRequest.\"\"\"\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The document to rename.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position at which this request was sent.\"\"\"\n    new_name: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The new name of the symbol.\n    If the given name is not valid the request must return a\n    ResponseError with an appropriate message set.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameOptions:\n    \"\"\"Provider options for a RenameRequest.\"\"\"\n    prepare_provider: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Renames should be checked and tested before being executed.\n    @since version 3.12.0\n    \"\"\"\n    # Since: version 3.12.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameRegistrationOptions:\n    \"\"\"Registration options for a RenameRequest.\"\"\"\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side\n    will be used.\n    \"\"\"\n    prepare_provider: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PrepareRenameParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PrepareRenameParams:\n    text_document: \"TextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document.\"\"\"\n    position: \"Position\" = attrs.field()\n    \"\"\"The position inside the text document.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n@attrs.define\nclass ExecuteCommandParams:\n    \"\"\"The parameters of a ExecuteCommandRequest.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ExecuteCommandParams:\n    \"\"\"The parameters of a ExecuteCommandRequest.\"\"\"\n    command: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The identifier of the actual command handler.\"\"\"\n    arguments: Optional[List[LSPAny]] = attrs.field(default=None)\n    \"\"\"Arguments that the command should be invoked with.\"\"\"\n    work_done_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report work done progress.\"\"\"\n@attrs.define\nclass ExecuteCommandOptions:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ExecuteCommandOptions:\n    \"\"\"The server capabilities of a ExecuteCommandRequest.\"\"\"\n    commands: List[str] = attrs.field()\n    \"\"\"The commands to be executed on the server.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass ExecuteCommandRegistrationOptions:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ExecuteCommandRegistrationOptions:\n    \"\"\"Registration options for a ExecuteCommandRequest.\"\"\"\n    commands: List[str] = attrs.field()\n    \"\"\"The commands to be executed on the server.\"\"\"\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n@attrs.define\nclass ApplyWorkspaceEditParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ApplyWorkspaceEditParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ApplyWorkspaceEditParams:\n    \"\"\"The parameters passed via a apply workspace edit request.\"\"\"\n    edit: WorkspaceEdit = attrs.field()\n    \"\"\"The edits to apply.\"\"\"\n    label: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"An optional label of the workspace edit.\n    This label is presented in the user interface for example on an undo",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ApplyWorkspaceEditResult",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ApplyWorkspaceEditResult:\n    \"\"\"The result returned from the apply workspace edit request.\n    @since 3.17 renamed from ApplyWorkspaceEditResponse\n    \"\"\"\n    # Since: 3.17 renamed from ApplyWorkspaceEditResponse\n    applied: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"Indicates whether the edit was applied or not.\"\"\"\n    failure_reason: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressBegin",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressBegin:\n    title: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"Mandatory title of the progress operation. Used to briefly inform about\n    the kind of operation being performed.\n    Examples: \"Indexing\" or \"Linking dependencies\".\n    \"\"\"\n    kind: str = attrs.field(validator=attrs.validators.in_([\"begin\"]), default=\"begin\")\n    cancellable: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressReport:\n    kind: str = attrs.field(\n        validator=attrs.validators.in_([\"report\"]), default=\"report\"\n    )\n    cancellable: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Controls enablement state of a cancel button.\n    Clients that don't support cancellation or don't support controlling",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkDoneProgressEnd",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkDoneProgressEnd:\n    kind: str = attrs.field(validator=attrs.validators.in_([\"end\"]), default=\"end\")\n    message: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"Optional, a final message indicating to for example indicate the outcome\n    of the operation.\"\"\"\n@attrs.define\nclass SetTraceParams:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SetTraceParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SetTraceParams:\n    value: TraceValues = attrs.field()\n@attrs.define\nclass LogTraceParams:\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    verbose: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LogTraceParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LogTraceParams:\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    verbose: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n@attrs.define\nclass CancelParams:\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id to cancel.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CancelParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CancelParams:\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id to cancel.\"\"\"\n@attrs.define\nclass ProgressParams:\n    token: ProgressToken = attrs.field()\n    \"\"\"The progress token provided by the client or server.\"\"\"\n    value: LSPAny = attrs.field()\n    \"\"\"The progress data.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ProgressParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ProgressParams:\n    token: ProgressToken = attrs.field()\n    \"\"\"The progress token provided by the client or server.\"\"\"\n    value: LSPAny = attrs.field()\n    \"\"\"The progress data.\"\"\"\n@attrs.define\nclass LocationLink:\n    \"\"\"Represents the connection of two locations.\n    Provides additional metadata over normal locations, including an\n    origin range.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LocationLink",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LocationLink:\n    \"\"\"Represents the connection of two locations.\n    Provides additional metadata over normal locations, including an\n    origin range.\n    \"\"\"\n    target_uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The target resource identifier of this link.\"\"\"\n    target_range: \"Range\" = attrs.field()\n    \"\"\"The full target range of this link.\n    If the target for example is a symbol then target range is the range",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Range",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Range:\n    \"\"\"A range in a text document expressed as (zero-based) start and end\n    positions.\n    If you want to specify a range that contains a line including the line ending\n    character(s) then use an end position denoting the start of the next line.\n    For example:\n    ```ts\n    {\n        start: { line: 5, character: 23 }\n        end : { line 6, character : 0 }",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFoldersChangeEvent",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceFoldersChangeEvent:\n    \"\"\"The workspace folder change event.\"\"\"\n    added: List[WorkspaceFolder] = attrs.field()\n    \"\"\"The array of added workspace folders.\"\"\"\n    removed: List[WorkspaceFolder] = attrs.field()\n    \"\"\"The array of the removed workspace folders.\"\"\"\n@attrs.define\nclass ConfigurationItem:\n    scope_uri: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ConfigurationItem",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ConfigurationItem:\n    scope_uri: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The scope to get the configuration section for.\"\"\"\n    section: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentIdentifier",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentIdentifier:\n    \"\"\"A literal to identify a text document in the client.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The text document's uri.\"\"\"\n@attrs.define\nclass Color:\n    \"\"\"Represents a color in RGBA space.\"\"\"\n    red: float = attrs.field(validator=attrs.validators.instance_of(float))\n    \"\"\"The red component of this color in the range [0-1].\"\"\"\n    green: float = attrs.field(validator=attrs.validators.instance_of(float))",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Color:\n    \"\"\"Represents a color in RGBA space.\"\"\"\n    red: float = attrs.field(validator=attrs.validators.instance_of(float))\n    \"\"\"The red component of this color in the range [0-1].\"\"\"\n    green: float = attrs.field(validator=attrs.validators.instance_of(float))\n    \"\"\"The green component of this color in the range [0-1].\"\"\"\n    blue: float = attrs.field(validator=attrs.validators.instance_of(float))\n    \"\"\"The blue component of this color in the range [0-1].\"\"\"\n    alpha: float = attrs.field(validator=attrs.validators.instance_of(float))\n    \"\"\"The alpha component of this color in the range [0-1].\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Position:\n    \"\"\"Position in a text document expressed as zero-based line and character\n    offset. Prior to 3.17 the offsets were always based on a UTF-16 string\n    representation. So a string of the form `ab` the character offset of the\n    character `a` is 0, the character offset of `` is 1 and the character\n    offset of b is 3 since `` is represented using two code units in UTF-16.\n    Since 3.17 clients and servers can agree on a different string encoding\n    representation (e.g. UTF-8). The client announces it's supported encoding\n    via the client capability.\n    [`general.positionEncodings`](#clientCapabilities). The value is an array",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensEdit",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensEdit:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    start: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"The start offset of the edit.\"\"\"\n    delete_count: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"The count of elements to remove.\"\"\"\n    data: Optional[List[int]] = attrs.field(default=None)\n    \"\"\"The elements to insert.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileCreate",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileCreate:\n    \"\"\"Represents information on a file/folder create.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A file:// URI for the location of the file/folder being created.\"\"\"\n@attrs.define\nclass TextDocumentEdit:\n    \"\"\"Describes textual changes on a text document.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentEdit",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentEdit:\n    \"\"\"Describes textual changes on a text document.\n    A TextDocumentEdit describes all changes on a document version Si\n    and after they are applied move the document to version Si+1. So the\n    creator of a TextDocumentEdit doesn't need to sort the array of\n    edits or do any kind of ordering. However the edits must be non\n    overlapping.\n    \"\"\"\n    text_document: \"OptionalVersionedTextDocumentIdentifier\" = attrs.field()\n    \"\"\"The text document to change.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ResourceOperation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ResourceOperation:\n    \"\"\"A generic resource operation.\"\"\"\n    kind: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The resource operation kind.\"\"\"\n    annotation_id: Optional[ChangeAnnotationIdentifier] = attrs.field(default=None)\n    \"\"\"An optional annotation identifier describing the operation.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CreateFile",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CreateFile:\n    \"\"\"Create file operation.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The resource to create.\"\"\"\n    kind: str = attrs.field(\n        validator=attrs.validators.in_([\"create\"]), default=\"create\"\n    )\n    \"\"\"A create.\"\"\"\n    options: Optional[\"CreateFileOptions\"] = attrs.field(default=None)\n    \"\"\"Additional options.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameFile",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameFile:\n    \"\"\"Rename file operation.\"\"\"\n    old_uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The old (existing) location.\"\"\"\n    new_uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The new location.\"\"\"\n    kind: str = attrs.field(\n        validator=attrs.validators.in_([\"rename\"]), default=\"rename\"\n    )\n    \"\"\"A rename.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeleteFile",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeleteFile:\n    \"\"\"Delete file operation.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The file to delete.\"\"\"\n    kind: str = attrs.field(\n        validator=attrs.validators.in_([\"delete\"]), default=\"delete\"\n    )\n    \"\"\"A delete.\"\"\"\n    options: Optional[\"DeleteFileOptions\"] = attrs.field(default=None)\n    \"\"\"Delete options.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ChangeAnnotation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ChangeAnnotation:\n    \"\"\"Additional information that describes document changes.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    label: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A human-readable string describing the actual change.\n    The string is rendered prominent in the user interface.\n    \"\"\"\n    needs_confirmation: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationFilter",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationFilter:\n    \"\"\"A filter to describe in which file operation requests or notifications\n    the server is interested in receiving.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    pattern: \"FileOperationPattern\" = attrs.field()\n    \"\"\"The actual file operation pattern.\"\"\"\n    scheme: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileRename",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileRename:\n    \"\"\"Represents information on a file/folder rename.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    old_uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A file:// URI for the original location of the file/folder being\n    renamed.\"\"\"\n    new_uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A file:// URI for the new location of the file/folder being renamed.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileDelete",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileDelete:\n    \"\"\"Represents information on a file/folder delete.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A file:// URI for the location of the file/folder being deleted.\"\"\"\n@attrs.define\nclass InlineValueContext:\n    \"\"\"@since 3.17.0\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueContext",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueContext:\n    \"\"\"@since 3.17.0\"\"\"\n    # Since: 3.17.0\n    frame_id: int = attrs.field(validator=validators.integer_validator)\n    \"\"\"The stack frame (as a DAP Id) where the execution has stopped.\"\"\"\n    stopped_location: Range = attrs.field()\n    \"\"\"The document range where execution has stopped.\n    Typically the end position of the range denotes the line where the\n    inline values are shown.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueText",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueText:\n    \"\"\"Provide inline value as text.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    range: Range = attrs.field()\n    \"\"\"The document range for which the inline value applies.\"\"\"\n    text: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The text of the inline value.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueVariableLookup",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueVariableLookup:\n    \"\"\"Provide inline value through a variable lookup. If only a range is\n    specified, the variable name will be extracted from the underlying\n    document. An optional variable name can be used to override the extracted\n    name.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    range: Range = attrs.field()\n    \"\"\"The document range for which the inline value applies.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueEvaluatableExpression",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueEvaluatableExpression:\n    \"\"\"Provide an inline value through an expression evaluation. If only a\n    range is specified, the expression will be extracted from the underlying\n    document. An optional expression can be used to override the extracted\n    expression.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    range: Range = attrs.field()\n    \"\"\"The document range for which the inline value applies.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintLabelPart",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintLabelPart:\n    \"\"\"An inlay hint label part allows for interactive and composite labels of\n    inlay hints.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    value: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The value of this label part.\"\"\"\n    tooltip: Optional[Union[str, \"MarkupContent\"]] = attrs.field(default=None)\n    \"\"\"The tooltip text when you hover over this label part.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MarkupContent",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MarkupContent:\n    \"\"\"A `MarkupContent` literal represents a string value which content is\n    interpreted base on its kind flag. Currently the protocol supports\n    `plaintext` and `markdown` as markup kinds.\n    If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.\n    See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting\n    Here is an example how such a string can be constructed using JavaScript / TypeScript:\n    ```ts\n    let markdown: MarkdownContent = {\n     kind: MarkupKind.Markdown,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FullDocumentDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FullDocumentDiagnosticReport:\n    \"\"\"A diagnostic report with a full set of problems.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    items: List[\"Diagnostic\"] = attrs.field()\n    \"\"\"The actual items.\"\"\"\n    kind: str = attrs.field(validator=attrs.validators.in_([\"full\"]), default=\"full\")\n    \"\"\"A full document diagnostic report.\"\"\"\n    result_id: Optional[str] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RelatedFullDocumentDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RelatedFullDocumentDiagnosticReport:\n    \"\"\"A full diagnostic report with a set of related documents.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    items: List[\"Diagnostic\"] = attrs.field()\n    \"\"\"The actual items.\"\"\"\n    related_documents: Optional[\n        Dict[\n            str,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "UnchangedDocumentDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class UnchangedDocumentDiagnosticReport:\n    \"\"\"A diagnostic report indicating that the last returned report is still\n    accurate.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    result_id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A result id which will be sent on the next diagnostic request for the\n    same document.\"\"\"\n    kind: str = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RelatedUnchangedDocumentDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RelatedUnchangedDocumentDiagnosticReport:\n    \"\"\"An unchanged diagnostic report with a set of related documents.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    result_id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A result id which will be sent on the next diagnostic request for the\n    same document.\"\"\"\n    related_documents: Optional[\n        Dict[",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PreviousResultId",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PreviousResultId:\n    \"\"\"A previous result id in a workspace pull request.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The URI for which the client knowns a result id.\"\"\"\n    value: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The value of the previous result id.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocument",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocument:\n    \"\"\"A notebook document.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The notebook document's uri.\"\"\"\n    notebook_type: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The type of the notebook.\"\"\"\n    version: int = attrs.field(validator=validators.integer_validator)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentItem",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentItem:\n    \"\"\"An item to transfer a text document from the client to the server.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The text document's uri.\"\"\"\n    language_id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The text document's language identifier.\"\"\"\n    version: int = attrs.field(validator=validators.integer_validator)\n    \"\"\"The version number of this document (it will increase after each change,\n    including undo/redo).\"\"\"\n    text: str = attrs.field(validator=attrs.validators.instance_of(str))",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "VersionedNotebookDocumentIdentifier",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class VersionedNotebookDocumentIdentifier:\n    \"\"\"A versioned notebook document identifier.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    version: int = attrs.field(validator=validators.integer_validator)\n    \"\"\"The version number of this notebook document.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The notebook document's uri.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentChangeEventCellsTypeStructureType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentChangeEventCellsTypeStructureType:\n    array: \"NotebookCellArrayChange\" = attrs.field()\n    \"\"\"The change to the cell array.\"\"\"\n    did_open: Optional[List[TextDocumentItem]] = attrs.field(default=None)\n    \"\"\"Additional opened cell text documents.\"\"\"\n    did_close: Optional[List[TextDocumentIdentifier]] = attrs.field(default=None)\n    \"\"\"Additional closed cell text documents.\"\"\"\n@attrs.define\nclass NotebookDocumentChangeEventCellsTypeTextContentType:\n    document: \"VersionedTextDocumentIdentifier\" = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentChangeEventCellsTypeTextContentType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentChangeEventCellsTypeTextContentType:\n    document: \"VersionedTextDocumentIdentifier\" = attrs.field()\n    changes: List[TextDocumentContentChangeEvent] = attrs.field()\n@attrs.define\nclass NotebookDocumentChangeEventCellsType:\n    structure: Optional[\n        \"NotebookDocumentChangeEventCellsTypeStructureType\"\n    ] = attrs.field(default=None)\n    \"\"\"Changes to the cell structure to add or remove cells.\"\"\"\n    data: Optional[List[\"NotebookCell\"]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentChangeEventCellsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentChangeEventCellsType:\n    structure: Optional[\n        \"NotebookDocumentChangeEventCellsTypeStructureType\"\n    ] = attrs.field(default=None)\n    \"\"\"Changes to the cell structure to add or remove cells.\"\"\"\n    data: Optional[List[\"NotebookCell\"]] = attrs.field(default=None)\n    \"\"\"Changes to notebook cells properties like its kind, execution summary or\n    metadata.\"\"\"\n    text_content: Optional[\n        List[\"NotebookDocumentChangeEventCellsTypeTextContentType\"]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentChangeEvent",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentChangeEvent:\n    \"\"\"A change event for a notebook document.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    metadata: Optional[\"LSPObject\"] = attrs.field(default=None)\n    \"\"\"The changed meta data if any.\n    Note: should always be an object literal (e.g. LSPObject)\n    \"\"\"\n    cells: Optional[\"NotebookDocumentChangeEventCellsType\"] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentIdentifier",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentIdentifier:\n    \"\"\"A literal to identify a notebook document in the client.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The notebook document's uri.\"\"\"\n@attrs.define\nclass Registration:\n    \"\"\"General parameters to to register for an notification or to register a",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Registration",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Registration:\n    \"\"\"General parameters to to register for an notification or to register a\n    provider.\"\"\"\n    id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The id used to register the request.\n    The id can be used to deregister the request again.\n    \"\"\"\n    method: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The method / capability to register for.\"\"\"\n    register_options: Optional[LSPAny] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Unregistration",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Unregistration:\n    \"\"\"General parameters to unregister a request or notification.\"\"\"\n    id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The id used to unregister the request or notification.\n    Usually an id provided during the register request.\n    \"\"\"\n    method: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The method to unregister for.\"\"\"\n@attrs.define\nclass ServerCapabilitiesWorkspaceType:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ServerCapabilitiesWorkspaceType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ServerCapabilitiesWorkspaceType:\n    workspace_folders: Optional[\"WorkspaceFoldersServerCapabilities\"] = attrs.field(\n        default=None\n    )\n    \"\"\"The server supports workspace folder.\n    @since 3.6.0\n    \"\"\"\n    # Since: 3.6.0\n    file_operations: Optional[\"FileOperationOptions\"] = attrs.field(default=None)\n    \"\"\"The server is interested in notifications/requests for operations on",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ServerCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ServerCapabilities:\n    \"\"\"Defines the capabilities provided by a language server.\"\"\"\n    position_encoding: Optional[Union[PositionEncodingKind, str]] = attrs.field(\n        default=None\n    )\n    \"\"\"The position encoding the server picked from the encodings offered by\n    the client via the client capability `general.positionEncodings`.\n    If the client didn't provide any position encodings the only valid\n    value that a server can return is 'utf-16'.\n    If omitted it defaults to 'utf-16'.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "VersionedTextDocumentIdentifier",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class VersionedTextDocumentIdentifier:\n    \"\"\"A text document identifier to denote a specific version of a text\n    document.\"\"\"\n    version: int = attrs.field(validator=validators.integer_validator)\n    \"\"\"The version number of this document.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The text document's uri.\"\"\"\n@attrs.define\nclass FileEvent:\n    \"\"\"An event describing a file change.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileEvent",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileEvent:\n    \"\"\"An event describing a file change.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The file's uri.\"\"\"\n    type: FileChangeType = attrs.field()\n    \"\"\"The change type.\"\"\"\n@attrs.define\nclass FileSystemWatcher:\n    glob_pattern: GlobPattern = attrs.field()\n    \"\"\"The glob pattern to watch. See {@link GlobPattern glob pattern} for more",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileSystemWatcher",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileSystemWatcher:\n    glob_pattern: GlobPattern = attrs.field()\n    \"\"\"The glob pattern to watch. See {@link GlobPattern glob pattern} for more\n    detail.\n    @since 3.17.0 support for relative patterns.\n    \"\"\"\n    # Since: 3.17.0 support for relative patterns.\n    kind: Optional[Union[WatchKind, int]] = attrs.field(default=None)\n    \"\"\"The kind of events of interest.\n    If omitted it defaults to WatchKind.Create | WatchKind.Change |",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Diagnostic",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class Diagnostic:\n    \"\"\"Represents a diagnostic, such as a compiler error or warning.\n    Diagnostic objects are only valid in the scope of a resource.\n    \"\"\"\n    range: Range = attrs.field()\n    \"\"\"The range at which the message applies.\"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The diagnostic's message.\n    It usually appears in the user interface\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionContext",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionContext:\n    \"\"\"Contains additional information about the context in which a completion\n    request is triggered.\"\"\"\n    trigger_kind: CompletionTriggerKind = attrs.field()\n    \"\"\"How the completion was triggered.\"\"\"\n    trigger_character: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"The trigger character (a single character) that has trigger code",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionItemLabelDetails",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionItemLabelDetails:\n    \"\"\"Additional details for a completion item label.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    detail: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,\n    )\n    \"\"\"An optional string which is rendered less prominently directly after.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InsertReplaceEdit",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InsertReplaceEdit:\n    \"\"\"A special text edit to provide an insert and a replace operation.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    new_text: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The string to be inserted.\"\"\"\n    insert: Range = attrs.field()\n    \"\"\"The range if the insert is requested.\"\"\"\n    replace: Range = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpContext",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpContext:\n    \"\"\"Additional information about the context in which a signature help\n    request was triggered.\n    @since 3.15.0\n    \"\"\"\n    # Since: 3.15.0\n    trigger_kind: SignatureHelpTriggerKind = attrs.field()\n    \"\"\"Action that caused signature help to be triggered.\"\"\"\n    is_retrigger: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"`true` if signature help was already showing when it was triggered.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureInformation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureInformation:\n    \"\"\"Represents the signature of something callable.\n    A signature can have a label, like a function-name, a doc-comment,\n    and a set of parameters.\n    \"\"\"\n    label: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The label of this signature.\n    Will be shown in the UI.\n    \"\"\"\n    documentation: Optional[Union[str, MarkupContent]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ReferenceContext",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ReferenceContext:\n    \"\"\"Value-object that contains additional information when requesting\n    references.\"\"\"\n    include_declaration: bool = attrs.field(\n        validator=attrs.validators.instance_of(bool)\n    )\n    \"\"\"Include the declaration of the current symbol.\"\"\"\n@attrs.define\nclass CodeActionContext:\n    \"\"\"Contains additional diagnostic information about the context in which a",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionContext",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionContext:\n    \"\"\"Contains additional diagnostic information about the context in which a\n    code action is run.\"\"\"\n    diagnostics: List[Diagnostic] = attrs.field()\n    \"\"\"An array of diagnostics known on the client side overlapping the range\n    provided to the `textDocument/codeAction` request.\n    They are provided so that the server knows which errors are\n    currently presented to the user for the given range. There is no\n    guarantee that these accurately reflect the error state of the\n    resource. The primary parameter to compute code actions is the",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FormattingOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FormattingOptions:\n    \"\"\"Value-object describing what options formatting should use.\"\"\"\n    tab_size: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"Size of a tab in spaces.\"\"\"\n    insert_spaces: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"Prefer spaces over tabs.\"\"\"\n    trim_trailing_whitespace: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensLegend",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensLegend:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    token_types: List[str] = attrs.field()\n    \"\"\"The token types a server uses.\"\"\"\n    token_modifiers: List[str] = attrs.field()\n    \"\"\"The token modifiers a server uses.\"\"\"\n@attrs.define\nclass OptionalVersionedTextDocumentIdentifier:\n    \"\"\"A text document identifier to optionally denote a specific version of a",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "OptionalVersionedTextDocumentIdentifier",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class OptionalVersionedTextDocumentIdentifier:\n    \"\"\"A text document identifier to optionally denote a specific version of a\n    text document.\"\"\"\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The text document's uri.\"\"\"\n    version: Optional[Union[int, None]] = attrs.field(default=None)\n    \"\"\"The version number of this document.\n    If a versioned text document identifier is sent from the server to\n    the client and the file is not open in the editor (the server has\n    not received an open notification before) the server can send `null`",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "AnnotatedTextEdit",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class AnnotatedTextEdit:\n    \"\"\"A special text edit with an additional change annotation.\n    @since 3.16.0.\n    \"\"\"\n    # Since: 3.16.0.\n    annotation_id: ChangeAnnotationIdentifier = attrs.field()\n    \"\"\"The actual identifier of the change annotation.\"\"\"\n    range: Range = attrs.field()\n    \"\"\"The range of the text document to be manipulated.\n    To insert text into a document create a range where start === end.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CreateFileOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CreateFileOptions:\n    \"\"\"Options to create a file.\"\"\"\n    overwrite: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Overwrite existing file.\n    Overwrite wins over `ignoreIfExists`\n    \"\"\"\n    ignore_if_exists: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameFileOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameFileOptions:\n    \"\"\"Rename file options.\"\"\"\n    overwrite: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Overwrite target if existing.\n    Overwrite wins over `ignoreIfExists`\n    \"\"\"\n    ignore_if_exists: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeleteFileOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeleteFileOptions:\n    \"\"\"Delete file options.\"\"\"\n    recursive: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Delete the content recursively if a folder is denoted.\"\"\"\n    ignore_if_not_exists: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationPattern",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationPattern:\n    \"\"\"A pattern to describe in which file operation requests or notifications\n    the server is interested in receiving.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    glob: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The glob pattern to match. Glob patterns can have the following syntax:\n    - `*` to match one or more characters in a path segment\n    - `?` to match on one character in a path segment",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFullDocumentDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceFullDocumentDiagnosticReport:\n    \"\"\"A full document diagnostic report for a workspace diagnostic result.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The URI for which diagnostic information is reported.\"\"\"\n    items: List[Diagnostic] = attrs.field()\n    \"\"\"The actual items.\"\"\"\n    version: Optional[Union[int, None]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceUnchangedDocumentDiagnosticReport",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceUnchangedDocumentDiagnosticReport:\n    \"\"\"An unchanged document diagnostic report for a workspace diagnostic\n    result.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    uri: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The URI for which diagnostic information is reported.\"\"\"\n    result_id: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A result id which will be sent on the next diagnostic request for the",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookCell",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookCell:\n    \"\"\"A notebook cell.\n    A cell's document URI must be unique across ALL notebook\n    cells and can therefore be used to uniquely identify a\n    notebook cell or the cell's text document.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    kind: NotebookCellKind = attrs.field()\n    \"\"\"The cell's kind.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookCellArrayChange",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookCellArrayChange:\n    \"\"\"A change describing how to move a `NotebookCell` array from state S to\n    S'.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    start: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"The start oftest of the cell that changed.\"\"\"\n    delete_count: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"The deleted cells.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ClientCapabilities:\n    \"\"\"Defines the capabilities provided by the client.\"\"\"\n    workspace: Optional[\"WorkspaceClientCapabilities\"] = attrs.field(default=None)\n    \"\"\"Workspace specific client capabilities.\"\"\"\n    text_document: Optional[\"TextDocumentClientCapabilities\"] = attrs.field(\n        default=None\n    )\n    \"\"\"Text document specific client capabilities.\"\"\"\n    notebook_document: Optional[\"NotebookDocumentClientCapabilities\"] = attrs.field(\n        default=None",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSyncOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSyncOptions:\n    open_close: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Open and close notifications are sent to the server.\n    If omitted open close notification should not be sent.\n    \"\"\"\n    change: Optional[TextDocumentSyncKind] = attrs.field(default=None)\n    \"\"\"Change notifications are sent to the server.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncOptionsNotebookSelectorType1CellsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncOptionsNotebookSelectorType1CellsType:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n@attrs.define\nclass NotebookDocumentSyncOptionsNotebookSelectorType1:\n    notebook: Union[str, NotebookDocumentFilter] = attrs.field()\n    \"\"\"The notebook to be synced If a string value is provided it matches\n    against the notebook type.\n    '*' matches every notebook.\n    \"\"\"\n    cells: Optional[",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncOptionsNotebookSelectorType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncOptionsNotebookSelectorType1:\n    notebook: Union[str, NotebookDocumentFilter] = attrs.field()\n    \"\"\"The notebook to be synced If a string value is provided it matches\n    against the notebook type.\n    '*' matches every notebook.\n    \"\"\"\n    cells: Optional[\n        List[\"NotebookDocumentSyncOptionsNotebookSelectorType1CellsType\"]\n    ] = attrs.field(default=None)\n    \"\"\"The cells of the matching notebook to be synced.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncOptionsNotebookSelectorType2CellsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncOptionsNotebookSelectorType2CellsType:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n@attrs.define\nclass NotebookDocumentSyncOptionsNotebookSelectorType2:\n    cells: List[\n        \"NotebookDocumentSyncOptionsNotebookSelectorType2CellsType\"\n    ] = attrs.field()\n    \"\"\"The cells of the matching notebook to be synced.\"\"\"\n    notebook: Optional[Union[str, NotebookDocumentFilter]] = attrs.field(default=None)\n    \"\"\"The notebook to be synced If a string value is provided it matches",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncOptionsNotebookSelectorType2",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncOptionsNotebookSelectorType2:\n    cells: List[\n        \"NotebookDocumentSyncOptionsNotebookSelectorType2CellsType\"\n    ] = attrs.field()\n    \"\"\"The cells of the matching notebook to be synced.\"\"\"\n    notebook: Optional[Union[str, NotebookDocumentFilter]] = attrs.field(default=None)\n    \"\"\"The notebook to be synced If a string value is provided it matches\n    against the notebook type.\n    '*' matches every notebook.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncOptions:\n    \"\"\"Options specific to a notebook plus its cells to be synced to the\n    server.\n    If a selector provides a notebook document\n    filter but no cell selector all cells of a\n    matching notebook document will be synced.\n    If a selector provides no notebook document\n    filter but only a cell selector all notebook\n    document that contain at least one matching\n    cell will be synced.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1CellsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1CellsType:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n@attrs.define\nclass NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1:\n    notebook: Union[str, NotebookDocumentFilter] = attrs.field()\n    \"\"\"The notebook to be synced If a string value is provided it matches\n    against the notebook type.\n    '*' matches every notebook.\n    \"\"\"\n    cells: Optional[",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1:\n    notebook: Union[str, NotebookDocumentFilter] = attrs.field()\n    \"\"\"The notebook to be synced If a string value is provided it matches\n    against the notebook type.\n    '*' matches every notebook.\n    \"\"\"\n    cells: Optional[\n        List[\"NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1CellsType\"]\n    ] = attrs.field(default=None)\n    \"\"\"The cells of the matching notebook to be synced.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2CellsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2CellsType:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n@attrs.define\nclass NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2:\n    cells: List[\n        \"NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2CellsType\"\n    ] = attrs.field()\n    \"\"\"The cells of the matching notebook to be synced.\"\"\"\n    notebook: Optional[Union[str, NotebookDocumentFilter]] = attrs.field(default=None)\n    \"\"\"The notebook to be synced If a string value is provided it matches",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2:\n    cells: List[\n        \"NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2CellsType\"\n    ] = attrs.field()\n    \"\"\"The cells of the matching notebook to be synced.\"\"\"\n    notebook: Optional[Union[str, NotebookDocumentFilter]] = attrs.field(default=None)\n    \"\"\"The notebook to be synced If a string value is provided it matches\n    against the notebook type.\n    '*' matches every notebook.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncRegistrationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncRegistrationOptions:\n    \"\"\"Registration options specific to a notebook.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    notebook_selector: List[\n        Union[\n            \"NotebookDocumentSyncRegistrationOptionsNotebookSelectorType1\",\n            \"NotebookDocumentSyncRegistrationOptionsNotebookSelectorType2\",\n        ]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceFoldersServerCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceFoldersServerCapabilities:\n    supported: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The server has support for workspace folders.\"\"\"\n    change_notifications: Optional[Union[str, bool]] = attrs.field(default=None)\n    \"\"\"Whether the server wants to receive workspace folder change\n    notifications.\n    If a string is provided the string is treated as an ID under which",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationOptions:\n    \"\"\"Options for notifications/requests for user operations on files.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    did_create: Optional[FileOperationRegistrationOptions] = attrs.field(default=None)\n    \"\"\"The server is interested in receiving didCreateFiles notifications.\"\"\"\n    will_create: Optional[FileOperationRegistrationOptions] = attrs.field(default=None)\n    \"\"\"The server is interested in receiving willCreateFiles requests.\"\"\"\n    did_rename: Optional[FileOperationRegistrationOptions] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeDescription",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeDescription:\n    \"\"\"Structure to capture a description for an error code.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    href: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"An URI to open with more information about the diagnostic error.\"\"\"\n@attrs.define\nclass DiagnosticRelatedInformation:\n    \"\"\"Represents a related message and source code location for a diagnostic.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticRelatedInformation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticRelatedInformation:\n    \"\"\"Represents a related message and source code location for a diagnostic.\n    This should be used to point to code locations that cause or related\n    to a diagnostics, e.g when duplicating a symbol in a scope.\n    \"\"\"\n    location: Location = attrs.field()\n    \"\"\"The location of this related diagnostic information.\"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The message of this related diagnostic information.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ParameterInformation",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ParameterInformation:\n    \"\"\"Represents a parameter of a callable-signature.\n    A parameter can have a label and a doc-comment.\n    \"\"\"\n    label: Union[str, Tuple[int, int]] = attrs.field()\n    \"\"\"The label of this parameter information.\n    Either a string or an inclusive start and exclusive end offsets within its containing\n    signature label. (see SignatureInformation.label). The offsets are based on a UTF-16\n    string representation as `Position` and `Range` does.\n    *Note*: a label of type string should be a substring of its containing signature label.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookCellTextDocumentFilter",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookCellTextDocumentFilter:\n    \"\"\"A notebook cell text document filter denotes a cell text document by\n    different properties.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    notebook: Union[str, NotebookDocumentFilter] = attrs.field()\n    \"\"\"A filter that matches against the notebook containing the notebook cell.\n    If a string value is provided it matches against the notebook type.\n    '*' matches every notebook.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationPatternOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationPatternOptions:\n    \"\"\"Matching options for the file operation pattern.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    ignore_case: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The pattern should be matched ignoring casing.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecutionSummary",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ExecutionSummary:\n    execution_order: int = attrs.field(validator=validators.uinteger_validator)\n    \"\"\"A strict monotonically increasing value indicating the execution order\n    of a cell inside a notebook.\"\"\"\n    success: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the execution was successful or not if known by the client.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceClientCapabilities:\n    \"\"\"Workspace specific client capabilities.\"\"\"\n    apply_edit: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The client supports applying batch edits to the workspace by supporting\n    the request 'workspace/applyEdit'.\"\"\"\n    workspace_edit: Optional[\"WorkspaceEditClientCapabilities\"] = attrs.field(\n        default=None",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentClientCapabilities:\n    \"\"\"Text document specific client capabilities.\"\"\"\n    synchronization: Optional[\"TextDocumentSyncClientCapabilities\"] = attrs.field(\n        default=None\n    )\n    \"\"\"Defines which synchronization capabilities the client supports.\"\"\"\n    completion: Optional[\"CompletionClientCapabilities\"] = attrs.field(default=None)\n    \"\"\"Capabilities specific to the `textDocument/completion` request.\"\"\"\n    hover: Optional[\"HoverClientCapabilities\"] = attrs.field(default=None)\n    \"\"\"Capabilities specific to the `textDocument/hover` request.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentClientCapabilities:\n    \"\"\"Capabilities specific to the notebook document support.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    synchronization: \"NotebookDocumentSyncClientCapabilities\" = attrs.field()\n    \"\"\"Capabilities specific to notebook document synchronization.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowClientCapabilities:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"It indicates whether the client supports server initiated progress using\n    the `window/workDoneProgress/create` request.\n    The capability also controls Whether client supports handling\n    of progress notifications. If set servers are allowed to report a\n    `workDoneProgress` property in the request specific server",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "GeneralClientCapabilitiesStaleRequestSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class GeneralClientCapabilitiesStaleRequestSupportType:\n    cancel: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"The client will actively cancel the request.\"\"\"\n    retry_on_content_modified: List[str] = attrs.field()\n    \"\"\"The list of requests for which the client will retry the request if it\n    receives a response with error code `ContentModified`\"\"\"\n@attrs.define\nclass GeneralClientCapabilities:\n    \"\"\"General client capabilities.\n    @since 3.16.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "GeneralClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class GeneralClientCapabilities:\n    \"\"\"General client capabilities.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    stale_request_support: Optional[\n        \"GeneralClientCapabilitiesStaleRequestSupportType\"\n    ] = attrs.field(default=None)\n    \"\"\"Client capability that signals how the client handles stale requests\n    (e.g. a request for which the client will not process the response anymore",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RelativePattern",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RelativePattern:\n    \"\"\"A relative pattern is a helper to construct glob patterns that are\n    matched relatively to a base URI. The common value for a `baseUri` is a\n    workspace folder root, but it can be another absolute URI as well.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    base_uri: Union[WorkspaceFolder, str] = attrs.field()\n    \"\"\"A workspace folder or a base URI to which this pattern will be matched\n    against relatively.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceEditClientCapabilitiesChangeAnnotationSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceEditClientCapabilitiesChangeAnnotationSupportType:\n    groups_on_label: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client groups edits with equal labels into tree nodes, for\n    instance all edits labelled with \"Changes in Strings\" would be a tree\n    node.\"\"\"\n@attrs.define\nclass WorkspaceEditClientCapabilities:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceEditClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceEditClientCapabilities:\n    document_changes: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The client supports versioned document changes in `WorkspaceEdit`s.\"\"\"\n    resource_operations: Optional[List[ResourceOperationKind]] = attrs.field(\n        default=None\n    )\n    \"\"\"The resource operations the client supports. Clients should at least",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeConfigurationClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeConfigurationClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Did change configuration notification supports dynamic registration.\"\"\"\n@attrs.define\nclass DidChangeWatchedFilesClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DidChangeWatchedFilesClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DidChangeWatchedFilesClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Did change watched files notification supports dynamic registration.\n    Please note that the current protocol doesn't support static\n    configuration for file changes from the server side.\n    \"\"\"\n    relative_pattern_support: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolClientCapabilitiesSymbolKindType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolClientCapabilitiesSymbolKindType:\n    value_set: Optional[List[SymbolKind]] = attrs.field(default=None)\n    \"\"\"The symbol kind values the client supports. When this property exists\n    the client also guarantees that it will handle values outside its set\n    gracefully and falls back to a default value when unknown.\n    If this property is not present the client only supports the symbol\n    kinds from `File` to `Array` as defined in the initial version of\n    the protocol.\n    \"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolClientCapabilitiesTagSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolClientCapabilitiesTagSupportType:\n    value_set: List[SymbolTag] = attrs.field()\n    \"\"\"The tags supported by the client.\"\"\"\n@attrs.define\nclass WorkspaceSymbolClientCapabilitiesResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\n    Usually `location.range`\n    \"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolClientCapabilitiesResolveSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolClientCapabilitiesResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\n    Usually `location.range`\n    \"\"\"\n@attrs.define\nclass WorkspaceSymbolClientCapabilities:\n    \"\"\"Client capabilities for a WorkspaceSymbolRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolClientCapabilities:\n    \"\"\"Client capabilities for a WorkspaceSymbolRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Symbol request supports dynamic registration.\"\"\"\n    symbol_kind: Optional[\n        \"WorkspaceSymbolClientCapabilitiesSymbolKindType\"\n    ] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ExecuteCommandClientCapabilities:\n    \"\"\"The client capabilities of a ExecuteCommandRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Execute command supports dynamic registration.\"\"\"\n@attrs.define\nclass SemanticTokensWorkspaceClientCapabilities:\n    \"\"\"@since 3.16.0\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensWorkspaceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensWorkspaceClientCapabilities:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    refresh_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client implementation supports a refresh request sent from\n    the server to the client.\n    Note that this event is global and will force the client to refresh",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensWorkspaceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensWorkspaceClientCapabilities:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    refresh_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client implementation supports a refresh request sent from\n    the server to the client.\n    Note that this event is global and will force the client to refresh",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FileOperationClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FileOperationClientCapabilities:\n    \"\"\"Capabilities relating to events from file operations by the user in the\n    client.\n    These events do not come from the file system, they come from user operations\n    like renaming a file in the UI.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueWorkspaceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueWorkspaceClientCapabilities:\n    \"\"\"Client workspace capabilities specific to inline values.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    refresh_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client implementation supports a refresh request sent from",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintWorkspaceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintWorkspaceClientCapabilities:\n    \"\"\"Client workspace capabilities specific to inlay hints.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    refresh_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client implementation supports a refresh request sent from",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticWorkspaceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticWorkspaceClientCapabilities:\n    \"\"\"Workspace client capabilities specific to diagnostic pull requests.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    refresh_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client implementation supports a refresh request sent from",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSyncClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSyncClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether text document synchronization supports dynamic registration.\"\"\"\n    will_save: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilitiesCompletionItemTypeTagSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilitiesCompletionItemTypeTagSupportType:\n    value_set: List[CompletionItemTag] = attrs.field()\n    \"\"\"The tags supported by the client.\"\"\"\n@attrs.define\nclass CompletionClientCapabilitiesCompletionItemTypeResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\"\"\"\n@attrs.define\nclass CompletionClientCapabilitiesCompletionItemTypeInsertTextModeSupportType:\n    value_set: List[InsertTextMode] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilitiesCompletionItemTypeResolveSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilitiesCompletionItemTypeResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\"\"\"\n@attrs.define\nclass CompletionClientCapabilitiesCompletionItemTypeInsertTextModeSupportType:\n    value_set: List[InsertTextMode] = attrs.field()\n@attrs.define\nclass CompletionClientCapabilitiesCompletionItemType:\n    snippet_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilitiesCompletionItemTypeInsertTextModeSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilitiesCompletionItemTypeInsertTextModeSupportType:\n    value_set: List[InsertTextMode] = attrs.field()\n@attrs.define\nclass CompletionClientCapabilitiesCompletionItemType:\n    snippet_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Client supports snippets as insert text.\n    A snippet can define tab stops and placeholders with `$1`, `$2` and",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilitiesCompletionItemType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilitiesCompletionItemType:\n    snippet_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Client supports snippets as insert text.\n    A snippet can define tab stops and placeholders with `$1`, `$2` and\n    `${3:foo}`. `$0` defines the final tab stop, it defaults to the end\n    of the snippet. Placeholders with equal identifiers are linked, that\n    is typing in one will update others too.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilitiesCompletionItemKindType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilitiesCompletionItemKindType:\n    value_set: Optional[List[CompletionItemKind]] = attrs.field(default=None)\n    \"\"\"The completion item kind values the client supports. When this property\n    exists the client also guarantees that it will handle values outside its\n    set gracefully and falls back to a default value when unknown.\n    If this property is not present the client only supports the\n    completion items kinds from `Text` to `Reference` as defined in the\n    initial version of the protocol.\n    \"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilitiesCompletionListType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilitiesCompletionListType:\n    item_defaults: Optional[List[str]] = attrs.field(default=None)\n    \"\"\"The client supports the following itemDefaults on a completion list.\n    The value lists the supported property names of the\n    `CompletionList.itemDefaults` object. If omitted\n    no properties are supported.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionClientCapabilities:\n    \"\"\"Completion client capabilities.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether completion supports dynamic registration.\"\"\"\n    completion_item: Optional[\n        \"CompletionClientCapabilitiesCompletionItemType\"\n    ] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "HoverClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class HoverClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether hover supports dynamic registration.\"\"\"\n    content_format: Optional[List[MarkupKind]] = attrs.field(default=None)\n    \"\"\"Client supports the following content formats for the content property.\n    The order describes the preferred format of the client.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpClientCapabilitiesSignatureInformationTypeParameterInformationType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpClientCapabilitiesSignatureInformationTypeParameterInformationType:\n    label_offset_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The client supports processing label offsets instead of a simple label\n    string.\n    @since 3.14.0\n    \"\"\"\n    # Since: 3.14.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpClientCapabilitiesSignatureInformationType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpClientCapabilitiesSignatureInformationType:\n    documentation_format: Optional[List[MarkupKind]] = attrs.field(default=None)\n    \"\"\"Client supports the following content formats for the documentation\n    property.\n    The order describes the preferred format of the client.\n    \"\"\"\n    parameter_information: Optional[\n        \"SignatureHelpClientCapabilitiesSignatureInformationTypeParameterInformationType\"\n    ] = attrs.field(default=None)\n    \"\"\"Client capabilities specific to parameter information.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SignatureHelpClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SignatureHelpClientCapabilities:\n    \"\"\"Client Capabilities for a SignatureHelpRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether signature help supports dynamic registration.\"\"\"\n    signature_information: Optional[\n        \"SignatureHelpClientCapabilitiesSignatureInformationType\"\n    ] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeclarationClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DeclarationClientCapabilities:\n    \"\"\"@since 3.14.0\"\"\"\n    # Since: 3.14.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether declaration supports dynamic registration.\n    If this is set to `true` the client supports the new\n    `DeclarationRegistrationOptions` return value for the corresponding",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DefinitionClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DefinitionClientCapabilities:\n    \"\"\"Client Capabilities for a DefinitionRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether definition supports dynamic registration.\"\"\"\n    link_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeDefinitionClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeDefinitionClientCapabilities:\n    \"\"\"Since 3.6.0.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.\n    If this is set to `true` the client supports the new\n    `TypeDefinitionRegistrationOptions` return value for the\n    corresponding server capability as well.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ImplementationClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ImplementationClientCapabilities:\n    \"\"\"@since 3.6.0\"\"\"\n    # Since: 3.6.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.\n    If this is set to `true` the client supports the new\n    `ImplementationRegistrationOptions` return value for the",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ReferenceClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ReferenceClientCapabilities:\n    \"\"\"Client Capabilities for a ReferencesRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether references supports dynamic registration.\"\"\"\n@attrs.define\nclass DocumentHighlightClientCapabilities:\n    \"\"\"Client Capabilities for a DocumentHighlightRequest.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentHighlightClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentHighlightClientCapabilities:\n    \"\"\"Client Capabilities for a DocumentHighlightRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether document highlight supports dynamic registration.\"\"\"\n@attrs.define\nclass DocumentSymbolClientCapabilitiesSymbolKindType:\n    value_set: Optional[List[SymbolKind]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbolClientCapabilitiesSymbolKindType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbolClientCapabilitiesSymbolKindType:\n    value_set: Optional[List[SymbolKind]] = attrs.field(default=None)\n    \"\"\"The symbol kind values the client supports. When this property exists\n    the client also guarantees that it will handle values outside its set\n    gracefully and falls back to a default value when unknown.\n    If this property is not present the client only supports the symbol\n    kinds from `File` to `Array` as defined in the initial version of\n    the protocol.\n    \"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbolClientCapabilitiesTagSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbolClientCapabilitiesTagSupportType:\n    value_set: List[SymbolTag] = attrs.field()\n    \"\"\"The tags supported by the client.\"\"\"\n@attrs.define\nclass DocumentSymbolClientCapabilities:\n    \"\"\"Client Capabilities for a DocumentSymbolRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSymbolClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentSymbolClientCapabilities:\n    \"\"\"Client Capabilities for a DocumentSymbolRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether document symbol supports dynamic registration.\"\"\"\n    symbol_kind: Optional[\n        \"DocumentSymbolClientCapabilitiesSymbolKindType\"\n    ] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionClientCapabilitiesCodeActionLiteralSupportTypeCodeActionKindType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionClientCapabilitiesCodeActionLiteralSupportTypeCodeActionKindType:\n    value_set: List[Union[CodeActionKind, str]] = attrs.field()\n    \"\"\"The code action kind values the client supports.\n    When this property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back to a default\n    value when unknown.\n    \"\"\"\n@attrs.define\nclass CodeActionClientCapabilitiesCodeActionLiteralSupportType:\n    code_action_kind: \"CodeActionClientCapabilitiesCodeActionLiteralSupportTypeCodeActionKindType\" = (",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionClientCapabilitiesCodeActionLiteralSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionClientCapabilitiesCodeActionLiteralSupportType:\n    code_action_kind: \"CodeActionClientCapabilitiesCodeActionLiteralSupportTypeCodeActionKindType\" = (\n        attrs.field()\n    )\n    \"\"\"The code action kind is support with the following value set.\"\"\"\n@attrs.define\nclass CodeActionClientCapabilitiesResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionClientCapabilitiesResolveSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionClientCapabilitiesResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\"\"\"\n@attrs.define\nclass CodeActionClientCapabilities:\n    \"\"\"The Client Capabilities of a CodeActionRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionClientCapabilities:\n    \"\"\"The Client Capabilities of a CodeActionRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether code action supports dynamic registration.\"\"\"\n    code_action_literal_support: Optional[\n        \"CodeActionClientCapabilitiesCodeActionLiteralSupportType\"\n    ] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensClientCapabilities:\n    \"\"\"The client capabilities  of a CodeLensRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether code lens supports dynamic registration.\"\"\"\n@attrs.define\nclass DocumentLinkClientCapabilities:\n    \"\"\"The client capabilities of a DocumentLinkRequest.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLinkClientCapabilities:\n    \"\"\"The client capabilities of a DocumentLinkRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether document link supports dynamic registration.\"\"\"\n    tooltip_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentColorClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentColorClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.\n    If this is set to `true` the client supports the new\n    `DocumentColorRegistrationOptions` return value for the\n    corresponding server capability as well.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentFormattingClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentFormattingClientCapabilities:\n    \"\"\"Client capabilities of a DocumentFormattingRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether formatting supports dynamic registration.\"\"\"\n@attrs.define\nclass DocumentRangeFormattingClientCapabilities:\n    \"\"\"Client capabilities of a DocumentRangeFormattingRequest.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentRangeFormattingClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentRangeFormattingClientCapabilities:\n    \"\"\"Client capabilities of a DocumentRangeFormattingRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether range formatting supports dynamic registration.\"\"\"\n@attrs.define\nclass DocumentOnTypeFormattingClientCapabilities:\n    \"\"\"Client capabilities of a DocumentOnTypeFormattingRequest.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentOnTypeFormattingClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentOnTypeFormattingClientCapabilities:\n    \"\"\"Client capabilities of a DocumentOnTypeFormattingRequest.\"\"\"\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether on type formatting supports dynamic registration.\"\"\"\n@attrs.define\nclass RenameClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RenameClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RenameClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether rename supports dynamic registration.\"\"\"\n    prepare_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeClientCapabilitiesFoldingRangeKindType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeClientCapabilitiesFoldingRangeKindType:\n    value_set: Optional[List[Union[FoldingRangeKind, str]]] = attrs.field(default=None)\n    \"\"\"The folding range kind values the client supports.\n    When this property exists the client also guarantees that it will\n    handle values outside its set gracefully and falls back to a default\n    value when unknown.\n    \"\"\"\n@attrs.define\nclass FoldingRangeClientCapabilitiesFoldingRangeType:\n    collapsed_text: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeClientCapabilitiesFoldingRangeType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeClientCapabilitiesFoldingRangeType:\n    collapsed_text: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"If set, the client signals that it supports setting collapsedText on\n    folding ranges to display custom labels instead of the default text.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "FoldingRangeClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class FoldingRangeClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration for folding range\n    providers.\n    If this is set to `true` the client supports the new\n    `FoldingRangeRegistrationOptions` return value for the corresponding\n    server capability as well.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SelectionRangeClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SelectionRangeClientCapabilities:\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration for selection range\n    providers.\n    If this is set to `true` the client supports the new\n    `SelectionRangeRegistrationOptions` return value for the\n    corresponding server capability as well.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PublishDiagnosticsClientCapabilitiesTagSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PublishDiagnosticsClientCapabilitiesTagSupportType:\n    value_set: List[DiagnosticTag] = attrs.field()\n    \"\"\"The tags supported by the client.\"\"\"\n@attrs.define\nclass PublishDiagnosticsClientCapabilities:\n    \"\"\"The publish diagnostic client capabilities.\"\"\"\n    related_information: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PublishDiagnosticsClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class PublishDiagnosticsClientCapabilities:\n    \"\"\"The publish diagnostic client capabilities.\"\"\"\n    related_information: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the clients accepts diagnostics with related information.\"\"\"\n    tag_support: Optional[\n        \"PublishDiagnosticsClientCapabilitiesTagSupportType\"\n    ] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyClientCapabilities:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.\n    If this is set to `true` the client supports the new\n    `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensClientCapabilitiesRequestsTypeFullType1",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensClientCapabilitiesRequestsTypeFullType1:\n    delta: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"The client will send the `textDocument/semanticTokens/full/delta`\n    request if the server provides a corresponding handler.\"\"\"\n@attrs.define\nclass SemanticTokensClientCapabilitiesRequestsType:\n    range: Optional[Union[bool, Any]] = attrs.field(default=None)",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensClientCapabilitiesRequestsType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensClientCapabilitiesRequestsType:\n    range: Optional[Union[bool, Any]] = attrs.field(default=None)\n    \"\"\"The client will send the `textDocument/semanticTokens/range` request if\n    the server provides a corresponding handler.\"\"\"\n    full: Optional[\n        Union[bool, \"SemanticTokensClientCapabilitiesRequestsTypeFullType1\"]\n    ] = attrs.field(default=None)\n    \"\"\"The client will send the `textDocument/semanticTokens/full` request if\n    the server provides a corresponding handler.\"\"\"\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SemanticTokensClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SemanticTokensClientCapabilities:\n    \"\"\"@since 3.16.0\"\"\"\n    # Since: 3.16.0\n    requests: \"SemanticTokensClientCapabilitiesRequestsType\" = attrs.field()\n    \"\"\"Which requests the client supports and might send to the server\n    depending on the server's capability.\n    Please note that clients might not show semantic tokens or degrade\n    some of the user experience if a range or full request is advertised\n    by the client but not provided by the server. If for example the\n    client capability `requests.full` and `request.range` are both set",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LinkedEditingRangeClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LinkedEditingRangeClientCapabilities:\n    \"\"\"Client capabilities for the linked editing range request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MonikerClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MonikerClientCapabilities:\n    \"\"\"Client capabilities specific to the moniker request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether moniker supports dynamic registration.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchyClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchyClientCapabilities:\n    \"\"\"@since 3.17.0\"\"\"\n    # Since: 3.17.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.\n    If this is set to `true` the client supports the new\n    `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValueClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlineValueClientCapabilities:\n    \"\"\"Client capabilities specific to inline values.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration for inline value",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintClientCapabilitiesResolveSupportType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintClientCapabilitiesResolveSupportType:\n    properties: List[str] = attrs.field()\n    \"\"\"The properties that a client can resolve lazily.\"\"\"\n@attrs.define\nclass InlayHintClientCapabilities:\n    \"\"\"Inlay hint client capabilities.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    dynamic_registration: Optional[bool] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintClientCapabilities:\n    \"\"\"Inlay hint client capabilities.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether inlay hints support dynamic registration.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DiagnosticClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DiagnosticClientCapabilities:\n    \"\"\"Client capabilities specific to diagnostic pull requests.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentSyncClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentSyncClientCapabilities:\n    \"\"\"Notebook specific client capabilities.\n    @since 3.17.0\n    \"\"\"\n    # Since: 3.17.0\n    dynamic_registration: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether implementation supports dynamic registration.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowMessageRequestClientCapabilitiesMessageActionItemType",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowMessageRequestClientCapabilitiesMessageActionItemType:\n    additional_properties_support: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    \"\"\"Whether the client supports additional attributes which are preserved\n    and send back to the server in the request's response.\"\"\"\n@attrs.define\nclass ShowMessageRequestClientCapabilities:\n    \"\"\"Show message request client capabilities.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowMessageRequestClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowMessageRequestClientCapabilities:\n    \"\"\"Show message request client capabilities.\"\"\"\n    message_action_item: Optional[\n        \"ShowMessageRequestClientCapabilitiesMessageActionItemType\"\n    ] = attrs.field(default=None)\n    \"\"\"Capabilities specific to the `MessageActionItem` type.\"\"\"\n@attrs.define\nclass ShowDocumentClientCapabilities:\n    \"\"\"Client capabilities for the showDocument request.\n    @since 3.16.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShowDocumentClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShowDocumentClientCapabilities:\n    \"\"\"Client capabilities for the showDocument request.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    support: bool = attrs.field(validator=attrs.validators.instance_of(bool))\n    \"\"\"The client has support for the showDocument request.\"\"\"\n@attrs.define\nclass RegularExpressionsClientCapabilities:\n    \"\"\"Client capabilities specific to regular expressions.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RegularExpressionsClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class RegularExpressionsClientCapabilities:\n    \"\"\"Client capabilities specific to regular expressions.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    engine: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The engine's name.\"\"\"\n    version: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MarkdownClientCapabilities",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MarkdownClientCapabilities:\n    \"\"\"Client capabilities specific to the used markdown parser.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    parser: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"The name of the parser.\"\"\"\n    version: Optional[str] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(str)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceConfigurationParams",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceConfigurationParams:\n    items: List[ConfigurationItem] = attrs.field()\n    partial_result_token: Optional[ProgressToken] = attrs.field(default=None)\n    \"\"\"An optional token that a server can use to report partial results (e.g.\n    streaming) to the client.\"\"\"\n@attrs.define\nclass TextDocumentColorPresentationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentColorPresentationOptions",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentColorPresentationOptions:\n    work_done_progress: Optional[bool] = attrs.field(\n        validator=attrs.validators.optional(attrs.validators.instance_of(bool)),\n        default=None,\n    )\n    document_selector: Optional[Union[DocumentSelector, None]] = attrs.field(\n        default=None\n    )\n    \"\"\"A document selector to identify the scope of the registration.\n    If set to null the document selector provided on the client side",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ResponseError",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ResponseError:\n    code: int = attrs.field(validator=validators.integer_validator)\n    \"\"\"A number indicating the error type that occurred.\"\"\"\n    message: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A string providing a short description of the error.\"\"\"\n    data: Optional[LSPAny] = attrs.field(default=None)\n    \"\"\"A primitive or structured value that contains additional information\n    about the error.\n    Can be omitted.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ResponseErrorMessage",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ResponseErrorMessage:\n    id: Optional[Union[int, str]] = attrs.field(default=None)\n    \"\"\"The request id where the error occurred.\"\"\"\n    error: Optional[ResponseError] = attrs.field(default=None)\n    \"\"\"The error object in case a request fails.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentImplementationRequest:\n    \"\"\"A request to resolve the implementation locations of a symbol at a given\n    text document position.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentImplementationRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentImplementationRequest:\n    \"\"\"A request to resolve the implementation locations of a symbol at a given\n    text document position.\n    The request's parameter is of type [TextDocumentPositionParams]\n    (#TextDocumentPositionParams) the response is of type Definition or\n    a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ImplementationParams = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentImplementationResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentImplementationResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[Definition, List[DefinitionLink], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentTypeDefinitionRequest:\n    \"\"\"A request to resolve the type definition locations of a symbol at a\n    given text document position.\n    The request's parameter is of type [TextDocumentPositionParams]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentTypeDefinitionRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentTypeDefinitionRequest:\n    \"\"\"A request to resolve the type definition locations of a symbol at a\n    given text document position.\n    The request's parameter is of type [TextDocumentPositionParams]\n    (#TextDocumentPositionParams) the response is of type Definition or\n    a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: TypeDefinitionParams = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentTypeDefinitionResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentTypeDefinitionResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[Definition, List[DefinitionLink], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceWorkspaceFoldersRequest:\n    \"\"\"The `workspace/workspaceFolders` is sent from the server to the client\n    to fetch the open workspace folders.\"\"\"\n    id: Union[int, str] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWorkspaceFoldersRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWorkspaceFoldersRequest:\n    \"\"\"The `workspace/workspaceFolders` is sent from the server to the client\n    to fetch the open workspace folders.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"workspace/workspaceFolders\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWorkspaceFoldersResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWorkspaceFoldersResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[WorkspaceFolder], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceConfigurationRequest:\n    \"\"\"The 'workspace/configuration' request is sent from the server to the\n    client to fetch a certain configuration setting.\n    This pull model replaces the old push model were the client signaled",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceConfigurationRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceConfigurationRequest:\n    \"\"\"The 'workspace/configuration' request is sent from the server to the\n    client to fetch a certain configuration setting.\n    This pull model replaces the old push model were the client signaled\n    configuration change via an event. If the server still needs to\n    react to configuration changes (since the server caches the result\n    of `workspace/configuration` requests) the server should register\n    for an empty configuration change event and empty the cache if such\n    an event is received.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceConfigurationResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceConfigurationResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: List[LSPAny] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDocumentColorRequest:\n    \"\"\"A request to list all color symbols found in a given text document.\n    The request's parameter is of type DocumentColorParams the response\n    is of type ColorInformation[] or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentColorRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentColorRequest:\n    \"\"\"A request to list all color symbols found in a given text document.\n    The request's parameter is of type DocumentColorParams the response\n    is of type ColorInformation[] or a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentColorParams = attrs.field()\n    method: str = \"textDocument/documentColor\"\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentColorResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentColorResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: List[ColorInformation] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentColorPresentationRequest:\n    \"\"\"A request to list all presentation for a color.\n    The request's parameter is of type ColorPresentationParams the\n    response is of type ColorInformation[] or a Thenable that resolves",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentColorPresentationRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentColorPresentationRequest:\n    \"\"\"A request to list all presentation for a color.\n    The request's parameter is of type ColorPresentationParams the\n    response is of type ColorInformation[] or a Thenable that resolves\n    to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ColorPresentationParams = attrs.field()\n    method: str = \"textDocument/colorPresentation\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentColorPresentationResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentColorPresentationResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: List[ColorPresentation] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentFoldingRangeRequest:\n    \"\"\"A request to provide folding ranges in a document.\n    The request's parameter is of type FoldingRangeParams, the response\n    is of type FoldingRangeList or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFoldingRangeRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFoldingRangeRequest:\n    \"\"\"A request to provide folding ranges in a document.\n    The request's parameter is of type FoldingRangeParams, the response\n    is of type FoldingRangeList or a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: FoldingRangeParams = attrs.field()\n    method: str = \"textDocument/foldingRange\"\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFoldingRangeResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFoldingRangeResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[FoldingRange], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDeclarationRequest:\n    \"\"\"A request to resolve the type definition locations of a symbol at a\n    given text document position.\n    The request's parameter is of type [TextDocumentPositionParams]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDeclarationRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDeclarationRequest:\n    \"\"\"A request to resolve the type definition locations of a symbol at a\n    given text document position.\n    The request's parameter is of type [TextDocumentPositionParams]\n    (#TextDocumentPositionParams) the response is of type Declaration or\n    a typed array of DeclarationLink or a Thenable that resolves to\n    such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDeclarationResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDeclarationResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[Declaration, List[DeclarationLink], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSelectionRangeRequest:\n    \"\"\"A request to provide selection ranges in a document.\n    The request's parameter is of type SelectionRangeParams, the\n    response is of type [SelectionRange[]](#SelectionRange[]) or a",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSelectionRangeRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSelectionRangeRequest:\n    \"\"\"A request to provide selection ranges in a document.\n    The request's parameter is of type SelectionRangeParams, the\n    response is of type [SelectionRange[]](#SelectionRange[]) or a\n    Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: SelectionRangeParams = attrs.field()\n    method: str = \"textDocument/selectionRange\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSelectionRangeResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSelectionRangeResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[SelectionRange], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WindowWorkDoneProgressCreateRequest:\n    \"\"\"The `window/workDoneProgress/create` request is sent from the server to\n    the client to initiate progress reporting from the server.\"\"\"\n    id: Union[int, str] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowWorkDoneProgressCreateRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowWorkDoneProgressCreateRequest:\n    \"\"\"The `window/workDoneProgress/create` request is sent from the server to\n    the client to initiate progress reporting from the server.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: WorkDoneProgressCreateParams = attrs.field()\n    method: str = \"window/workDoneProgress/create\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowWorkDoneProgressCreateResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowWorkDoneProgressCreateResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentPrepareCallHierarchyRequest:\n    \"\"\"A request to result a `CallHierarchyItem` in a document at a given\n    position. Can be used as an input to an incoming or outgoing call\n    hierarchy.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPrepareCallHierarchyRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPrepareCallHierarchyRequest:\n    \"\"\"A request to result a `CallHierarchyItem` in a document at a given\n    position. Can be used as an input to an incoming or outgoing call\n    hierarchy.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CallHierarchyPrepareParams = attrs.field()\n    method: str = \"textDocument/prepareCallHierarchy\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPrepareCallHierarchyResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPrepareCallHierarchyResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[CallHierarchyItem], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CallHierarchyIncomingCallsRequest:\n    \"\"\"A request to resolve the incoming calls for a given `CallHierarchyItem`.\n    @since 3.16.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyIncomingCallsRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyIncomingCallsRequest:\n    \"\"\"A request to resolve the incoming calls for a given `CallHierarchyItem`.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CallHierarchyIncomingCallsParams = attrs.field()\n    method: str = \"callHierarchy/incomingCalls\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyIncomingCallsResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyIncomingCallsResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[CallHierarchyIncomingCall], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CallHierarchyOutgoingCallsRequest:\n    \"\"\"A request to resolve the outgoing calls for a given `CallHierarchyItem`.\n    @since 3.16.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyOutgoingCallsRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyOutgoingCallsRequest:\n    \"\"\"A request to resolve the outgoing calls for a given `CallHierarchyItem`.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CallHierarchyOutgoingCallsParams = attrs.field()\n    method: str = \"callHierarchy/outgoingCalls\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CallHierarchyOutgoingCallsResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CallHierarchyOutgoingCallsResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[CallHierarchyOutgoingCall], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSemanticTokensFullRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSemanticTokensFullRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSemanticTokensFullRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: SemanticTokensParams = attrs.field()\n    method: str = \"textDocument/semanticTokens/full\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSemanticTokensFullResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSemanticTokensFullResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSemanticTokensFullResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[SemanticTokens, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSemanticTokensFullDeltaRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSemanticTokensFullDeltaRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSemanticTokensFullDeltaRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: SemanticTokensDeltaParams = attrs.field()\n    method: str = \"textDocument/semanticTokens/full/delta\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSemanticTokensFullDeltaResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSemanticTokensFullDeltaResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSemanticTokensFullDeltaResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[SemanticTokens, SemanticTokensDelta, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSemanticTokensRangeRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSemanticTokensRangeRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSemanticTokensRangeRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: SemanticTokensRangeParams = attrs.field()\n    method: str = \"textDocument/semanticTokens/range\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSemanticTokensRangeResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSemanticTokensRangeResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSemanticTokensRangeResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[SemanticTokens, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceSemanticTokensRefreshRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSemanticTokensRefreshRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSemanticTokensRefreshRequest:\n    \"\"\"@since 3.16.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"workspace/semanticTokens/refresh\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceSemanticTokensRefreshResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSemanticTokensRefreshResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSemanticTokensRefreshResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WindowShowDocumentRequest:\n    \"\"\"A request to show a document. This request might open an external\n    program depending on the value of the URI to open. For example a request to\n    open `https://code.visualstudio.com/` will very likely open the URI in a",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowShowDocumentRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowShowDocumentRequest:\n    \"\"\"A request to show a document. This request might open an external\n    program depending on the value of the URI to open. For example a request to\n    open `https://code.visualstudio.com/` will very likely open the URI in a\n    WEB browser.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ShowDocumentParams = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowShowDocumentResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowShowDocumentResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: ShowDocumentResult = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentLinkedEditingRangeRequest:\n    \"\"\"A request to provide ranges that can be edited together.\n    @since 3.16.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentLinkedEditingRangeRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentLinkedEditingRangeRequest:\n    \"\"\"A request to provide ranges that can be edited together.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: LinkedEditingRangeParams = attrs.field()\n    method: str = \"textDocument/linkedEditingRange\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentLinkedEditingRangeResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentLinkedEditingRangeResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[LinkedEditingRanges, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceWillCreateFilesRequest:\n    \"\"\"The will create files request is sent from the client to the server\n    before files are actually created as long as the creation is triggered from\n    within the client.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWillCreateFilesRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWillCreateFilesRequest:\n    \"\"\"The will create files request is sent from the client to the server\n    before files are actually created as long as the creation is triggered from\n    within the client.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CreateFilesParams = attrs.field()\n    method: str = \"workspace/willCreateFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWillCreateFilesResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWillCreateFilesResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[WorkspaceEdit, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceWillRenameFilesRequest:\n    \"\"\"The will rename files request is sent from the client to the server\n    before files are actually renamed as long as the rename is triggered from\n    within the client.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWillRenameFilesRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWillRenameFilesRequest:\n    \"\"\"The will rename files request is sent from the client to the server\n    before files are actually renamed as long as the rename is triggered from\n    within the client.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: RenameFilesParams = attrs.field()\n    method: str = \"workspace/willRenameFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWillRenameFilesResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWillRenameFilesResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[WorkspaceEdit, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceWillDeleteFilesRequest:\n    \"\"\"The did delete files notification is sent from the client to the server\n    when files were deleted from within the client.\n    @since 3.16.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWillDeleteFilesRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWillDeleteFilesRequest:\n    \"\"\"The did delete files notification is sent from the client to the server\n    when files were deleted from within the client.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DeleteFilesParams = attrs.field()\n    method: str = \"workspace/willDeleteFiles\"\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceWillDeleteFilesResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceWillDeleteFilesResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[WorkspaceEdit, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentMonikerRequest:\n    \"\"\"A request to get the moniker of a symbol at a given text document\n    position.\n    The request parameter is of type TextDocumentPositionParams. The",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentMonikerRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentMonikerRequest:\n    \"\"\"A request to get the moniker of a symbol at a given text document\n    position.\n    The request parameter is of type TextDocumentPositionParams. The\n    response is of type [Moniker[]](#Moniker[]) or `null`.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: MonikerParams = attrs.field()\n    method: str = \"textDocument/moniker\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentMonikerResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentMonikerResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[Moniker], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentPrepareTypeHierarchyRequest:\n    \"\"\"A request to result a `TypeHierarchyItem` in a document at a given\n    position. Can be used as an input to a subtypes or supertypes type\n    hierarchy.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPrepareTypeHierarchyRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPrepareTypeHierarchyRequest:\n    \"\"\"A request to result a `TypeHierarchyItem` in a document at a given\n    position. Can be used as an input to a subtypes or supertypes type\n    hierarchy.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: TypeHierarchyPrepareParams = attrs.field()\n    method: str = \"textDocument/prepareTypeHierarchy\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPrepareTypeHierarchyResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPrepareTypeHierarchyResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TypeHierarchyItem], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TypeHierarchySupertypesRequest:\n    \"\"\"A request to resolve the supertypes for a given `TypeHierarchyItem`.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchySupertypesRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchySupertypesRequest:\n    \"\"\"A request to resolve the supertypes for a given `TypeHierarchyItem`.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: TypeHierarchySupertypesParams = attrs.field()\n    method: str = \"typeHierarchy/supertypes\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchySupertypesResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchySupertypesResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TypeHierarchyItem], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TypeHierarchySubtypesRequest:\n    \"\"\"A request to resolve the subtypes for a given `TypeHierarchyItem`.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchySubtypesRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchySubtypesRequest:\n    \"\"\"A request to resolve the subtypes for a given `TypeHierarchyItem`.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: TypeHierarchySubtypesParams = attrs.field()\n    method: str = \"typeHierarchy/subtypes\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TypeHierarchySubtypesResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TypeHierarchySubtypesResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TypeHierarchyItem], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentInlineValueRequest:\n    \"\"\"A request to provide inline values in a document. The request's\n    parameter is of type InlineValueParams, the response is of type.\n    [InlineValue[]](#InlineValue[]) or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentInlineValueRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentInlineValueRequest:\n    \"\"\"A request to provide inline values in a document. The request's\n    parameter is of type InlineValueParams, the response is of type.\n    [InlineValue[]](#InlineValue[]) or a Thenable that resolves to such.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: InlineValueParams = attrs.field()\n    method: str = \"textDocument/inlineValue\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentInlineValueResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentInlineValueResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[InlineValue], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceInlineValueRefreshRequest:\n    \"\"\"@since 3.17.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceInlineValueRefreshRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceInlineValueRefreshRequest:\n    \"\"\"@since 3.17.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"workspace/inlineValue/refresh\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceInlineValueRefreshResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceInlineValueRefreshResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceInlineValueRefreshResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentInlayHintRequest:\n    \"\"\"A request to provide inlay hints in a document. The request's parameter\n    is of type InlayHintsParams, the response is of type.\n    [InlayHint[]](#InlayHint[]) or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentInlayHintRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentInlayHintRequest:\n    \"\"\"A request to provide inlay hints in a document. The request's parameter\n    is of type InlayHintsParams, the response is of type.\n    [InlayHint[]](#InlayHint[]) or a Thenable that resolves to such.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: InlayHintParams = attrs.field()\n    method: str = \"textDocument/inlayHint\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentInlayHintResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentInlayHintResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[InlayHint], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass InlayHintResolveRequest:\n    \"\"\"A request to resolve additional properties for an inlay hint. The\n    request's parameter is of type InlayHint, the response is of type InlayHint\n    or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintResolveRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintResolveRequest:\n    \"\"\"A request to resolve additional properties for an inlay hint. The\n    request's parameter is of type InlayHint, the response is of type InlayHint\n    or a Thenable that resolves to such.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: InlayHint = attrs.field()\n    method: str = \"inlayHint/resolve\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlayHintResolveResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InlayHintResolveResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: InlayHint = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceInlayHintRefreshRequest:\n    \"\"\"@since 3.17.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceInlayHintRefreshRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceInlayHintRefreshRequest:\n    \"\"\"@since 3.17.0\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"workspace/inlayHint/refresh\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceInlayHintRefreshResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceInlayHintRefreshResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceInlayHintRefreshResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDiagnosticRequest:\n    \"\"\"The document diagnostic request definition.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDiagnosticRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDiagnosticRequest:\n    \"\"\"The document diagnostic request definition.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentDiagnosticParams = attrs.field()\n    method: str = \"textDocument/diagnostic\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDiagnosticResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDiagnosticResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: DocumentDiagnosticReport = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceDiagnosticRequest:\n    \"\"\"The workspace diagnostic request definition.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticRequest:\n    \"\"\"The workspace diagnostic request definition.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: WorkspaceDiagnosticParams = attrs.field()\n    method: str = \"workspace/diagnostic\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: WorkspaceDiagnosticReport = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceDiagnosticRefreshRequest:\n    \"\"\"The diagnostic refresh request definition.\n    @since 3.17.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticRefreshRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticRefreshRequest:\n    \"\"\"The diagnostic refresh request definition.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"workspace/diagnostic/refresh\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDiagnosticRefreshResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDiagnosticRefreshResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass ClientRegisterCapabilityRequest:\n    \"\"\"The `client/registerCapability` request is sent from the server to the\n    client to register a new capability handler on the client side.\"\"\"\n    id: Union[int, str] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientRegisterCapabilityRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ClientRegisterCapabilityRequest:\n    \"\"\"The `client/registerCapability` request is sent from the server to the\n    client to register a new capability handler on the client side.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: RegistrationParams = attrs.field()\n    method: str = \"client/registerCapability\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientRegisterCapabilityResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ClientRegisterCapabilityResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass ClientUnregisterCapabilityRequest:\n    \"\"\"The `client/unregisterCapability` request is sent from the server to the\n    client to unregister a previously registered capability handler on the\n    client side.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientUnregisterCapabilityRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ClientUnregisterCapabilityRequest:\n    \"\"\"The `client/unregisterCapability` request is sent from the server to the\n    client to unregister a previously registered capability handler on the\n    client side.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: UnregistrationParams = attrs.field()\n    method: str = \"client/unregisterCapability\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ClientUnregisterCapabilityResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ClientUnregisterCapabilityResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass InitializeRequest:\n    \"\"\"The initialize request is sent from the client to the server.\n    It is sent once as the request after starting up the server. The\n    requests parameter is of type InitializeParams the response if of",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeRequest:\n    \"\"\"The initialize request is sent from the client to the server.\n    It is sent once as the request after starting up the server. The\n    requests parameter is of type InitializeParams the response if of\n    type InitializeResult of a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: InitializeParams = attrs.field()\n    method: str = \"initialize\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializeResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializeResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: InitializeResult = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass ShutdownRequest:\n    \"\"\"A shutdown request is sent from the client to the server.\n    It is sent once when the client decides to shutdown the server. The\n    only notification that is sent after a shutdown request is the exit",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShutdownRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShutdownRequest:\n    \"\"\"A shutdown request is sent from the client to the server.\n    It is sent once when the client decides to shutdown the server. The\n    only notification that is sent after a shutdown request is the exit\n    event.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"shutdown\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ShutdownResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ShutdownResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WindowShowMessageRequestRequest:\n    \"\"\"The show message request is sent from the server to the client to show a\n    message and a set of options actions to the user.\"\"\"\n    id: Union[int, str] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowShowMessageRequestRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowShowMessageRequestRequest:\n    \"\"\"The show message request is sent from the server to the client to show a\n    message and a set of options actions to the user.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ShowMessageRequestParams = attrs.field()\n    method: str = \"window/showMessageRequest\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowShowMessageRequestResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowShowMessageRequestResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[MessageActionItem, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentWillSaveWaitUntilRequest:\n    \"\"\"A document will save request is sent from the client to the server\n    before the document is actually saved.\n    The request can return an array of TextEdits which will be applied",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentWillSaveWaitUntilRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentWillSaveWaitUntilRequest:\n    \"\"\"A document will save request is sent from the client to the server\n    before the document is actually saved.\n    The request can return an array of TextEdits which will be applied\n    to the text document before it is saved. Please note that clients\n    might drop results if computing the text edits took too long or if a\n    server constantly fails on this request. This is done to keep the\n    save fast and reliable.\n    \"\"\"\n    id: Union[int, str] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentWillSaveWaitUntilResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentWillSaveWaitUntilResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TextEdit], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentCompletionRequest:\n    \"\"\"Request to request completion at a given text document position. The\n    request's parameter is of type TextDocumentPosition the response is of type\n    CompletionItem[] or CompletionList or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentCompletionRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentCompletionRequest:\n    \"\"\"Request to request completion at a given text document position. The\n    request's parameter is of type TextDocumentPosition the response is of type\n    CompletionItem[] or CompletionList or a Thenable that resolves to such.\n    The request can delay the computation of the\n    [`detail`](#CompletionItem.detail) and\n    [`documentation`](#CompletionItem.documentation) properties to the\n    `completionItem/resolve` request. However, properties that are\n    needed for the initial sorting and filtering, like `sortText`,\n    `filterText`, `insertText`, and `textEdit`, must not be changed",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentCompletionResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentCompletionResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[CompletionItem], CompletionList, None] = attrs.field(\n        default=None\n    )\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CompletionItemResolveRequest:\n    \"\"\"Request to resolve additional information for a given completion",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionItemResolveRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionItemResolveRequest:\n    \"\"\"Request to resolve additional information for a given completion\n    item.The request's parameter is of type CompletionItem the response is of\n    type CompletionItem or a Thenable that resolves to such.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CompletionItem = attrs.field()\n    method: str = \"completionItem/resolve\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CompletionItemResolveResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CompletionItemResolveResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: CompletionItem = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentHoverRequest:\n    \"\"\"Request to request hover information at a given text document position.\n    The request's parameter is of type TextDocumentPosition the response\n    is of type Hover or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentHoverRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentHoverRequest:\n    \"\"\"Request to request hover information at a given text document position.\n    The request's parameter is of type TextDocumentPosition the response\n    is of type Hover or a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: HoverParams = attrs.field()\n    method: str = \"textDocument/hover\"\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentHoverResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentHoverResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[Hover, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSignatureHelpRequest:\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: SignatureHelpParams = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSignatureHelpRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSignatureHelpRequest:\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: SignatureHelpParams = attrs.field()\n    method: str = \"textDocument/signatureHelp\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentSignatureHelpResponse:\n    id: Optional[Union[int, str]] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentSignatureHelpResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentSignatureHelpResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[SignatureHelp, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDefinitionRequest:\n    \"\"\"A request to resolve the definition location of a symbol at a given text\n    document position.\n    The request's parameter is of type [TextDocumentPosition]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDefinitionRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDefinitionRequest:\n    \"\"\"A request to resolve the definition location of a symbol at a given text\n    document position.\n    The request's parameter is of type [TextDocumentPosition]\n    (#TextDocumentPosition) the response is of either type Definition or\n    a typed array of DefinitionLink or a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DefinitionParams = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDefinitionResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDefinitionResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[Definition, List[DefinitionLink], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentReferencesRequest:\n    \"\"\"A request to resolve project-wide references for the symbol denoted by\n    the given text document position.\n    The request's parameter is of type ReferenceParams the response is",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentReferencesRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentReferencesRequest:\n    \"\"\"A request to resolve project-wide references for the symbol denoted by\n    the given text document position.\n    The request's parameter is of type ReferenceParams the response is\n    of type Location[] or a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ReferenceParams = attrs.field()\n    method: str = \"textDocument/references\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentReferencesResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentReferencesResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[Location], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDocumentHighlightRequest:\n    \"\"\"Request to resolve a DocumentHighlight for a given text document\n    position.\n    The request's parameter is of type [TextDocumentPosition]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentHighlightRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentHighlightRequest:\n    \"\"\"Request to resolve a DocumentHighlight for a given text document\n    position.\n    The request's parameter is of type [TextDocumentPosition]\n    (#TextDocumentPosition) the request response is of type\n    [DocumentHighlight[]] (#DocumentHighlight) or a Thenable that\n    resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentHighlightResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentHighlightResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[DocumentHighlight], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDocumentSymbolRequest:\n    \"\"\"A request to list all symbols found in a given text document.\n    The request's parameter is of type TextDocumentIdentifier the\n    response is of type SymbolInformation[] or a Thenable that resolves",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentSymbolRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentSymbolRequest:\n    \"\"\"A request to list all symbols found in a given text document.\n    The request's parameter is of type TextDocumentIdentifier the\n    response is of type SymbolInformation[] or a Thenable that resolves\n    to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentSymbolParams = attrs.field()\n    method: str = \"textDocument/documentSymbol\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentSymbolResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentSymbolResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[SymbolInformation], List[DocumentSymbol], None] = attrs.field(\n        default=None\n    )\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentCodeActionRequest:\n    \"\"\"A request to provide commands for the given text document and range.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentCodeActionRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentCodeActionRequest:\n    \"\"\"A request to provide commands for the given text document and range.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CodeActionParams = attrs.field()\n    method: str = \"textDocument/codeAction\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentCodeActionResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentCodeActionResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentCodeActionResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[Union[Command, CodeAction]], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CodeActionResolveRequest:\n    \"\"\"Request to resolve additional information for a given code action.The\n    request's parameter is of type CodeAction the response is of type\n    CodeAction or a Thenable that resolves to such.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionResolveRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionResolveRequest:\n    \"\"\"Request to resolve additional information for a given code action.The\n    request's parameter is of type CodeAction the response is of type\n    CodeAction or a Thenable that resolves to such.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CodeAction = attrs.field()\n    method: str = \"codeAction/resolve\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeActionResolveResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeActionResolveResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: CodeAction = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceSymbolRequest:\n    \"\"\"A request to list project-wide symbols matching the query string given\n    by the WorkspaceSymbolParams. The response is of type SymbolInformation[]\n    or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolRequest:\n    \"\"\"A request to list project-wide symbols matching the query string given\n    by the WorkspaceSymbolParams. The response is of type SymbolInformation[]\n    or a Thenable that resolves to such.\n    @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients\n     need to advertise support for WorkspaceSymbols via the client capability\n     `workspace.symbol.resolveSupport`.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[SymbolInformation], List[WorkspaceSymbol], None] = attrs.field(\n        default=None\n    )\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceSymbolResolveRequest:\n    \"\"\"A request to resolve the range inside the workspace symbol's location.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolResolveRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolResolveRequest:\n    \"\"\"A request to resolve the range inside the workspace symbol's location.\n    @since 3.17.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: WorkspaceSymbol = attrs.field()\n    method: str = \"workspaceSymbol/resolve\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceSymbolResolveResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceSymbolResolveResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: WorkspaceSymbol = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentCodeLensRequest:\n    \"\"\"A request to provide code lens for the given text document.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentCodeLensRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentCodeLensRequest:\n    \"\"\"A request to provide code lens for the given text document.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CodeLensParams = attrs.field()\n    method: str = \"textDocument/codeLens\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentCodeLensResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentCodeLensResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentCodeLensResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[CodeLens], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CodeLensResolveRequest:\n    \"\"\"A request to resolve a command for a given code lens.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensResolveRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensResolveRequest:\n    \"\"\"A request to resolve a command for a given code lens.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: CodeLens = attrs.field()\n    method: str = \"codeLens/resolve\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CodeLensResolveResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CodeLensResolveResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CodeLensResolveResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: CodeLens = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceCodeLensRefreshRequest:\n    \"\"\"A request to refresh all code actions.\n    @since 3.16.0\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceCodeLensRefreshRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceCodeLensRefreshRequest:\n    \"\"\"A request to refresh all code actions.\n    @since 3.16.0\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = \"workspace/codeLens/refresh\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceCodeLensRefreshResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceCodeLensRefreshResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: None = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDocumentLinkRequest:\n    \"\"\"A request to provide document links.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentLinkRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentLinkRequest:\n    \"\"\"A request to provide document links.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentLinkParams = attrs.field()\n    method: str = \"textDocument/documentLink\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentDocumentLinkResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDocumentLinkResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDocumentLinkResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[DocumentLink], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass DocumentLinkResolveRequest:\n    \"\"\"Request to resolve additional information for a given document link.\n    The request's parameter is of type DocumentLink the response is of\n    type DocumentLink or a Thenable that resolves to such.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkResolveRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLinkResolveRequest:\n    \"\"\"Request to resolve additional information for a given document link.\n    The request's parameter is of type DocumentLink the response is of\n    type DocumentLink or a Thenable that resolves to such.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentLink = attrs.field()\n    method: str = \"documentLink/resolve\"\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentLinkResolveResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class DocumentLinkResolveResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: DocumentLink = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentFormattingRequest:\n    \"\"\"A request to to format a whole document.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFormattingRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFormattingRequest:\n    \"\"\"A request to to format a whole document.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentFormattingParams = attrs.field()\n    method: str = \"textDocument/formatting\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentFormattingResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFormattingResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentFormattingResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TextEdit], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentRangeFormattingRequest:\n    \"\"\"A request to to format a range in a document.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentRangeFormattingRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentRangeFormattingRequest:\n    \"\"\"A request to to format a range in a document.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentRangeFormattingParams = attrs.field()\n    method: str = \"textDocument/rangeFormatting\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentRangeFormattingResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentRangeFormattingResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentRangeFormattingResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TextEdit], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentOnTypeFormattingRequest:\n    \"\"\"A request to format a document on type.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentOnTypeFormattingRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentOnTypeFormattingRequest:\n    \"\"\"A request to format a document on type.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: DocumentOnTypeFormattingParams = attrs.field()\n    method: str = \"textDocument/onTypeFormatting\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentOnTypeFormattingResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentOnTypeFormattingResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentOnTypeFormattingResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[List[TextEdit], None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentRenameRequest:\n    \"\"\"A request to rename a symbol.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentRenameRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentRenameRequest:\n    \"\"\"A request to rename a symbol.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: RenameParams = attrs.field()\n    method: str = \"textDocument/rename\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentRenameResponse:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentRenameResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentRenameResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[WorkspaceEdit, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass TextDocumentPrepareRenameRequest:\n    \"\"\"A request to test and perform the setup necessary for a rename.\n    @since 3.16 - support for default behavior\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPrepareRenameRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPrepareRenameRequest:\n    \"\"\"A request to test and perform the setup necessary for a rename.\n    @since 3.16 - support for default behavior\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: PrepareRenameParams = attrs.field()\n    method: str = \"textDocument/prepareRename\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPrepareRenameResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPrepareRenameResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[PrepareRenameResult, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceExecuteCommandRequest:\n    \"\"\"A request send from the client to the server to execute a command.\n    The request might return a workspace edit which the client will\n    apply to the workspace.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceExecuteCommandRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceExecuteCommandRequest:\n    \"\"\"A request send from the client to the server to execute a command.\n    The request might return a workspace edit which the client will\n    apply to the workspace.\n    \"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ExecuteCommandParams = attrs.field()\n    method: str = \"workspace/executeCommand\"\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceExecuteCommandResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceExecuteCommandResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: Union[LSPAny, None] = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceApplyEditRequest:\n    \"\"\"A request sent from the server to the client to modified certain\n    resources.\"\"\"\n    id: Union[int, str] = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceApplyEditRequest",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceApplyEditRequest:\n    \"\"\"A request sent from the server to the client to modified certain\n    resources.\"\"\"\n    id: Union[int, str] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    params: ApplyWorkspaceEditParams = attrs.field()\n    method: str = \"workspace/applyEdit\"\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceApplyEditResponse",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceApplyEditResponse:\n    id: Optional[Union[int, str]] = attrs.field()\n    \"\"\"The request id.\"\"\"\n    result: ApplyWorkspaceEditResult = attrs.field(default=None)\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass WorkspaceDidChangeWorkspaceFoldersNotification:\n    \"\"\"The `workspace/didChangeWorkspaceFolders` notification is sent from the\n    client to the server when the workspace folder configuration changes.\"\"\"\n    params: DidChangeWorkspaceFoldersParams = attrs.field()",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDidChangeWorkspaceFoldersNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDidChangeWorkspaceFoldersNotification:\n    \"\"\"The `workspace/didChangeWorkspaceFolders` notification is sent from the\n    client to the server when the workspace folder configuration changes.\"\"\"\n    params: DidChangeWorkspaceFoldersParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"workspace/didChangeWorkspaceFolders\"]),\n        default=\"workspace/didChangeWorkspaceFolders\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowWorkDoneProgressCancelNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowWorkDoneProgressCancelNotification:\n    \"\"\"The `window/workDoneProgress/cancel` notification is sent from  the\n    client to the server to cancel a progress initiated on the server side.\"\"\"\n    params: WorkDoneProgressCancelParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"window/workDoneProgress/cancel\"]),\n        default=\"window/workDoneProgress/cancel\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDidCreateFilesNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDidCreateFilesNotification:\n    \"\"\"The did create files notification is sent from the client to the server\n    when files were created from within the client.\n    @since 3.16.0\n    \"\"\"\n    params: CreateFilesParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"workspace/didCreateFiles\"]),\n        default=\"workspace/didCreateFiles\",\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDidRenameFilesNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDidRenameFilesNotification:\n    \"\"\"The did rename files notification is sent from the client to the server\n    when files were renamed from within the client.\n    @since 3.16.0\n    \"\"\"\n    params: RenameFilesParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"workspace/didRenameFiles\"]),\n        default=\"workspace/didRenameFiles\",\n    )",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDidDeleteFilesNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDidDeleteFilesNotification:\n    \"\"\"The will delete files request is sent from the client to the server\n    before files are actually deleted as long as the deletion is triggered from\n    within the client.\n    @since 3.16.0\n    \"\"\"\n    params: DeleteFilesParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"workspace/didDeleteFiles\"]),\n        default=\"workspace/didDeleteFiles\",",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentDidOpenNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentDidOpenNotification:\n    \"\"\"A notification sent when a notebook opens.\n    @since 3.17.0\n    \"\"\"\n    params: DidOpenNotebookDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"notebookDocument/didOpen\"]),\n        default=\"notebookDocument/didOpen\",\n    )\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentDidChangeNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentDidChangeNotification:\n    params: DidChangeNotebookDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"notebookDocument/didChange\"]),\n        default=\"notebookDocument/didChange\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass NotebookDocumentDidSaveNotification:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentDidSaveNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentDidSaveNotification:\n    \"\"\"A notification sent when a notebook document is saved.\n    @since 3.17.0\n    \"\"\"\n    params: DidSaveNotebookDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"notebookDocument/didSave\"]),\n        default=\"notebookDocument/didSave\",\n    )\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentDidCloseNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class NotebookDocumentDidCloseNotification:\n    \"\"\"A notification sent when a notebook closes.\n    @since 3.17.0\n    \"\"\"\n    params: DidCloseNotebookDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"notebookDocument/didClose\"]),\n        default=\"notebookDocument/didClose\",\n    )\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InitializedNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class InitializedNotification:\n    \"\"\"The initialized notification is sent from the client to the server after\n    the client is fully initialized and the server is allowed to send requests\n    from the server to the client.\"\"\"\n    params: InitializedParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"initialized\"]),\n        default=\"initialized\",\n    )\n    \"\"\"The method to be invoked.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ExitNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ExitNotification:\n    \"\"\"The exit event is sent from the client to the server to ask the server\n    to exit its process.\"\"\"\n    params: Optional[None] = attrs.field(default=None)\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"exit\"]),\n        default=\"exit\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDidChangeConfigurationNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDidChangeConfigurationNotification:\n    \"\"\"The configuration change notification is sent from the client to the\n    server when the client's configuration has changed.\n    The notification contains the changed configuration as defined by\n    the language client.\n    \"\"\"\n    params: DidChangeConfigurationParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"workspace/didChangeConfiguration\"]),\n        default=\"workspace/didChangeConfiguration\",",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowShowMessageNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowShowMessageNotification:\n    \"\"\"The show message notification is sent from a server to a client to ask\n    the client to display a particular message in the user interface.\"\"\"\n    params: ShowMessageParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"window/showMessage\"]),\n        default=\"window/showMessage\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WindowLogMessageNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WindowLogMessageNotification:\n    \"\"\"The log message notification is sent from the server to the client to\n    ask the client to log a particular message.\"\"\"\n    params: LogMessageParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"window/logMessage\"]),\n        default=\"window/logMessage\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TelemetryEventNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TelemetryEventNotification:\n    \"\"\"The telemetry event notification is sent from the server to the client\n    to ask the client to log telemetry data.\"\"\"\n    params: LSPAny = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"telemetry/event\"]),\n        default=\"telemetry/event\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDidOpenNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDidOpenNotification:\n    \"\"\"The document open notification is sent from the client to the server to\n    signal newly opened text documents.\n    The document's truth is now managed by the client and the server\n    must not try to read the document's truth using the document's uri.\n    Open in this sense means it is managed by the client. It doesn't\n    necessarily mean that its content is presented in an editor. An open\n    notification must not be sent more than once without a corresponding\n    close notification send before. This means open and close\n    notification must be balanced and the max open count is one.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDidChangeNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDidChangeNotification:\n    \"\"\"The document change notification is sent from the client to the server\n    to signal changes to a text document.\"\"\"\n    params: DidChangeTextDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"textDocument/didChange\"]),\n        default=\"textDocument/didChange\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDidCloseNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDidCloseNotification:\n    \"\"\"The document close notification is sent from the client to the server\n    when the document got closed in the client.\n    The document's truth now exists where the document's uri points to\n    (e.g. if the document's uri is a file uri the truth now exists on\n    disk). As with the open notification the close notification is about\n    managing the document's content. Receiving a close notification\n    doesn't mean that the document was open in an editor before. A close\n    notification requires a previous open notification to be sent.\n    \"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentDidSaveNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentDidSaveNotification:\n    \"\"\"The document save notification is sent from the client to the server\n    when the document got saved in the client.\"\"\"\n    params: DidSaveTextDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"textDocument/didSave\"]),\n        default=\"textDocument/didSave\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentWillSaveNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentWillSaveNotification:\n    \"\"\"A document will save notification is sent from the client to the server\n    before the document is actually saved.\"\"\"\n    params: WillSaveTextDocumentParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"textDocument/willSave\"]),\n        default=\"textDocument/willSave\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDidChangeWatchedFilesNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class WorkspaceDidChangeWatchedFilesNotification:\n    \"\"\"The watched files notification is sent from the client to the server\n    when the client detects changes to file watched by the language client.\"\"\"\n    params: DidChangeWatchedFilesParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"workspace/didChangeWatchedFiles\"]),\n        default=\"workspace/didChangeWatchedFiles\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentPublishDiagnosticsNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class TextDocumentPublishDiagnosticsNotification:\n    \"\"\"Diagnostics notification are sent from the server to the client to\n    signal results of validation runs.\"\"\"\n    params: PublishDiagnosticsParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"textDocument/publishDiagnostics\"]),\n        default=\"textDocument/publishDiagnostics\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SetTraceNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class SetTraceNotification:\n    params: SetTraceParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"$/setTrace\"]),\n        default=\"$/setTrace\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass LogTraceNotification:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LogTraceNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class LogTraceNotification:\n    params: LogTraceParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"$/logTrace\"]),\n        default=\"$/logTrace\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass CancelRequestNotification:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CancelRequestNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class CancelRequestNotification:\n    params: CancelParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"$/cancelRequest\"]),\n        default=\"$/cancelRequest\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@attrs.define\nclass ProgressNotification:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ProgressNotification",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class ProgressNotification:\n    params: ProgressParams = attrs.field()\n    method: str = attrs.field(\n        validator=attrs.validators.in_([\"$/progress\"]),\n        default=\"$/progress\",\n    )\n    \"\"\"The method to be invoked.\"\"\"\n    jsonrpc: str = attrs.field(default=\"2.0\")\n@enum.unique\nclass MessageDirection(enum.Enum):",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MessageDirection",
        "kind": 6,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "class MessageDirection(enum.Enum):\n    Both = \"both\"\n    ClientToServer = \"clientToServer\"\n    ServerToClient = \"serverToClient\"\nCALL_HIERARCHY_INCOMING_CALLS = \"callHierarchy/incomingCalls\"\nCALL_HIERARCHY_OUTGOING_CALLS = \"callHierarchy/outgoingCalls\"\nCANCEL_REQUEST = \"$/cancelRequest\"\nCLIENT_REGISTER_CAPABILITY = \"client/registerCapability\"\nCLIENT_UNREGISTER_CAPABILITY = \"client/unregisterCapability\"\nCODE_ACTION_RESOLVE = \"codeAction/resolve\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "is_keyword_class",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "def is_keyword_class(cls: type) -> bool:\n    \"\"\"Returns true if the class has a property that may be python keyword.\"\"\"\n    return any(cls is c for c in _KEYWORD_CLASSES)\n_SPECIAL_CLASSES = [\n    CallHierarchyIncomingCallsRequest,\n    CallHierarchyIncomingCallsResponse,\n    CallHierarchyOutgoingCallsRequest,\n    CallHierarchyOutgoingCallsResponse,\n    CallHierarchyRegistrationOptions,\n    CancelRequestNotification,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "is_special_class",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "def is_special_class(cls: type) -> bool:\n    \"\"\"Returns true if the class or its properties require special handling.\"\"\"\n    return any(cls is c for c in _SPECIAL_CLASSES)\n_SPECIAL_PROPERTIES = [\n    \"CallHierarchyIncomingCallsRequest.jsonrpc\",\n    \"CallHierarchyIncomingCallsRequest.method\",\n    \"CallHierarchyIncomingCallsResponse.jsonrpc\",\n    \"CallHierarchyIncomingCallsResponse.result\",\n    \"CallHierarchyOutgoingCallsRequest.jsonrpc\",\n    \"CallHierarchyOutgoingCallsRequest.method\",",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "is_special_property",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "def is_special_property(cls: type, property_name: str) -> bool:\n    \"\"\"Returns true if the class or its properties require special handling.\n    Example:\n      Consider RenameRegistrationOptions\n        * document_selector property:\n            When you set `document_selector` to None in python it has to be preserved when\n            serializing it. Since the serialized JSON value `{\"document_selector\": null}`\n            means use the Clients document selector. Omitting it might throw error.\n        * prepare_provider property\n            This property does NOT need special handling, since omitting it or using",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "message_direction",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "def message_direction(method: str) -> str:\n    \"\"\"Returns message direction clientToServer, serverToClient or both.\"\"\"\n    return _MESSAGE_DIRECTION[method]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "__lsp_version__",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "__lsp_version__ = \"3.17.0\"\n@enum.unique\nclass SemanticTokenTypes(str, enum.Enum):\n    \"\"\"A set of predefined token types. This set is not fixed an clients can\n    specify additional token types via the corresponding client capabilities.\n    @since 3.16.0\n    \"\"\"\n    # Since: 3.16.0\n    Namespace = \"namespace\"\n    Type = \"type\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Definition",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "Definition = Union[\"Location\", List[\"Location\"]]\n\"\"\"The definition of a symbol represented as one or many locations. For most\nprogramming languages there is only one location at which a symbol is defined.\nServers should prefer returning `DefinitionLink` over `Definition` if\nsupported by the client.\n\"\"\"\nDefinitionLink = Union[\"LocationLink\", \"LocationLink\"]\n\"\"\"Information about where a symbol is defined.\nProvides additional metadata over normal location definitions, including\nthe range of the defining symbol",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DefinitionLink",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "DefinitionLink = Union[\"LocationLink\", \"LocationLink\"]\n\"\"\"Information about where a symbol is defined.\nProvides additional metadata over normal location definitions, including\nthe range of the defining symbol\n\"\"\"\nLSPArray = List[\"LSPAny\"]\n\"\"\"LSP arrays.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LSPArray",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "LSPArray = List[\"LSPAny\"]\n\"\"\"LSP arrays.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0\nLSPAny = Union[\"LSPObject\", LSPArray, str, int, int, float, bool, None]\n\"\"\"The LSP any type. Please note that strictly speaking a property with the\nvalue `undefined` can't be converted into JSON preserving the property name.\nHowever for convenience it is allowed and assumed that all these properties are\noptional as well.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LSPAny",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "LSPAny = Union[\"LSPObject\", LSPArray, str, int, int, float, bool, None]\n\"\"\"The LSP any type. Please note that strictly speaking a property with the\nvalue `undefined` can't be converted into JSON preserving the property name.\nHowever for convenience it is allowed and assumed that all these properties are\noptional as well.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0\nDeclaration = Union[\"Location\", List[\"Location\"]]\n\"\"\"The declaration of a symbol representation as one or many locations.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Declaration",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "Declaration = Union[\"Location\", List[\"Location\"]]\n\"\"\"The declaration of a symbol representation as one or many locations.\"\"\"\nDeclarationLink = Union[\"LocationLink\", \"LocationLink\"]\n\"\"\"Information about where a symbol is declared.\nProvides additional metadata over normal location declarations, including the range of\nthe declaring symbol.\nServers should prefer returning `DeclarationLink` over `Declaration` if supported\nby the client.\n\"\"\"\nInlineValue = Union[",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DeclarationLink",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "DeclarationLink = Union[\"LocationLink\", \"LocationLink\"]\n\"\"\"Information about where a symbol is declared.\nProvides additional metadata over normal location declarations, including the range of\nthe declaring symbol.\nServers should prefer returning `DeclarationLink` over `Declaration` if supported\nby the client.\n\"\"\"\nInlineValue = Union[\n    \"InlineValueText\", \"InlineValueVariableLookup\", \"InlineValueEvaluatableExpression\"\n]",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "InlineValue",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "InlineValue = Union[\n    \"InlineValueText\", \"InlineValueVariableLookup\", \"InlineValueEvaluatableExpression\"\n]\n\"\"\"Inline value information can be provided by different means:\n- directly as a text value (class InlineValueText).\n- as a name to use for a variable lookup (class InlineValueVariableLookup)\n- as an evaluatable expression (class InlineValueEvaluatableExpression)\nThe InlineValue types combines all inline value types into one type.\n@since 3.17.0\n\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentDiagnosticReport",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "DocumentDiagnosticReport = Union[\n    \"RelatedFullDocumentDiagnosticReport\", \"RelatedUnchangedDocumentDiagnosticReport\"\n]\n\"\"\"The result of a document diagnostic pull request. A report can either be a\nfull report containing all diagnostics for the requested document or an\nunchanged report indicating that nothing has changed in terms of diagnostics in\ncomparison to the last pull request.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PrepareRenameResult",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "PrepareRenameResult = Union[\n    \"Range\", \"PrepareRenameResult_Type1\", \"PrepareRenameResult_Type2\"\n]\nProgressToken = Union[int, str]\nDocumentSelector = List[\"DocumentFilter\"]\n\"\"\"A document selector is the combination of one or many document filters.\n@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**/tsconfig.json' }]`;\nThe use of a string as a document filter is deprecated @since 3.16.0.\n\"\"\"\n# Since: 3.16.0.",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ProgressToken",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "ProgressToken = Union[int, str]\nDocumentSelector = List[\"DocumentFilter\"]\n\"\"\"A document selector is the combination of one or many document filters.\n@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**/tsconfig.json' }]`;\nThe use of a string as a document filter is deprecated @since 3.16.0.\n\"\"\"\n# Since: 3.16.0.\nChangeAnnotationIdentifier = str\n\"\"\"An identifier to refer to a change annotation stored with a workspace\nedit.\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentSelector",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "DocumentSelector = List[\"DocumentFilter\"]\n\"\"\"A document selector is the combination of one or many document filters.\n@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**/tsconfig.json' }]`;\nThe use of a string as a document filter is deprecated @since 3.16.0.\n\"\"\"\n# Since: 3.16.0.\nChangeAnnotationIdentifier = str\n\"\"\"An identifier to refer to a change annotation stored with a workspace\nedit.\"\"\"\nWorkspaceDocumentDiagnosticReport = Union[",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "ChangeAnnotationIdentifier",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "ChangeAnnotationIdentifier = str\n\"\"\"An identifier to refer to a change annotation stored with a workspace\nedit.\"\"\"\nWorkspaceDocumentDiagnosticReport = Union[\n    \"WorkspaceFullDocumentDiagnosticReport\",\n    \"WorkspaceUnchangedDocumentDiagnosticReport\",\n]\n\"\"\"A workspace diagnostic document report.\n@since 3.17.0\n\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WorkspaceDocumentDiagnosticReport",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WorkspaceDocumentDiagnosticReport = Union[\n    \"WorkspaceFullDocumentDiagnosticReport\",\n    \"WorkspaceUnchangedDocumentDiagnosticReport\",\n]\n\"\"\"A workspace diagnostic document report.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0\n@attrs.define\nclass TextDocumentContentChangeEvent_Type1:",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentContentChangeEvent",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TextDocumentContentChangeEvent = Union[\n    \"TextDocumentContentChangeEvent_Type1\", \"TextDocumentContentChangeEvent_Type2\"\n]\n\"\"\"An event describing a change to a text document.\nIf only a text is provided it is considered to be the full content of\nthe document.\n\"\"\"\n@attrs.define\nclass MarkedString_Type1:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MarkedString",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "MarkedString = Union[str, \"MarkedString_Type1\"]\n\"\"\"MarkedString can be used to render human readable text. It is either a\nmarkdown string or a code-block that provides a language and a code snippet.\nThe language identifier is semantically equal to the optional language\nidentifier in fenced code blocks in GitHub issues. See\nhttps://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-\nhighlighting.\nThe pair of a language and a value is an equivalent to markdown:\n```${language}\n${value}",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DocumentFilter",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "DocumentFilter = Union[\"TextDocumentFilter\", \"NotebookCellTextDocumentFilter\"]\n\"\"\"A document filter describes a top level text document or a notebook cell\ndocument.\n@since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.\n\"\"\"\n# Since: 3.17.0 - proposed support for NotebookCellTextDocumentFilter.\nGlobPattern = Union[\"Pattern\", \"RelativePattern\"]\n\"\"\"The glob pattern. Either a string pattern or a relative pattern.\n@since 3.17.0\n\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "GlobPattern",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "GlobPattern = Union[\"Pattern\", \"RelativePattern\"]\n\"\"\"The glob pattern. Either a string pattern or a relative pattern.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0\n@attrs.define\nclass TextDocumentFilter_Type1:\n    language: str = attrs.field(validator=attrs.validators.instance_of(str))\n    \"\"\"A language id, like `typescript`.\"\"\"\n    scheme: Optional[str] = attrs.field(",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TextDocumentFilter",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TextDocumentFilter = Union[\n    \"TextDocumentFilter_Type1\", \"TextDocumentFilter_Type2\", \"TextDocumentFilter_Type3\"\n]\n\"\"\"A document filter denotes a document by different properties like the\nlanguage, the scheme of its resource, or a glob-pattern that is applied to the\npath.\nGlob patterns can have the following syntax:\n- `*` to match one or more characters in a path segment\n- `?` to match on one character in a path segment\n- `**` to match any number of path segments, including none",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NotebookDocumentFilter",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "NotebookDocumentFilter = Union[\n    \"NotebookDocumentFilter_Type1\",\n    \"NotebookDocumentFilter_Type2\",\n    \"NotebookDocumentFilter_Type3\",\n]\n\"\"\"A notebook document filter denotes a notebook document by different\nproperties. The properties will be match against the notebook's URI (same as\nwith documents)\n@since 3.17.0\n\"\"\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "Pattern = str\n\"\"\"The glob pattern to watch relative to the base path. Glob patterns can have\nthe following syntax:\n- `*` to match one or more characters in a path segment\n- `?` to match on one character in a path segment\n- `**` to match any number of path segments, including none\n- `{}` to group conditions (e.g. `**/*.{ts,js}` matches all TypeScript and JavaScript files)\n- `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n- `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n@since 3.17.0",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LSPObject",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "LSPObject = object\n\"\"\"LSP object definition.\n@since 3.17.0\n\"\"\"\n# Since: 3.17.0\n@attrs.define\nclass NotebookCell:\n    \"\"\"A notebook cell.\n    A cell's document URI must be unique across ALL notebook\n    cells and can therefore be used to uniquely identify a",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CALL_HIERARCHY_INCOMING_CALLS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CALL_HIERARCHY_INCOMING_CALLS = \"callHierarchy/incomingCalls\"\nCALL_HIERARCHY_OUTGOING_CALLS = \"callHierarchy/outgoingCalls\"\nCANCEL_REQUEST = \"$/cancelRequest\"\nCLIENT_REGISTER_CAPABILITY = \"client/registerCapability\"\nCLIENT_UNREGISTER_CAPABILITY = \"client/unregisterCapability\"\nCODE_ACTION_RESOLVE = \"codeAction/resolve\"\nCODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CALL_HIERARCHY_OUTGOING_CALLS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CALL_HIERARCHY_OUTGOING_CALLS = \"callHierarchy/outgoingCalls\"\nCANCEL_REQUEST = \"$/cancelRequest\"\nCLIENT_REGISTER_CAPABILITY = \"client/registerCapability\"\nCLIENT_UNREGISTER_CAPABILITY = \"client/unregisterCapability\"\nCODE_ACTION_RESOLVE = \"codeAction/resolve\"\nCODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CANCEL_REQUEST",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CANCEL_REQUEST = \"$/cancelRequest\"\nCLIENT_REGISTER_CAPABILITY = \"client/registerCapability\"\nCLIENT_UNREGISTER_CAPABILITY = \"client/unregisterCapability\"\nCODE_ACTION_RESOLVE = \"codeAction/resolve\"\nCODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CLIENT_REGISTER_CAPABILITY",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CLIENT_REGISTER_CAPABILITY = \"client/registerCapability\"\nCLIENT_UNREGISTER_CAPABILITY = \"client/unregisterCapability\"\nCODE_ACTION_RESOLVE = \"codeAction/resolve\"\nCODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CLIENT_UNREGISTER_CAPABILITY",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CLIENT_UNREGISTER_CAPABILITY = \"client/unregisterCapability\"\nCODE_ACTION_RESOLVE = \"codeAction/resolve\"\nCODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CODE_ACTION_RESOLVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CODE_ACTION_RESOLVE = \"codeAction/resolve\"\nCODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "CODE_LENS_RESOLVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "CODE_LENS_RESOLVE = \"codeLens/resolve\"\nCOMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "COMPLETION_ITEM_RESOLVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "COMPLETION_ITEM_RESOLVE = \"completionItem/resolve\"\nDOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "DOCUMENT_LINK_RESOLVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "DOCUMENT_LINK_RESOLVE = \"documentLink/resolve\"\nEXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "EXIT",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "EXIT = \"exit\"\nINITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "INITIALIZE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "INITIALIZE = \"initialize\"\nINITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "INITIALIZED",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "INITIALIZED = \"initialized\"\nINLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "INLAY_HINT_RESOLVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "INLAY_HINT_RESOLVE = \"inlayHint/resolve\"\nLOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "LOG_TRACE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "LOG_TRACE = \"$/logTrace\"\nNOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NOTEBOOK_DOCUMENT_DID_CHANGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "NOTEBOOK_DOCUMENT_DID_CHANGE = \"notebookDocument/didChange\"\nNOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NOTEBOOK_DOCUMENT_DID_CLOSE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "NOTEBOOK_DOCUMENT_DID_CLOSE = \"notebookDocument/didClose\"\nNOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NOTEBOOK_DOCUMENT_DID_OPEN",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "NOTEBOOK_DOCUMENT_DID_OPEN = \"notebookDocument/didOpen\"\nNOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NOTEBOOK_DOCUMENT_DID_SAVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "NOTEBOOK_DOCUMENT_DID_SAVE = \"notebookDocument/didSave\"\nPROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "PROGRESS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "PROGRESS = \"$/progress\"\nSET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SET_TRACE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "SET_TRACE = \"$/setTrace\"\nSHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "SHUTDOWN",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "SHUTDOWN = \"shutdown\"\nTELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TELEMETRY_EVENT",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TELEMETRY_EVENT = \"telemetry/event\"\nTEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_CODE_ACTION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_CODE_ACTION = \"textDocument/codeAction\"\nTEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_CODE_LENS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_CODE_LENS = \"textDocument/codeLens\"\nTEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_COLOR_PRESENTATION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_COLOR_PRESENTATION = \"textDocument/colorPresentation\"\nTEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_COMPLETION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_COMPLETION = \"textDocument/completion\"\nTEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DECLARATION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DECLARATION = \"textDocument/declaration\"\nTEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DEFINITION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DEFINITION = \"textDocument/definition\"\nTEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DIAGNOSTIC",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DIAGNOSTIC = \"textDocument/diagnostic\"\nTEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_CHANGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DID_CHANGE = \"textDocument/didChange\"\nTEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_CLOSE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DID_CLOSE = \"textDocument/didClose\"\nTEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_OPEN",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DID_OPEN = \"textDocument/didOpen\"\nTEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DID_SAVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DID_SAVE = \"textDocument/didSave\"\nTEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_COLOR",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DOCUMENT_COLOR = \"textDocument/documentColor\"\nTEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_HIGHLIGHT",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DOCUMENT_HIGHLIGHT = \"textDocument/documentHighlight\"\nTEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_LINK",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DOCUMENT_LINK = \"textDocument/documentLink\"\nTEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_DOCUMENT_SYMBOL",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_DOCUMENT_SYMBOL = \"textDocument/documentSymbol\"\nTEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_FOLDING_RANGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_FOLDING_RANGE = \"textDocument/foldingRange\"\nTEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_FORMATTING",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_FORMATTING = \"textDocument/formatting\"\nTEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_HOVER",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_HOVER = \"textDocument/hover\"\nTEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_IMPLEMENTATION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_IMPLEMENTATION = \"textDocument/implementation\"\nTEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_INLAY_HINT",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_INLAY_HINT = \"textDocument/inlayHint\"\nTEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_INLINE_VALUE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_INLINE_VALUE = \"textDocument/inlineValue\"\nTEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_LINKED_EDITING_RANGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_LINKED_EDITING_RANGE = \"textDocument/linkedEditingRange\"\nTEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_MONIKER",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_MONIKER = \"textDocument/moniker\"\nTEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_ON_TYPE_FORMATTING",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_ON_TYPE_FORMATTING = \"textDocument/onTypeFormatting\"\nTEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_PREPARE_CALL_HIERARCHY",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_PREPARE_CALL_HIERARCHY = \"textDocument/prepareCallHierarchy\"\nTEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_PREPARE_RENAME",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_PREPARE_RENAME = \"textDocument/prepareRename\"\nTEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_PREPARE_TYPE_HIERARCHY = \"textDocument/prepareTypeHierarchy\"\nTEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_PUBLISH_DIAGNOSTICS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nTEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_RANGE_FORMATTING",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_RANGE_FORMATTING = \"textDocument/rangeFormatting\"\nTEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_REFERENCES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_REFERENCES = \"textDocument/references\"\nTEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_RENAME",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_RENAME = \"textDocument/rename\"\nTEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SELECTION_RANGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_SELECTION_RANGE = \"textDocument/selectionRange\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SEMANTIC_TOKENS_FULL",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_SEMANTIC_TOKENS_FULL = \"textDocument/semanticTokens/full\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_SEMANTIC_TOKENS_FULL_DELTA = \"textDocument/semanticTokens/full/delta\"\nTEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_SEMANTIC_TOKENS_RANGE = \"textDocument/semanticTokens/range\"\nTEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_SIGNATURE_HELP",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_SIGNATURE_HELP = \"textDocument/signatureHelp\"\nTEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_TYPE_DEFINITION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_TYPE_DEFINITION = \"textDocument/typeDefinition\"\nTEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_WILL_SAVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_WILL_SAVE = \"textDocument/willSave\"\nTEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TEXT_DOCUMENT_WILL_SAVE_WAIT_UNTIL = \"textDocument/willSaveWaitUntil\"\nTYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TYPE_HIERARCHY_SUBTYPES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TYPE_HIERARCHY_SUBTYPES = \"typeHierarchy/subtypes\"\nTYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "TYPE_HIERARCHY_SUPERTYPES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "TYPE_HIERARCHY_SUPERTYPES = \"typeHierarchy/supertypes\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_LOG_MESSAGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_SHOW_DOCUMENT",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WINDOW_SHOW_DOCUMENT = \"window/showDocument\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_SHOW_MESSAGE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WINDOW_SHOW_MESSAGE = \"window/showMessage\"\nWINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_SHOW_MESSAGE_REQUEST",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WINDOW_SHOW_MESSAGE_REQUEST = \"window/showMessageRequest\"\nWINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_WORK_DONE_PROGRESS_CANCEL",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WINDOW_WORK_DONE_PROGRESS_CANCEL = \"window/workDoneProgress/cancel\"\nWINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WINDOW_WORK_DONE_PROGRESS_CREATE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WINDOW_WORK_DONE_PROGRESS_CREATE = \"window/workDoneProgress/create\"\nWORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_APPLY_EDIT",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_APPLY_EDIT = \"workspace/applyEdit\"\nWORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_CODE_LENS_REFRESH",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_CODE_LENS_REFRESH = \"workspace/codeLens/refresh\"\nWORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_CONFIGURATION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_CONFIGURATION = \"workspace/configuration\"\nWORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DIAGNOSTIC",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DIAGNOSTIC = \"workspace/diagnostic\"\nWORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DIAGNOSTIC_REFRESH",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DIAGNOSTIC_REFRESH = \"workspace/diagnostic/refresh\"\nWORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_CHANGE_CONFIGURATION",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DID_CHANGE_CONFIGURATION = \"workspace/didChangeConfiguration\"\nWORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_CHANGE_WATCHED_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DID_CHANGE_WATCHED_FILES = \"workspace/didChangeWatchedFiles\"\nWORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DID_CHANGE_WORKSPACE_FOLDERS = \"workspace/didChangeWorkspaceFolders\"\nWORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_CREATE_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DID_CREATE_FILES = \"workspace/didCreateFiles\"\nWORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_DELETE_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DID_DELETE_FILES = \"workspace/didDeleteFiles\"\nWORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_DID_RENAME_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_DID_RENAME_FILES = \"workspace/didRenameFiles\"\nWORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_EXECUTE_COMMAND",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_EXECUTE_COMMAND = \"workspace/executeCommand\"\nWORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_INLAY_HINT_REFRESH",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_INLAY_HINT_REFRESH = \"workspace/inlayHint/refresh\"\nWORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_INLINE_VALUE_REFRESH",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_INLINE_VALUE_REFRESH = \"workspace/inlineValue/refresh\"\nWORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_SEMANTIC_TOKENS_REFRESH",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_SEMANTIC_TOKENS_REFRESH = \"workspace/semanticTokens/refresh\"\nWORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_SYMBOL",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_SYMBOL = \"workspace/symbol\"\nWORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_SYMBOL_RESOLVE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_SYMBOL_RESOLVE = \"workspaceSymbol/resolve\"\nWORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,\n        CallHierarchyIncomingCallsResponse,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WILL_CREATE_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_WILL_CREATE_FILES = \"workspace/willCreateFiles\"\nWORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,\n        CallHierarchyIncomingCallsResponse,\n        CallHierarchyIncomingCallsParams,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WILL_DELETE_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_WILL_DELETE_FILES = \"workspace/willDeleteFiles\"\nWORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,\n        CallHierarchyIncomingCallsResponse,\n        CallHierarchyIncomingCallsParams,\n        None,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WILL_RENAME_FILES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_WILL_RENAME_FILES = \"workspace/willRenameFiles\"\nWORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,\n        CallHierarchyIncomingCallsResponse,\n        CallHierarchyIncomingCallsParams,\n        None,\n    ),",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_WORKSPACE_FOLDERS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "WORKSPACE_WORKSPACE_FOLDERS = \"workspace/workspaceFolders\"\nMETHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,\n        CallHierarchyIncomingCallsResponse,\n        CallHierarchyIncomingCallsParams,\n        None,\n    ),\n    CALL_HIERARCHY_OUTGOING_CALLS: (",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "METHOD_TO_TYPES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "METHOD_TO_TYPES = {\n    # Requests\n    CALL_HIERARCHY_INCOMING_CALLS: (\n        CallHierarchyIncomingCallsRequest,\n        CallHierarchyIncomingCallsResponse,\n        CallHierarchyIncomingCallsParams,\n        None,\n    ),\n    CALL_HIERARCHY_OUTGOING_CALLS: (\n        CallHierarchyOutgoingCallsRequest,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "REQUESTS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "REQUESTS = Union[\n    CallHierarchyIncomingCallsRequest,\n    CallHierarchyOutgoingCallsRequest,\n    ClientRegisterCapabilityRequest,\n    ClientUnregisterCapabilityRequest,\n    CodeActionResolveRequest,\n    CodeLensResolveRequest,\n    CompletionItemResolveRequest,\n    DocumentLinkResolveRequest,\n    InitializeRequest,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "RESPONSES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "RESPONSES = Union[\n    CallHierarchyIncomingCallsResponse,\n    CallHierarchyOutgoingCallsResponse,\n    ClientRegisterCapabilityResponse,\n    ClientUnregisterCapabilityResponse,\n    CodeActionResolveResponse,\n    CodeLensResolveResponse,\n    CompletionItemResolveResponse,\n    DocumentLinkResolveResponse,\n    InitializeResponse,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "NOTIFICATIONS",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "NOTIFICATIONS = Union[\n    CancelRequestNotification,\n    ExitNotification,\n    InitializedNotification,\n    LogTraceNotification,\n    NotebookDocumentDidChangeNotification,\n    NotebookDocumentDidCloseNotification,\n    NotebookDocumentDidOpenNotification,\n    NotebookDocumentDidSaveNotification,\n    ProgressNotification,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "MESSAGE_TYPES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "MESSAGE_TYPES = Union[REQUESTS, RESPONSES, NOTIFICATIONS, ResponseErrorMessage]\n_KEYWORD_CLASSES = [CallHierarchyIncomingCall]\ndef is_keyword_class(cls: type) -> bool:\n    \"\"\"Returns true if the class has a property that may be python keyword.\"\"\"\n    return any(cls is c for c in _KEYWORD_CLASSES)\n_SPECIAL_CLASSES = [\n    CallHierarchyIncomingCallsRequest,\n    CallHierarchyIncomingCallsResponse,\n    CallHierarchyOutgoingCallsRequest,\n    CallHierarchyOutgoingCallsResponse,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "_KEYWORD_CLASSES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "_KEYWORD_CLASSES = [CallHierarchyIncomingCall]\ndef is_keyword_class(cls: type) -> bool:\n    \"\"\"Returns true if the class has a property that may be python keyword.\"\"\"\n    return any(cls is c for c in _KEYWORD_CLASSES)\n_SPECIAL_CLASSES = [\n    CallHierarchyIncomingCallsRequest,\n    CallHierarchyIncomingCallsResponse,\n    CallHierarchyOutgoingCallsRequest,\n    CallHierarchyOutgoingCallsResponse,\n    CallHierarchyRegistrationOptions,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "_SPECIAL_CLASSES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "_SPECIAL_CLASSES = [\n    CallHierarchyIncomingCallsRequest,\n    CallHierarchyIncomingCallsResponse,\n    CallHierarchyOutgoingCallsRequest,\n    CallHierarchyOutgoingCallsResponse,\n    CallHierarchyRegistrationOptions,\n    CancelRequestNotification,\n    ClientRegisterCapabilityRequest,\n    ClientRegisterCapabilityResponse,\n    ClientUnregisterCapabilityRequest,",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "_SPECIAL_PROPERTIES",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.types",
        "description": "bundled.libs.lsprotocol.types",
        "peekOfCode": "_SPECIAL_PROPERTIES = [\n    \"CallHierarchyIncomingCallsRequest.jsonrpc\",\n    \"CallHierarchyIncomingCallsRequest.method\",\n    \"CallHierarchyIncomingCallsResponse.jsonrpc\",\n    \"CallHierarchyIncomingCallsResponse.result\",\n    \"CallHierarchyOutgoingCallsRequest.jsonrpc\",\n    \"CallHierarchyOutgoingCallsRequest.method\",\n    \"CallHierarchyOutgoingCallsResponse.jsonrpc\",\n    \"CallHierarchyOutgoingCallsResponse.result\",\n    \"CallHierarchyRegistrationOptions.document_selector\",",
        "detail": "bundled.libs.lsprotocol.types",
        "documentation": {}
    },
    {
        "label": "integer_validator",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.validators",
        "description": "bundled.libs.lsprotocol.validators",
        "peekOfCode": "def integer_validator(\n    instance: Any,\n    attribute: \"attrs.Attribute[int]\",\n    value: Any,\n) -> bool:\n    \"\"\"Validates that integer value belongs in the range expected by LSP.\"\"\"\n    if not isinstance(value, int) or not (\n        INTEGER_MIN_VALUE <= value <= INTEGER_MAX_VALUE\n    ):\n        name = attribute.name if hasattr(attribute, \"name\") else str(attribute)",
        "detail": "bundled.libs.lsprotocol.validators",
        "documentation": {}
    },
    {
        "label": "uinteger_validator",
        "kind": 2,
        "importPath": "bundled.libs.lsprotocol.validators",
        "description": "bundled.libs.lsprotocol.validators",
        "peekOfCode": "def uinteger_validator(\n    instance: Any,\n    attribute: \"attrs.Attribute[int]\",\n    value: Any,\n) -> bool:\n    \"\"\"Validates that unsigned integer value belongs in the range expected by\n    LSP.\"\"\"\n    if not isinstance(value, int) or not (\n        UINTEGER_MIN_VALUE <= value <= UINTEGER_MAX_VALUE\n    ):",
        "detail": "bundled.libs.lsprotocol.validators",
        "documentation": {}
    },
    {
        "label": "INTEGER_MIN_VALUE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.validators",
        "description": "bundled.libs.lsprotocol.validators",
        "peekOfCode": "INTEGER_MIN_VALUE = -(2**31)\nINTEGER_MAX_VALUE = 2**31 - 1\ndef integer_validator(\n    instance: Any,\n    attribute: \"attrs.Attribute[int]\",\n    value: Any,\n) -> bool:\n    \"\"\"Validates that integer value belongs in the range expected by LSP.\"\"\"\n    if not isinstance(value, int) or not (\n        INTEGER_MIN_VALUE <= value <= INTEGER_MAX_VALUE",
        "detail": "bundled.libs.lsprotocol.validators",
        "documentation": {}
    },
    {
        "label": "INTEGER_MAX_VALUE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.validators",
        "description": "bundled.libs.lsprotocol.validators",
        "peekOfCode": "INTEGER_MAX_VALUE = 2**31 - 1\ndef integer_validator(\n    instance: Any,\n    attribute: \"attrs.Attribute[int]\",\n    value: Any,\n) -> bool:\n    \"\"\"Validates that integer value belongs in the range expected by LSP.\"\"\"\n    if not isinstance(value, int) or not (\n        INTEGER_MIN_VALUE <= value <= INTEGER_MAX_VALUE\n    ):",
        "detail": "bundled.libs.lsprotocol.validators",
        "documentation": {}
    },
    {
        "label": "UINTEGER_MIN_VALUE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.validators",
        "description": "bundled.libs.lsprotocol.validators",
        "peekOfCode": "UINTEGER_MIN_VALUE = 0\nUINTEGER_MAX_VALUE = 2**31 - 1\ndef uinteger_validator(\n    instance: Any,\n    attribute: \"attrs.Attribute[int]\",\n    value: Any,\n) -> bool:\n    \"\"\"Validates that unsigned integer value belongs in the range expected by\n    LSP.\"\"\"\n    if not isinstance(value, int) or not (",
        "detail": "bundled.libs.lsprotocol.validators",
        "documentation": {}
    },
    {
        "label": "UINTEGER_MAX_VALUE",
        "kind": 5,
        "importPath": "bundled.libs.lsprotocol.validators",
        "description": "bundled.libs.lsprotocol.validators",
        "peekOfCode": "UINTEGER_MAX_VALUE = 2**31 - 1\ndef uinteger_validator(\n    instance: Any,\n    attribute: \"attrs.Attribute[int]\",\n    value: Any,\n) -> bool:\n    \"\"\"Validates that unsigned integer value belongs in the range expected by\n    LSP.\"\"\"\n    if not isinstance(value, int) or not (\n        UINTEGER_MIN_VALUE <= value <= UINTEGER_MAX_VALUE",
        "detail": "bundled.libs.lsprotocol.validators",
        "documentation": {}
    },
    {
        "label": "ELFInvalid",
        "kind": 6,
        "importPath": "bundled.libs.packaging._elffile",
        "description": "bundled.libs.packaging._elffile",
        "peekOfCode": "class ELFInvalid(ValueError):\n    pass\nclass EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\nclass EMachine(enum.IntEnum):\n    I386 = 3",
        "detail": "bundled.libs.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "EIClass",
        "kind": 6,
        "importPath": "bundled.libs.packaging._elffile",
        "description": "bundled.libs.packaging._elffile",
        "peekOfCode": "class EIClass(enum.IntEnum):\n    C32 = 1\n    C64 = 2\nclass EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40",
        "detail": "bundled.libs.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "EIData",
        "kind": 6,
        "importPath": "bundled.libs.packaging._elffile",
        "description": "bundled.libs.packaging._elffile",
        "peekOfCode": "class EIData(enum.IntEnum):\n    Lsb = 1\n    Msb = 2\nclass EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\nclass ELFFile:",
        "detail": "bundled.libs.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "EMachine",
        "kind": 6,
        "importPath": "bundled.libs.packaging._elffile",
        "description": "bundled.libs.packaging._elffile",
        "peekOfCode": "class EMachine(enum.IntEnum):\n    I386 = 3\n    S390 = 22\n    Arm = 40\n    X8664 = 62\n    AArc64 = 183\nclass ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"",
        "detail": "bundled.libs.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "ELFFile",
        "kind": 6,
        "importPath": "bundled.libs.packaging._elffile",
        "description": "bundled.libs.packaging._elffile",
        "peekOfCode": "class ELFFile:\n    \"\"\"\n    Representation of an ELF executable.\n    \"\"\"\n    def __init__(self, f: IO[bytes]) -> None:\n        self._f = f\n        try:\n            ident = self._read(\"16B\")\n        except struct.error:\n            raise ELFInvalid(\"unable to parse identification\")",
        "detail": "bundled.libs.packaging._elffile",
        "documentation": {}
    },
    {
        "label": "_GLibCVersion",
        "kind": 6,
        "importPath": "bundled.libs.packaging._manylinux",
        "description": "bundled.libs.packaging._manylinux",
        "peekOfCode": "class _GLibCVersion(NamedTuple):\n    major: int\n    minor: int\ndef _glibc_version_string_confstr() -> Optional[str]:\n    \"\"\"\n    Primary implementation of glibc_version_string using os.confstr.\n    \"\"\"\n    # os.confstr is quite a bit faster than ctypes.DLL. It's also less likely\n    # to be broken or missing. This strategy is used in the standard library\n    # platform module.",
        "detail": "bundled.libs.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "platform_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging._manylinux",
        "description": "bundled.libs.packaging._manylinux",
        "peekOfCode": "def platform_tags(linux: str, arch: str) -> Iterator[str]:\n    if not _have_compatible_abi(sys.executable, arch):\n        return\n    # Oldest glibc to be supported regardless of architecture is (2, 17).\n    too_old_glibc2 = _GLibCVersion(2, 16)\n    if arch in {\"x86_64\", \"i686\"}:\n        # On x86/i686 also oldest glibc to be supported is (2, 5).\n        too_old_glibc2 = _GLibCVersion(2, 4)\n    current_glibc = _GLibCVersion(*_get_glibc_version())\n    glibc_max_list = [current_glibc]",
        "detail": "bundled.libs.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "EF_ARM_ABIMASK",
        "kind": 5,
        "importPath": "bundled.libs.packaging._manylinux",
        "description": "bundled.libs.packaging._manylinux",
        "peekOfCode": "EF_ARM_ABIMASK = 0xFF000000\nEF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None",
        "detail": "bundled.libs.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "EF_ARM_ABI_VER5",
        "kind": 5,
        "importPath": "bundled.libs.packaging._manylinux",
        "description": "bundled.libs.packaging._manylinux",
        "peekOfCode": "EF_ARM_ABI_VER5 = 0x05000000\nEF_ARM_ABI_FLOAT_HARD = 0x00000400\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\ndef _is_linux_armhf(executable: str) -> bool:",
        "detail": "bundled.libs.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "EF_ARM_ABI_FLOAT_HARD",
        "kind": 5,
        "importPath": "bundled.libs.packaging._manylinux",
        "description": "bundled.libs.packaging._manylinux",
        "peekOfCode": "EF_ARM_ABI_FLOAT_HARD = 0x00000400\n@contextlib.contextmanager\ndef _parse_elf(path: str) -> Generator[Optional[ELFFile], None, None]:\n    try:\n        with open(path, \"rb\") as f:\n            yield ELFFile(f)\n    except (OSError, TypeError, ValueError):\n        yield None\ndef _is_linux_armhf(executable: str) -> bool:\n    # hard-float ABI can be detected from the ELF header of the running",
        "detail": "bundled.libs.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "_LEGACY_MANYLINUX_MAP",
        "kind": 5,
        "importPath": "bundled.libs.packaging._manylinux",
        "description": "bundled.libs.packaging._manylinux",
        "peekOfCode": "_LEGACY_MANYLINUX_MAP = {\n    # CentOS 7 w/ glibc 2.17 (PEP 599)\n    (2, 17): \"manylinux2014\",\n    # CentOS 6 w/ glibc 2.12 (PEP 571)\n    (2, 12): \"manylinux2010\",\n    # CentOS 5 w/ glibc 2.5 (PEP 513)\n    (2, 5): \"manylinux1\",\n}\ndef platform_tags(linux: str, arch: str) -> Iterator[str]:\n    if not _have_compatible_abi(sys.executable, arch):",
        "detail": "bundled.libs.packaging._manylinux",
        "documentation": {}
    },
    {
        "label": "_MuslVersion",
        "kind": 6,
        "importPath": "bundled.libs.packaging._musllinux",
        "description": "bundled.libs.packaging._musllinux",
        "peekOfCode": "class _MuslVersion(NamedTuple):\n    major: int\n    minor: int\ndef _parse_musl_version(output: str) -> Optional[_MuslVersion]:\n    lines = [n for n in (n.strip() for n in output.splitlines()) if n]\n    if len(lines) < 2 or lines[0][:4] != \"musl\":\n        return None\n    m = re.match(r\"Version (\\d+)\\.(\\d+)\", lines[1])\n    if not m:\n        return None",
        "detail": "bundled.libs.packaging._musllinux",
        "documentation": {}
    },
    {
        "label": "platform_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging._musllinux",
        "description": "bundled.libs.packaging._musllinux",
        "peekOfCode": "def platform_tags(arch: str) -> Iterator[str]:\n    \"\"\"Generate musllinux tags compatible to the current platform.\n    :param arch: Should be the part of platform tag after the ``linux_``\n        prefix, e.g. ``x86_64``. The ``linux_`` prefix is assumed as a\n        prerequisite for the current platform to be musllinux-compatible.\n    :returns: An iterator of compatible musllinux tags.\n    \"\"\"\n    sys_musl = _get_musl_version(sys.executable)\n    if sys_musl is None:  # Python not dynamically linked against musl.\n        return",
        "detail": "bundled.libs.packaging._musllinux",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "class Node:\n    def __init__(self, value: str) -> None:\n        self.value = value\n    def __str__(self) -> str:\n        return self.value\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}('{self}')>\"\n    def serialize(self) -> str:\n        raise NotImplementedError\nclass Variable(Node):",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "Variable",
        "kind": 6,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "class Variable(Node):\n    def serialize(self) -> str:\n        return str(self)\nclass Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\nMarkerVar = Union[Variable, Value]",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "Value",
        "kind": 6,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "class Value(Node):\n    def serialize(self) -> str:\n        return f'\"{self}\"'\nclass Op(Node):\n    def serialize(self) -> str:\n        return str(self)\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "Op",
        "kind": 6,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "class Op(Node):\n    def serialize(self) -> str:\n        return str(self)\nMarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "ParsedRequirement",
        "kind": 6,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "class ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------\ndef parse_requirement(source: str) -> ParsedRequirement:",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "parse_requirement",
        "kind": 2,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "def parse_requirement(source: str) -> ParsedRequirement:\n    return _parse_requirement(Tokenizer(source, rules=DEFAULT_RULES))\ndef _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:\n    \"\"\"\n    requirement = WS? IDENTIFIER WS? extras WS? requirement_details\n    \"\"\"\n    tokenizer.consume(\"WS\")\n    name_token = tokenizer.expect(\n        \"IDENTIFIER\", expected=\"package name at the start of dependency specifier\"\n    )",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "parse_marker",
        "kind": 2,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "def parse_marker(source: str) -> MarkerList:\n    return _parse_marker(Tokenizer(source, rules=DEFAULT_RULES))\ndef _parse_marker(tokenizer: Tokenizer) -> MarkerList:\n    \"\"\"\n    marker = marker_atom (BOOLOP marker_atom)+\n    \"\"\"\n    expression = [_parse_marker_atom(tokenizer)]\n    while tokenizer.check(\"BOOLOP\"):\n        token = tokenizer.read()\n        expr_right = _parse_marker_atom(tokenizer)",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "process_env_var",
        "kind": 2,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "def process_env_var(env_var: str) -> Variable:\n    if (\n        env_var == \"platform_python_implementation\"\n        or env_var == \"python_implementation\"\n    ):\n        return Variable(\"platform_python_implementation\")\n    else:\n        return Variable(env_var)\ndef process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "process_python_str",
        "kind": 2,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "def process_python_str(python_str: str) -> Value:\n    value = ast.literal_eval(python_str)\n    return Value(str(value))\ndef _parse_marker_op(tokenizer: Tokenizer) -> Op:\n    \"\"\"\n    marker_op = IN | NOT IN | OP\n    \"\"\"\n    if tokenizer.check(\"IN\"):\n        tokenizer.read()\n        return Op(\"in\")",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerVar",
        "kind": 5,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "MarkerVar = Union[Variable, Value]\nMarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerItem",
        "kind": 5,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "MarkerItem = Tuple[MarkerVar, Op, MarkerVar]\n# MarkerAtom = Union[MarkerItem, List[\"MarkerAtom\"]]\n# MarkerList = List[Union[\"MarkerList\", MarkerAtom, str]]\n# mypy does not support recursive type definition\n# https://github.com/python/mypy/issues/731\nMarkerAtom = Any\nMarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerAtom",
        "kind": 5,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "MarkerAtom = Any\nMarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "MarkerList",
        "kind": 5,
        "importPath": "bundled.libs.packaging._parser",
        "description": "bundled.libs.packaging._parser",
        "peekOfCode": "MarkerList = List[Any]\nclass ParsedRequirement(NamedTuple):\n    name: str\n    url: str\n    extras: List[str]\n    specifier: str\n    marker: Optional[MarkerList]\n# --------------------------------------------------------------------------------------\n# Recursive descent parser for dependency specifier\n# --------------------------------------------------------------------------------------",
        "detail": "bundled.libs.packaging._parser",
        "documentation": {}
    },
    {
        "label": "InfinityType",
        "kind": 6,
        "importPath": "bundled.libs.packaging._structures",
        "description": "bundled.libs.packaging._structures",
        "peekOfCode": "class InfinityType:\n    def __repr__(self) -> str:\n        return \"Infinity\"\n    def __hash__(self) -> int:\n        return hash(repr(self))\n    def __lt__(self, other: object) -> bool:\n        return False\n    def __le__(self, other: object) -> bool:\n        return False\n    def __eq__(self, other: object) -> bool:",
        "detail": "bundled.libs.packaging._structures",
        "documentation": {}
    },
    {
        "label": "NegativeInfinityType",
        "kind": 6,
        "importPath": "bundled.libs.packaging._structures",
        "description": "bundled.libs.packaging._structures",
        "peekOfCode": "class NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n    def __hash__(self) -> int:\n        return hash(repr(self))\n    def __lt__(self, other: object) -> bool:\n        return True\n    def __le__(self, other: object) -> bool:\n        return True\n    def __eq__(self, other: object) -> bool:",
        "detail": "bundled.libs.packaging._structures",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "kind": 5,
        "importPath": "bundled.libs.packaging._structures",
        "description": "bundled.libs.packaging._structures",
        "peekOfCode": "Infinity = InfinityType()\nclass NegativeInfinityType:\n    def __repr__(self) -> str:\n        return \"-Infinity\"\n    def __hash__(self) -> int:\n        return hash(repr(self))\n    def __lt__(self, other: object) -> bool:\n        return True\n    def __le__(self, other: object) -> bool:\n        return True",
        "detail": "bundled.libs.packaging._structures",
        "documentation": {}
    },
    {
        "label": "NegativeInfinity",
        "kind": 5,
        "importPath": "bundled.libs.packaging._structures",
        "description": "bundled.libs.packaging._structures",
        "peekOfCode": "NegativeInfinity = NegativeInfinityType()",
        "detail": "bundled.libs.packaging._structures",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "bundled.libs.packaging._tokenizer",
        "description": "bundled.libs.packaging._tokenizer",
        "peekOfCode": "class Token:\n    name: str\n    text: str\n    position: int\nclass ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n    def __init__(\n        self,\n        message: str,\n        *,",
        "detail": "bundled.libs.packaging._tokenizer",
        "documentation": {}
    },
    {
        "label": "ParserSyntaxError",
        "kind": 6,
        "importPath": "bundled.libs.packaging._tokenizer",
        "description": "bundled.libs.packaging._tokenizer",
        "peekOfCode": "class ParserSyntaxError(Exception):\n    \"\"\"The provided source text could not be parsed correctly.\"\"\"\n    def __init__(\n        self,\n        message: str,\n        *,\n        source: str,\n        span: Tuple[int, int],\n    ) -> None:\n        self.span = span",
        "detail": "bundled.libs.packaging._tokenizer",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "kind": 6,
        "importPath": "bundled.libs.packaging._tokenizer",
        "description": "bundled.libs.packaging._tokenizer",
        "peekOfCode": "class Tokenizer:\n    \"\"\"Context-sensitive token parsing.\n    Provides methods to examine the input stream to check whether the next token\n    matches.\n    \"\"\"\n    def __init__(\n        self,\n        source: str,\n        *,\n        rules: \"Dict[str, Union[str, re.Pattern[str]]]\",",
        "detail": "bundled.libs.packaging._tokenizer",
        "documentation": {}
    },
    {
        "label": "InvalidMarker",
        "kind": 6,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "class InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "UndefinedComparison",
        "kind": 6,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "class UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\nclass UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\ndef _normalize_extra_values(results: Any) -> Any:",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "UndefinedEnvironmentName",
        "kind": 6,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "class UndefinedEnvironmentName(ValueError):\n    \"\"\"\n    A name was attempted to be used that does not exist inside of the\n    environment.\n    \"\"\"\ndef _normalize_extra_values(results: Any) -> Any:\n    \"\"\"\n    Normalize extra values.\n    \"\"\"\n    if isinstance(results[0], tuple):",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "Marker",
        "kind": 6,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "class Marker:\n    def __init__(self, marker: str) -> None:\n        # Note: We create a Marker object without calling this constructor in\n        #       packaging.requirements.Requirement. If any additional logic is\n        #       added here, make sure to mirror/adapt Requirement.\n        try:\n            self._markers = _normalize_extra_values(parse_marker(marker))\n            # The attribute `_markers` can be described in terms of a recursive type:\n            # MarkerList = List[Union[Tuple[Node, ...], str, MarkerList]]\n            #",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "format_full_version",
        "kind": 2,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "def format_full_version(info: \"sys._version_info\") -> str:\n    version = \"{0.major}.{0.minor}.{0.micro}\".format(info)\n    kind = info.releaselevel\n    if kind != \"final\":\n        version += kind[0] + str(info.serial)\n    return version\ndef default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "default_environment",
        "kind": 2,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "def default_environment() -> Dict[str, str]:\n    iver = format_full_version(sys.implementation.version)\n    implementation_name = sys.implementation.name\n    return {\n        \"implementation_name\": implementation_name,\n        \"implementation_version\": iver,\n        \"os_name\": os.name,\n        \"platform_machine\": platform.machine(),\n        \"platform_release\": platform.release(),\n        \"platform_system\": platform.system(),",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "__all__ = [\n    \"InvalidMarker\",\n    \"UndefinedComparison\",\n    \"UndefinedEnvironmentName\",\n    \"Marker\",\n    \"default_environment\",\n]\nOperator = Callable[[str, str], bool]\nclass InvalidMarker(ValueError):\n    \"\"\"",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "Operator",
        "kind": 5,
        "importPath": "bundled.libs.packaging.markers",
        "description": "bundled.libs.packaging.markers",
        "peekOfCode": "Operator = Callable[[str, str], bool]\nclass InvalidMarker(ValueError):\n    \"\"\"\n    An invalid marker was found, users should refer to PEP 508.\n    \"\"\"\nclass UndefinedComparison(ValueError):\n    \"\"\"\n    An invalid operation was attempted on a value that doesn't support it.\n    \"\"\"\nclass UndefinedEnvironmentName(ValueError):",
        "detail": "bundled.libs.packaging.markers",
        "documentation": {}
    },
    {
        "label": "InvalidRequirement",
        "kind": 6,
        "importPath": "bundled.libs.packaging.requirements",
        "description": "bundled.libs.packaging.requirements",
        "peekOfCode": "class InvalidRequirement(ValueError):\n    \"\"\"\n    An invalid requirement was found, users should refer to PEP 508.\n    \"\"\"\nclass Requirement:\n    \"\"\"Parse a requirement.\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"",
        "detail": "bundled.libs.packaging.requirements",
        "documentation": {}
    },
    {
        "label": "Requirement",
        "kind": 6,
        "importPath": "bundled.libs.packaging.requirements",
        "description": "bundled.libs.packaging.requirements",
        "peekOfCode": "class Requirement:\n    \"\"\"Parse a requirement.\n    Parse a given requirement string into its parts, such as name, specifier,\n    URL, and extras. Raises InvalidRequirement on a badly-formed requirement\n    string.\n    \"\"\"\n    # TODO: Can we test whether something is contained within a requirement?\n    #       If so how do we do that? Do we need to test against the _name_ of\n    #       the thing as well as the version? What about the markers?\n    # TODO: Can we normalize the name and extra name?",
        "detail": "bundled.libs.packaging.requirements",
        "documentation": {}
    },
    {
        "label": "InvalidSpecifier",
        "kind": 6,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "class InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n    >>> Specifier(\"lolwat\")\n    Traceback (most recent call last):\n        ...\n    packaging.specifiers.InvalidSpecifier: Invalid specifier: 'lolwat'\n    \"\"\"\nclass BaseSpecifier(metaclass=abc.ABCMeta):",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "BaseSpecifier",
        "kind": 6,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "class BaseSpecifier(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __str__(self) -> str:\n        \"\"\"\n        Returns the str representation of this Specifier-like object. This\n        should be representative of the Specifier itself.\n        \"\"\"\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "Specifier",
        "kind": 6,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "class Specifier(BaseSpecifier):\n    \"\"\"This class abstracts handling of version specifiers.\n    .. tip::\n        It is generally not required to instantiate this manually. You should instead\n        prefer to work with :class:`SpecifierSet` instead, which can parse\n        comma-separated version specifiers (which is what package metadata contains).\n    \"\"\"\n    _operator_regex_str = r\"\"\"\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        \"\"\"",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "SpecifierSet",
        "kind": 6,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "class SpecifierSet(BaseSpecifier):\n    \"\"\"This class abstracts handling of a set of version specifiers.\n    It can be passed a single specifier (``>=3.0``), a comma-separated list of\n    specifiers (``>=3.0,!=3.1``), or no specifier at all.\n    \"\"\"\n    def __init__(\n        self, specifiers: str = \"\", prereleases: Optional[bool] = None\n    ) -> None:\n        \"\"\"Initialize a SpecifierSet instance.\n        :param specifiers:",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "UnparsedVersion",
        "kind": 5,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "UnparsedVersion = Union[Version, str]\nUnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "UnparsedVersionVar",
        "kind": 5,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "UnparsedVersionVar = TypeVar(\"UnparsedVersionVar\", bound=UnparsedVersion)\nCallableOperator = Callable[[Version, str], bool]\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "CallableOperator",
        "kind": 5,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "CallableOperator = Callable[[Version, str], bool]\ndef _coerce_version(version: UnparsedVersion) -> Version:\n    if not isinstance(version, Version):\n        version = Version(version)\n    return version\nclass InvalidSpecifier(ValueError):\n    \"\"\"\n    Raised when attempting to create a :class:`Specifier` with a specifier\n    string that is invalid.\n    >>> Specifier(\"lolwat\")",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "_prefix_regex",
        "kind": 5,
        "importPath": "bundled.libs.packaging.specifiers",
        "description": "bundled.libs.packaging.specifiers",
        "peekOfCode": "_prefix_regex = re.compile(r\"^([0-9]+)((?:a|b|c|rc)[0-9]+)$\")\ndef _version_split(version: str) -> List[str]:\n    result: List[str] = []\n    for item in version.split(\".\"):\n        match = _prefix_regex.search(item)\n        if match:\n            result.extend(match.groups())\n        else:\n            result.append(item)\n    return result",
        "detail": "bundled.libs.packaging.specifiers",
        "documentation": {}
    },
    {
        "label": "Tag",
        "kind": 6,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "class Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()\n        self._abi = abi.lower()",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "parse_tag",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def parse_tag(tag: str) -> FrozenSet[Tag]:\n    \"\"\"\n    Parses the provided tag (e.g. `py3-none-any`) into a frozenset of Tag instances.\n    Returning a set is required due to the possibility that the tag is a\n    compressed tag set.\n    \"\"\"\n    tags = set()\n    interpreters, abis, platforms = tag.split(\"-\")\n    for interpreter in interpreters.split(\".\"):\n        for abi in abis.split(\".\"):",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "cpython_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def cpython_tags(\n    python_version: Optional[PythonVersion] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a CPython interpreter.\n    The tags consist of:",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "generic_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def generic_tags(\n    interpreter: Optional[str] = None,\n    abis: Optional[Iterable[str]] = None,\n    platforms: Optional[Iterable[str]] = None,\n    *,\n    warn: bool = False,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the tags for a generic interpreter.\n    The tags consist of:",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "compatible_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def compatible_tags(\n    python_version: Optional[PythonVersion] = None,\n    interpreter: Optional[str] = None,\n    platforms: Optional[Iterable[str]] = None,\n) -> Iterator[Tag]:\n    \"\"\"\n    Yields the sequence of tags that are compatible with a specific version of Python.\n    The tags consist of:\n    - py*-none-<platform>\n    - <interpreter>-none-any  # ... if `interpreter` is provided.",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "mac_platforms",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def mac_platforms(\n    version: Optional[MacVersion] = None, arch: Optional[str] = None\n) -> Iterator[str]:\n    \"\"\"\n    Yields the platform tags for a macOS system.\n    The `version` parameter is a two-item tuple specifying the macOS version to\n    generate platform tags for. The `arch` parameter is the CPU architecture to\n    generate platform tags for. Both parameters default to the appropriate value\n    for the current system.\n    \"\"\"",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "platform_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def platform_tags() -> Iterator[str]:\n    \"\"\"\n    Provides the platform tags for this installation.\n    \"\"\"\n    if platform.system() == \"Darwin\":\n        return mac_platforms()\n    elif platform.system() == \"Linux\":\n        return _linux_platforms()\n    else:\n        return _generic_platforms()",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "interpreter_name",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def interpreter_name() -> str:\n    \"\"\"\n    Returns the name of the running interpreter.\n    Some implementations have a reserved, two-letter abbreviation which will\n    be returned when appropriate.\n    \"\"\"\n    name = sys.implementation.name\n    return INTERPRETER_SHORT_NAMES.get(name) or name\ndef interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "interpreter_version",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def interpreter_version(*, warn: bool = False) -> str:\n    \"\"\"\n    Returns the version of the running interpreter.\n    \"\"\"\n    version = _get_config_var(\"py_version_nodot\", warn=warn)\n    if version:\n        version = str(version)\n    else:\n        version = _version_nodot(sys.version_info[:2])\n    return version",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "sys_tags",
        "kind": 2,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "def sys_tags(*, warn: bool = False) -> Iterator[Tag]:\n    \"\"\"\n    Returns the sequence of tag triples for the running interpreter.\n    The order of the sequence corresponds to priority order for the\n    interpreter, from most to least important.\n    \"\"\"\n    interp_name = interpreter_name()\n    if interp_name == \"cp\":\n        yield from cpython_tags(warn=warn)\n    else:",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "logger = logging.getLogger(__name__)\nPythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "PythonVersion",
        "kind": 5,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "PythonVersion = Sequence[int]\nMacVersion = Tuple[int, int]\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n_32_BIT_INTERPRETER = sys.maxsize <= 2**32",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "MacVersion",
        "kind": 5,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "MacVersion = Tuple[int, int]\nINTERPRETER_SHORT_NAMES: Dict[str, str] = {\n    \"python\": \"py\",  # Generic.\n    \"cpython\": \"cp\",\n    \"pypy\": \"pp\",\n    \"ironpython\": \"ip\",\n    \"jython\": \"jy\",\n}\n_32_BIT_INTERPRETER = sys.maxsize <= 2**32\nclass Tag:",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "_32_BIT_INTERPRETER",
        "kind": 5,
        "importPath": "bundled.libs.packaging.tags",
        "description": "bundled.libs.packaging.tags",
        "peekOfCode": "_32_BIT_INTERPRETER = sys.maxsize <= 2**32\nclass Tag:\n    \"\"\"\n    A representation of the tag triple for a wheel.\n    Instances are considered immutable and thus are hashable. Equality checking\n    is also supported.\n    \"\"\"\n    __slots__ = [\"_interpreter\", \"_abi\", \"_platform\", \"_hash\"]\n    def __init__(self, interpreter: str, abi: str, platform: str) -> None:\n        self._interpreter = interpreter.lower()",
        "detail": "bundled.libs.packaging.tags",
        "documentation": {}
    },
    {
        "label": "InvalidWheelFilename",
        "kind": 6,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "class InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n# PEP 427: The build number must start with a digit.",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "InvalidSdistFilename",
        "kind": 6,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "class InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n_canonicalize_regex = re.compile(r\"[-_.]+\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\ndef canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "canonicalize_name",
        "kind": 2,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "def canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "canonicalize_version",
        "kind": 2,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "def canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference\n    with the way it handles the release segment.\n    \"\"\"\n    if isinstance(version, str):\n        try:\n            parsed = Version(version)",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "parse_wheel_filename",
        "kind": 2,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "def parse_wheel_filename(\n    filename: str,\n) -> Tuple[NormalizedName, Version, BuildTag, FrozenSet[Tag]]:\n    if not filename.endswith(\".whl\"):\n        raise InvalidWheelFilename(\n            f\"Invalid wheel filename (extension must be '.whl'): {filename}\"\n        )\n    filename = filename[:-4]\n    dashes = filename.count(\"-\")\n    if dashes not in (4, 5):",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "parse_sdist_filename",
        "kind": 2,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "def parse_sdist_filename(filename: str) -> Tuple[NormalizedName, Version]:\n    if filename.endswith(\".tar.gz\"):\n        file_stem = filename[: -len(\".tar.gz\")]\n    elif filename.endswith(\".zip\"):\n        file_stem = filename[: -len(\".zip\")]\n    else:\n        raise InvalidSdistFilename(\n            f\"Invalid sdist filename (extension must be '.tar.gz' or '.zip'):\"\n            f\" {filename}\"\n        )",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "BuildTag",
        "kind": 5,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "BuildTag = Union[Tuple[()], Tuple[int, str]]\nNormalizedName = NewType(\"NormalizedName\", str)\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "NormalizedName",
        "kind": 5,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "NormalizedName = NewType(\"NormalizedName\", str)\nclass InvalidWheelFilename(ValueError):\n    \"\"\"\n    An invalid wheel filename was found, users should refer to PEP 427.\n    \"\"\"\nclass InvalidSdistFilename(ValueError):\n    \"\"\"\n    An invalid sdist filename was found, users should refer to the packaging user guide.\n    \"\"\"\n_canonicalize_regex = re.compile(r\"[-_.]+\")",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "_canonicalize_regex",
        "kind": 5,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "_canonicalize_regex = re.compile(r\"[-_.]+\")\n# PEP 427: The build number must start with a digit.\n_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\ndef canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "_build_tag_regex",
        "kind": 5,
        "importPath": "bundled.libs.packaging.utils",
        "description": "bundled.libs.packaging.utils",
        "peekOfCode": "_build_tag_regex = re.compile(r\"(\\d+)(.*)\")\ndef canonicalize_name(name: str) -> NormalizedName:\n    # This is taken from PEP 503.\n    value = _canonicalize_regex.sub(\"-\", name).lower()\n    return cast(NormalizedName, value)\ndef canonicalize_version(\n    version: Union[Version, str], *, strip_trailing_zero: bool = True\n) -> str:\n    \"\"\"\n    This is very similar to Version.__str__, but has one subtle difference",
        "detail": "bundled.libs.packaging.utils",
        "documentation": {}
    },
    {
        "label": "InvalidVersion",
        "kind": 6,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "class InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.\n    >>> Version(\"invalid\")\n    Traceback (most recent call last):\n        ...\n    packaging.version.InvalidVersion: Invalid version: 'invalid'\n    \"\"\"\nclass _BaseVersion:\n    _key: CmpKey\n    def __hash__(self) -> int:",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "_BaseVersion",
        "kind": 6,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "class _BaseVersion:\n    _key: CmpKey\n    def __hash__(self) -> int:\n        return hash(self._key)\n    # Please keep the duplicated `isinstance` check\n    # in the six comparisons hereunder\n    # unless you find a way to avoid adding overhead function calls.\n    def __lt__(self, other: \"_BaseVersion\") -> bool:\n        if not isinstance(other, _BaseVersion):\n            return NotImplemented",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "Version",
        "kind": 6,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "class Version(_BaseVersion):\n    \"\"\"This class abstracts handling of a project's versions.\n    A :class:`Version` instance is comparison aware and can be compared and\n    sorted using the standard Python interfaces.\n    >>> v1 = Version(\"1.0a5\")\n    >>> v2 = Version(\"1.0\")\n    >>> v1\n    <Version('1.0a5')>\n    >>> v2\n    <Version('1.0')>",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "def parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"\n    return Version(version)\nclass InvalidVersion(ValueError):\n    \"\"\"Raised when a version string is not a valid version.",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "__all__ = [\"VERSION_PATTERN\", \"parse\", \"Version\", \"InvalidVersion\"]\nInfiniteTypes = Union[InfinityType, NegativeInfinityType]\nPrePostDevType = Union[InfiniteTypes, Tuple[str, int]]\nSubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "InfiniteTypes",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "InfiniteTypes = Union[InfinityType, NegativeInfinityType]\nPrePostDevType = Union[InfiniteTypes, Tuple[str, int]]\nSubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "PrePostDevType",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "PrePostDevType = Union[InfiniteTypes, Tuple[str, int]]\nSubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],\n        ],",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "SubLocalType",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "SubLocalType = Union[InfiniteTypes, int, str]\nLocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],\n        ],\n        ...,",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "LocalType",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "LocalType = Union[\n    NegativeInfinityType,\n    Tuple[\n        Union[\n            SubLocalType,\n            Tuple[SubLocalType, str],\n            Tuple[NegativeInfinityType, SubLocalType],\n        ],\n        ...,\n    ],",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "CmpKey",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "CmpKey = Tuple[\n    int, Tuple[int, ...], PrePostDevType, PrePostDevType, PrePostDevType, LocalType\n]\nVersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n_Version = collections.namedtuple(\n    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]\n)\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "VersionComparisonMethod",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "VersionComparisonMethod = Callable[[CmpKey, CmpKey], bool]\n_Version = collections.namedtuple(\n    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]\n)\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "_Version",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "_Version = collections.namedtuple(\n    \"_Version\", [\"epoch\", \"release\", \"dev\", \"pre\", \"post\", \"local\"]\n)\ndef parse(version: str) -> \"Version\":\n    \"\"\"Parse the given version string.\n    >>> parse('1.0.dev1')\n    <Version('1.0.dev1')>\n    :param version: The version string to parse.\n    :raises InvalidVersion: When the version string is not a valid version.\n    \"\"\"",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "_VERSION_PATTERN",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "_VERSION_PATTERN = r\"\"\"\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\\.]?\n            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n            [-_\\.]?\n            (?P<pre_n>[0-9]+)?",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "VERSION_PATTERN",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "VERSION_PATTERN = _VERSION_PATTERN\n\"\"\"\nA string containing the regular expression used to match a valid version.\nThe pattern is not anchored at either end, and is intended for embedding in larger\nexpressions (for example, matching a version number as part of a file name). The\nregular expression should be compiled with the ``re.VERBOSE`` and ``re.IGNORECASE``\nflags set.\n:meta hide-value:\n\"\"\"\nclass Version(_BaseVersion):",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "_local_version_separators",
        "kind": 5,
        "importPath": "bundled.libs.packaging.version",
        "description": "bundled.libs.packaging.version",
        "peekOfCode": "_local_version_separators = re.compile(r\"[\\._-]\")\ndef _parse_local_version(local: str) -> Optional[LocalType]:\n    \"\"\"\n    Takes a string like abc.1.twelve and turns it into (\"abc\", 1, \"twelve\").\n    \"\"\"\n    if local is not None:\n        return tuple(\n            part.lower() if not part.isdigit() else int(part)\n            for part in _local_version_separators.split(local)\n        )",
        "detail": "bundled.libs.packaging.version",
        "documentation": {}
    },
    {
        "label": "ServerCapabilitiesBuilder",
        "kind": 6,
        "importPath": "bundled.libs.pygls.capabilities",
        "description": "bundled.libs.pygls.capabilities",
        "peekOfCode": "class ServerCapabilitiesBuilder:\n    \"\"\"Create `ServerCapabilities` instance depending on builtin and user registered\n    features.\n    \"\"\"\n    def __init__(\n        self,\n        client_capabilities,\n        features,\n        feature_options,\n        commands,",
        "detail": "bundled.libs.pygls.capabilities",
        "documentation": {}
    },
    {
        "label": "get_capability",
        "kind": 2,
        "importPath": "bundled.libs.pygls.capabilities",
        "description": "bundled.libs.pygls.capabilities",
        "peekOfCode": "def get_capability(\n    client_capabilities: ClientCapabilities, field: str, default: Any = None\n) -> Any:\n    \"\"\"Check if ClientCapabilities has some nested value without raising\n    AttributeError.\n    e.g. get_capability('text_document.synchronization.will_save')\n    \"\"\"\n    try:\n        value = reduce(getattr, field.split(\".\"), client_capabilities)\n    except AttributeError:",
        "detail": "bundled.libs.pygls.capabilities",
        "documentation": {}
    },
    {
        "label": "ATTR_EXECUTE_IN_THREAD",
        "kind": 5,
        "importPath": "bundled.libs.pygls.constants",
        "description": "bundled.libs.pygls.constants",
        "peekOfCode": "ATTR_EXECUTE_IN_THREAD = 'execute_in_thread'\nATTR_COMMAND_TYPE = 'command'\nATTR_FEATURE_TYPE = 'feature'\nATTR_REGISTERED_NAME = 'reg_name'\nATTR_REGISTERED_TYPE = 'reg_type'\n# Parameters\nPARAM_LS = 'ls'",
        "detail": "bundled.libs.pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_COMMAND_TYPE",
        "kind": 5,
        "importPath": "bundled.libs.pygls.constants",
        "description": "bundled.libs.pygls.constants",
        "peekOfCode": "ATTR_COMMAND_TYPE = 'command'\nATTR_FEATURE_TYPE = 'feature'\nATTR_REGISTERED_NAME = 'reg_name'\nATTR_REGISTERED_TYPE = 'reg_type'\n# Parameters\nPARAM_LS = 'ls'",
        "detail": "bundled.libs.pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_FEATURE_TYPE",
        "kind": 5,
        "importPath": "bundled.libs.pygls.constants",
        "description": "bundled.libs.pygls.constants",
        "peekOfCode": "ATTR_FEATURE_TYPE = 'feature'\nATTR_REGISTERED_NAME = 'reg_name'\nATTR_REGISTERED_TYPE = 'reg_type'\n# Parameters\nPARAM_LS = 'ls'",
        "detail": "bundled.libs.pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_REGISTERED_NAME",
        "kind": 5,
        "importPath": "bundled.libs.pygls.constants",
        "description": "bundled.libs.pygls.constants",
        "peekOfCode": "ATTR_REGISTERED_NAME = 'reg_name'\nATTR_REGISTERED_TYPE = 'reg_type'\n# Parameters\nPARAM_LS = 'ls'",
        "detail": "bundled.libs.pygls.constants",
        "documentation": {}
    },
    {
        "label": "ATTR_REGISTERED_TYPE",
        "kind": 5,
        "importPath": "bundled.libs.pygls.constants",
        "description": "bundled.libs.pygls.constants",
        "peekOfCode": "ATTR_REGISTERED_TYPE = 'reg_type'\n# Parameters\nPARAM_LS = 'ls'",
        "detail": "bundled.libs.pygls.constants",
        "documentation": {}
    },
    {
        "label": "PARAM_LS",
        "kind": 5,
        "importPath": "bundled.libs.pygls.constants",
        "description": "bundled.libs.pygls.constants",
        "peekOfCode": "PARAM_LS = 'ls'",
        "detail": "bundled.libs.pygls.constants",
        "documentation": {}
    },
    {
        "label": "JsonRpcException",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcException(Exception):\n    \"\"\"A class used as a base class for json rpc exceptions.\"\"\"\n    def __init__(self, message=None, code=None, data=None):\n        message = message or getattr(self.__class__, 'MESSAGE')\n        super().__init__(message)\n        self.message = message\n        self.code = code or getattr(self.__class__, 'CODE')\n        self.data = data\n    def __eq__(self, other):\n        return (",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcInternalError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcInternalError(JsonRpcException):\n    CODE = -32602\n    MESSAGE = 'Internal Error'\n    @classmethod\n    def of(cls, exc_info):\n        exc_type, exc_value, exc_tb = exc_info\n        return cls(\n            message=''.join(traceback.format_exception_only(\n                exc_type, exc_value)).strip(),\n            data={'traceback': traceback.format_tb(exc_tb)}",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcInvalidParams",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcInvalidParams(JsonRpcException):\n    CODE = -32602\n    MESSAGE = 'Invalid Params'\nclass JsonRpcInvalidRequest(JsonRpcException):\n    CODE = -32600\n    MESSAGE = 'Invalid Request'\nclass JsonRpcMethodNotFound(JsonRpcException):\n    CODE = -32601\n    MESSAGE = 'Method Not Found'\n    @classmethod",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcInvalidRequest",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcInvalidRequest(JsonRpcException):\n    CODE = -32600\n    MESSAGE = 'Invalid Request'\nclass JsonRpcMethodNotFound(JsonRpcException):\n    CODE = -32601\n    MESSAGE = 'Method Not Found'\n    @classmethod\n    def of(cls, method):\n        return cls(message=cls.MESSAGE + ': ' + method)\nclass JsonRpcParseError(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcMethodNotFound",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcMethodNotFound(JsonRpcException):\n    CODE = -32601\n    MESSAGE = 'Method Not Found'\n    @classmethod\n    def of(cls, method):\n        return cls(message=cls.MESSAGE + ': ' + method)\nclass JsonRpcParseError(JsonRpcException):\n    CODE = -32700\n    MESSAGE = 'Parse Error'\nclass JsonRpcRequestCancelled(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcParseError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcParseError(JsonRpcException):\n    CODE = -32700\n    MESSAGE = 'Parse Error'\nclass JsonRpcRequestCancelled(JsonRpcException):\n    CODE = -32800\n    MESSAGE = 'Request Cancelled'\nclass JsonRpcContentModified(JsonRpcException):\n    CODE = -32801\n    MESSAGE = 'Content Modified'\nclass JsonRpcServerNotInitialized(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcRequestCancelled",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcRequestCancelled(JsonRpcException):\n    CODE = -32800\n    MESSAGE = 'Request Cancelled'\nclass JsonRpcContentModified(JsonRpcException):\n    CODE = -32801\n    MESSAGE = 'Content Modified'\nclass JsonRpcServerNotInitialized(JsonRpcException):\n    CODE = -32002\n    MESSAGE = 'ServerNotInitialized'\nclass JsonRpcUnknownErrorCode(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcContentModified",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcContentModified(JsonRpcException):\n    CODE = -32801\n    MESSAGE = 'Content Modified'\nclass JsonRpcServerNotInitialized(JsonRpcException):\n    CODE = -32002\n    MESSAGE = 'ServerNotInitialized'\nclass JsonRpcUnknownErrorCode(JsonRpcException):\n    CODE = -32001\n    MESSAGE = 'UnknownErrorCode'\nclass JsonRpcReservedErrorRangeStart(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcServerNotInitialized",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcServerNotInitialized(JsonRpcException):\n    CODE = -32002\n    MESSAGE = 'ServerNotInitialized'\nclass JsonRpcUnknownErrorCode(JsonRpcException):\n    CODE = -32001\n    MESSAGE = 'UnknownErrorCode'\nclass JsonRpcReservedErrorRangeStart(JsonRpcException):\n    CODE = -32099\n    MESSAGE = 'jsonrpcReservedErrorRangeStart'\nclass JsonRpcReservedErrorRangeEnd(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcUnknownErrorCode",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcUnknownErrorCode(JsonRpcException):\n    CODE = -32001\n    MESSAGE = 'UnknownErrorCode'\nclass JsonRpcReservedErrorRangeStart(JsonRpcException):\n    CODE = -32099\n    MESSAGE = 'jsonrpcReservedErrorRangeStart'\nclass JsonRpcReservedErrorRangeEnd(JsonRpcException):\n    CODE = -32000\n    MESSAGE = 'jsonrpcReservedErrorRangeEnd'\nclass LspReservedErrorRangeStart(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcReservedErrorRangeStart",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcReservedErrorRangeStart(JsonRpcException):\n    CODE = -32099\n    MESSAGE = 'jsonrpcReservedErrorRangeStart'\nclass JsonRpcReservedErrorRangeEnd(JsonRpcException):\n    CODE = -32000\n    MESSAGE = 'jsonrpcReservedErrorRangeEnd'\nclass LspReservedErrorRangeStart(JsonRpcException):\n    CODE = -32899\n    MESSAGE = 'lspReservedErrorRangeStart'\nclass LspReservedErrorRangeEnd(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcReservedErrorRangeEnd",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcReservedErrorRangeEnd(JsonRpcException):\n    CODE = -32000\n    MESSAGE = 'jsonrpcReservedErrorRangeEnd'\nclass LspReservedErrorRangeStart(JsonRpcException):\n    CODE = -32899\n    MESSAGE = 'lspReservedErrorRangeStart'\nclass LspReservedErrorRangeEnd(JsonRpcException):\n    CODE = -32800\n    MESSAGE = 'lspReservedErrorRangeEnd'\nclass JsonRpcServerError(JsonRpcException):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "LspReservedErrorRangeStart",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class LspReservedErrorRangeStart(JsonRpcException):\n    CODE = -32899\n    MESSAGE = 'lspReservedErrorRangeStart'\nclass LspReservedErrorRangeEnd(JsonRpcException):\n    CODE = -32800\n    MESSAGE = 'lspReservedErrorRangeEnd'\nclass JsonRpcServerError(JsonRpcException):\n    def __init__(self, message, code, data=None):\n        if not _is_server_error_code(code):\n            raise ValueError('Error code should be in range -32099 - -32000')",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "LspReservedErrorRangeEnd",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class LspReservedErrorRangeEnd(JsonRpcException):\n    CODE = -32800\n    MESSAGE = 'lspReservedErrorRangeEnd'\nclass JsonRpcServerError(JsonRpcException):\n    def __init__(self, message, code, data=None):\n        if not _is_server_error_code(code):\n            raise ValueError('Error code should be in range -32099 - -32000')\n        super().__init__(message=message, code=code, data=data)\n    @classmethod\n    def supports_code(cls, code):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "JsonRpcServerError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class JsonRpcServerError(JsonRpcException):\n    def __init__(self, message, code, data=None):\n        if not _is_server_error_code(code):\n            raise ValueError('Error code should be in range -32099 - -32000')\n        super().__init__(message=message, code=code, data=data)\n    @classmethod\n    def supports_code(cls, code):\n        return _is_server_error_code(code)\ndef _is_server_error_code(code):\n    return -32099 <= code <= -32000",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "PyglsError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class PyglsError(Exception):\n    pass\nclass CommandAlreadyRegisteredError(PyglsError):\n    def __init__(self, command_name):\n        self.command_name = command_name\n    def __repr__(self):\n        return f'Command \"{self.command_name}\" is already registered.'\nclass FeatureAlreadyRegisteredError(PyglsError):\n    def __init__(self, feature_name):\n        self.feature_name = feature_name",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "CommandAlreadyRegisteredError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class CommandAlreadyRegisteredError(PyglsError):\n    def __init__(self, command_name):\n        self.command_name = command_name\n    def __repr__(self):\n        return f'Command \"{self.command_name}\" is already registered.'\nclass FeatureAlreadyRegisteredError(PyglsError):\n    def __init__(self, feature_name):\n        self.feature_name = feature_name\n    def __repr__(self):\n        return f'Feature \"{self.feature_name}\" is already registered.'",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureAlreadyRegisteredError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class FeatureAlreadyRegisteredError(PyglsError):\n    def __init__(self, feature_name):\n        self.feature_name = feature_name\n    def __repr__(self):\n        return f'Feature \"{self.feature_name}\" is already registered.'\nclass FeatureRequestError(PyglsError):\n    pass\nclass FeatureNotificationError(PyglsError):\n    pass\nclass MethodTypeNotRegisteredError(PyglsError):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureRequestError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class FeatureRequestError(PyglsError):\n    pass\nclass FeatureNotificationError(PyglsError):\n    pass\nclass MethodTypeNotRegisteredError(PyglsError):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return f'\"{self.name}\" is not added to `pygls.lsp.LSP_METHODS_MAP`.'\nclass ThreadDecoratorError(PyglsError):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureNotificationError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class FeatureNotificationError(PyglsError):\n    pass\nclass MethodTypeNotRegisteredError(PyglsError):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return f'\"{self.name}\" is not added to `pygls.lsp.LSP_METHODS_MAP`.'\nclass ThreadDecoratorError(PyglsError):\n    pass\nclass ValidationError(PyglsError):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "MethodTypeNotRegisteredError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class MethodTypeNotRegisteredError(PyglsError):\n    def __init__(self, name):\n        self.name = name\n    def __repr__(self):\n        return f'\"{self.name}\" is not added to `pygls.lsp.LSP_METHODS_MAP`.'\nclass ThreadDecoratorError(PyglsError):\n    pass\nclass ValidationError(PyglsError):\n    def __init__(self, errors=None):\n        self.errors = errors or []",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "ThreadDecoratorError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class ThreadDecoratorError(PyglsError):\n    pass\nclass ValidationError(PyglsError):\n    def __init__(self, errors=None):\n        self.errors = errors or []\n    def __repr__(self):\n        opt_errs = '\\n-'.join([e for e in self.errors])\n        return f'Missing options: {opt_errs}'",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "kind": 6,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "class ValidationError(PyglsError):\n    def __init__(self, errors=None):\n        self.errors = errors or []\n    def __repr__(self):\n        opt_errs = '\\n-'.join([e for e in self.errors])\n        return f'Missing options: {opt_errs}'",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "_EXCEPTIONS",
        "kind": 5,
        "importPath": "bundled.libs.pygls.exceptions",
        "description": "bundled.libs.pygls.exceptions",
        "peekOfCode": "_EXCEPTIONS = (\n    JsonRpcInternalError,\n    JsonRpcInvalidParams,\n    JsonRpcInvalidRequest,\n    JsonRpcMethodNotFound,\n    JsonRpcParseError,\n    JsonRpcRequestCancelled,\n    JsonRpcServerError,\n)\nclass PyglsError(Exception):",
        "detail": "bundled.libs.pygls.exceptions",
        "documentation": {}
    },
    {
        "label": "FeatureManager",
        "kind": 6,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "class FeatureManager:\n    \"\"\"A class for managing server features.\n    Attributes:\n        _builtin_features(dict): Predefined set of lsp methods\n        _feature_options(dict): Registered feature's options\n        _features(dict): Registered features\n        _commands(dict): Registered commands\n        server(LanguageServer): Reference to the language server\n                                If passed, server will be passed to registered\n                                features/commands with first parameter:",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "assign_help_attrs",
        "kind": 2,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "def assign_help_attrs(f, reg_name, reg_type):\n    setattr(f, ATTR_REGISTERED_NAME, reg_name)\n    setattr(f, ATTR_REGISTERED_TYPE, reg_type)\ndef assign_thread_attr(f):\n    setattr(f, ATTR_EXECUTE_IN_THREAD, True)\ndef get_help_attrs(f):\n    return getattr(f, ATTR_REGISTERED_NAME, None), getattr(f, ATTR_REGISTERED_TYPE, None)\ndef has_ls_param_or_annotation(f, annotation):\n    \"\"\"Returns true if callable has first parameter named `ls` or type of\n    annotation\"\"\"",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "assign_thread_attr",
        "kind": 2,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "def assign_thread_attr(f):\n    setattr(f, ATTR_EXECUTE_IN_THREAD, True)\ndef get_help_attrs(f):\n    return getattr(f, ATTR_REGISTERED_NAME, None), getattr(f, ATTR_REGISTERED_TYPE, None)\ndef has_ls_param_or_annotation(f, annotation):\n    \"\"\"Returns true if callable has first parameter named `ls` or type of\n    annotation\"\"\"\n    try:\n        sig = inspect.signature(f)\n        first_p = next(itertools.islice(sig.parameters.values(), 0, 1))",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "get_help_attrs",
        "kind": 2,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "def get_help_attrs(f):\n    return getattr(f, ATTR_REGISTERED_NAME, None), getattr(f, ATTR_REGISTERED_TYPE, None)\ndef has_ls_param_or_annotation(f, annotation):\n    \"\"\"Returns true if callable has first parameter named `ls` or type of\n    annotation\"\"\"\n    try:\n        sig = inspect.signature(f)\n        first_p = next(itertools.islice(sig.parameters.values(), 0, 1))\n        return first_p.name == PARAM_LS or first_p.annotation is annotation\n    except Exception:",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "has_ls_param_or_annotation",
        "kind": 2,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "def has_ls_param_or_annotation(f, annotation):\n    \"\"\"Returns true if callable has first parameter named `ls` or type of\n    annotation\"\"\"\n    try:\n        sig = inspect.signature(f)\n        first_p = next(itertools.islice(sig.parameters.values(), 0, 1))\n        return first_p.name == PARAM_LS or first_p.annotation is annotation\n    except Exception:\n        return False\ndef is_thread_function(f):",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "is_thread_function",
        "kind": 2,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "def is_thread_function(f):\n    return getattr(f, ATTR_EXECUTE_IN_THREAD, False)\ndef wrap_with_server(f, server):\n    \"\"\"Returns a new callable/coroutine with server as first argument.\"\"\"\n    if not has_ls_param_or_annotation(f, type(server)):\n        return f\n    if asyncio.iscoroutinefunction(f):\n        async def wrapped(*args, **kwargs):\n            return await f(server, *args, **kwargs)\n    else:",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "wrap_with_server",
        "kind": 2,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "def wrap_with_server(f, server):\n    \"\"\"Returns a new callable/coroutine with server as first argument.\"\"\"\n    if not has_ls_param_or_annotation(f, type(server)):\n        return f\n    if asyncio.iscoroutinefunction(f):\n        async def wrapped(*args, **kwargs):\n            return await f(server, *args, **kwargs)\n    else:\n        wrapped = functools.partial(f, server)\n        if is_thread_function(f):",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "bundled.libs.pygls.feature_manager",
        "description": "bundled.libs.pygls.feature_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef assign_help_attrs(f, reg_name, reg_type):\n    setattr(f, ATTR_REGISTERED_NAME, reg_name)\n    setattr(f, ATTR_REGISTERED_TYPE, reg_type)\ndef assign_thread_attr(f):\n    setattr(f, ATTR_EXECUTE_IN_THREAD, True)\ndef get_help_attrs(f):\n    return getattr(f, ATTR_REGISTERED_NAME, None), getattr(f, ATTR_REGISTERED_TYPE, None)\ndef has_ls_param_or_annotation(f, annotation):\n    \"\"\"Returns true if callable has first parameter named `ls` or type of",
        "detail": "bundled.libs.pygls.feature_manager",
        "documentation": {}
    },
    {
        "label": "Progress",
        "kind": 6,
        "importPath": "bundled.libs.pygls.progress",
        "description": "bundled.libs.pygls.progress",
        "peekOfCode": "class Progress:\n    \"\"\"A class for working with client's progress bar.\n    Attributes:\n        _lsp(LanguageServerProtocol): Language server protocol instance\n        tokens(dict): Holds progress bar tokens that are already registered\n    \"\"\"\n    def __init__(self, lsp: LanguageServerProtocol) -> None:\n        self._lsp = lsp\n        self.tokens: Dict[ProgressToken, None] = {}\n    def _check_token_registered(self, token: ProgressToken) -> None:",
        "detail": "bundled.libs.pygls.progress",
        "documentation": {}
    },
    {
        "label": "JsonRPCNotification",
        "kind": 6,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "class JsonRPCNotification:\n    \"\"\"A class that represents a generic json rpc notification message.\n    Used as a fallback for unknown types.\n    \"\"\"\n    method: str\n    jsonrpc: str\n    params: Any\n@attrs.define\nclass JsonRPCRequestMessage:\n    \"\"\"A class that represents a generic json rpc request message.",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "JsonRPCRequestMessage",
        "kind": 6,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "class JsonRPCRequestMessage:\n    \"\"\"A class that represents a generic json rpc request message.\n    Used as a fallback for unknown types.\n    \"\"\"\n    id: Union[int, str]\n    method: str\n    jsonrpc: str\n    params: Any\n@attrs.define\nclass JsonRPCResponseMessage:",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "JsonRPCResponseMessage",
        "kind": 6,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "class JsonRPCResponseMessage:\n    \"\"\"A class that represents a generic json rpc response message.\n    Used as a fallback for unknown types.\n    \"\"\"\n    id: Union[int, str]\n    jsonrpc: str\n    result: Any\ndef _dict_to_object(d: Any):\n    \"\"\"Create nested objects (namedtuple) from dict.\"\"\"\n    if d is None:",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "JsonRPCProtocol",
        "kind": 6,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "class JsonRPCProtocol(asyncio.Protocol):\n    \"\"\"Json RPC protocol implementation using on top of `asyncio.Protocol`.\n    Specification of the protocol can be found here:\n        https://www.jsonrpc.org/specification\n    This class provides bidirectional communication which is needed for LSP.\n    \"\"\"\n    CHARSET = 'utf-8'\n    CONTENT_TYPE = 'application/vscode-jsonrpc'\n    MESSAGE_PATTERN = re.compile(\n        rb'^(?:[^\\r\\n]+\\r\\n)*'",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "LSPMeta",
        "kind": 6,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "class LSPMeta(type):\n    \"\"\"Wraps LSP built-in features (`lsp_` naming convention).\n    Built-in features cannot be overridden but user defined features with\n    the same LSP name will be called after them.\n    \"\"\"\n    def __new__(mcs, cls_name, cls_bases, cls):\n        for attr_name, attr_val in cls.items():\n            if callable(attr_val) and hasattr(attr_val, 'method_name'):\n                method_name = attr_val.method_name\n                wrapped = call_user_feature(attr_val, method_name)",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "LanguageServerProtocol",
        "kind": 6,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "class LanguageServerProtocol(JsonRPCProtocol, metaclass=LSPMeta):\n    \"\"\"A class that represents language server protocol.\n    It contains implementations for generic LSP features.\n    Attributes:\n        workspace(Workspace): In memory workspace\n    \"\"\"\n    def __init__(self, server, converter):\n        super().__init__(server, converter)\n        self.workspace = None\n        self.trace = None",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "call_user_feature",
        "kind": 2,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "def call_user_feature(base_func, method_name):\n    \"\"\"Wraps generic LSP features and calls user registered feature\n    immediately after it.\n    \"\"\"\n    @functools.wraps(base_func)\n    def decorator(self, *args, **kwargs):\n        ret_val = base_func(self, *args, **kwargs)\n        try:\n            user_func = self.fm.features[method_name]\n            self._execute_notification(user_func, *args, **kwargs)",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "default_converter",
        "kind": 2,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "def default_converter():\n    \"\"\"Default converter factory function.\"\"\"\n    converter = converters.get_converter()\n    converter.register_structure_hook(\n        JsonRPCRequestMessage, _params_field_structure_hook\n    )\n    converter.register_structure_hook(\n        JsonRPCResponseMessage, _result_field_structure_hook\n    )\n    converter.register_structure_hook(",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "lsp_method",
        "kind": 2,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "def lsp_method(method_name: str):\n    def decorator(f):\n        f.method_name = method_name\n        return f\n    return decorator\nclass LSPMeta(type):\n    \"\"\"Wraps LSP built-in features (`lsp_` naming convention).\n    Built-in features cannot be overridden but user defined features with\n    the same LSP name will be called after them.\n    \"\"\"",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "bundled.libs.pygls.protocol",
        "description": "bundled.libs.pygls.protocol",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef call_user_feature(base_func, method_name):\n    \"\"\"Wraps generic LSP features and calls user registered feature\n    immediately after it.\n    \"\"\"\n    @functools.wraps(base_func)\n    def decorator(self, *args, **kwargs):\n        ret_val = base_func(self, *args, **kwargs)\n        try:\n            user_func = self.fm.features[method_name]",
        "detail": "bundled.libs.pygls.protocol",
        "documentation": {}
    },
    {
        "label": "StdOutTransportAdapter",
        "kind": 6,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "class StdOutTransportAdapter:\n    \"\"\"Protocol adapter which overrides write method.\n    Write method sends data to stdout.\n    \"\"\"\n    def __init__(self, rfile, wfile):\n        self.rfile = rfile\n        self.wfile = wfile\n    def close(self):\n        self.rfile.close()\n        self.wfile.close()",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "PyodideTransportAdapter",
        "kind": 6,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "class PyodideTransportAdapter:\n    \"\"\"Protocol adapter which overrides write method.\n    Write method sends data to stdout.\n    \"\"\"\n    def __init__(self, wfile):\n        self.wfile = wfile\n    def close(self):\n        self.wfile.close()\n    def write(self, data):\n        self.wfile.write(data)",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "WebSocketTransportAdapter",
        "kind": 6,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "class WebSocketTransportAdapter:\n    \"\"\"Protocol adapter which calls write method.\n    Write method sends data via the WebSocket interface.\n    \"\"\"\n    def __init__(self, ws, loop):\n        self._ws = ws\n        self._loop = loop\n    def close(self) -> None:\n        \"\"\"Stop the WebSocket server.\"\"\"\n        self._ws.close()",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "Server",
        "kind": 6,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "class Server:\n    \"\"\"Class that represents async server. It can be started using TCP or IO.\n    Args:\n        protocol_cls(Protocol): Protocol implementation that must be derived\n                                from `asyncio.Protocol`\n        converter_factory: Factory function to use when constructing a cattrs converter.\n        loop(AbstractEventLoop): asyncio event loop\n        max_workers(int, optional): Number of workers for `ThreadPool` and\n                                    `ThreadPoolExecutor`\n        sync_kind(TextDocumentSyncKind): Text document synchronization option",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "LanguageServer",
        "kind": 6,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "class LanguageServer(Server):\n    \"\"\"A class that represents Language server using Language Server Protocol.\n    This class can be extended and it can be passed as a first argument to\n    registered commands/features.\n    Args:\n        name(str): Name of the server\n        version(str): Version of the server\n        protocol_cls(LanguageServerProtocol): LSP or any subclass of it\n        max_workers(int, optional): Number of workers for `ThreadPool` and\n                                    `ThreadPoolExecutor`",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "logger = logging.getLogger(__name__)\nF = TypeVar('F', bound=Callable)\nasync def aio_readline(loop, executor, stop_event, rfile, proxy):\n    \"\"\"Reads data from stdin in separate thread (asynchronously).\"\"\"\n    CONTENT_LENGTH_PATTERN = re.compile(rb'^Content-Length: (\\d+)\\r\\n$')\n    # Initialize message buffer\n    message = []\n    content_length = 0\n    while not stop_event.is_set() and not rfile.closed:\n        # Read a header line",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 5,
        "importPath": "bundled.libs.pygls.server",
        "description": "bundled.libs.pygls.server",
        "peekOfCode": "F = TypeVar('F', bound=Callable)\nasync def aio_readline(loop, executor, stop_event, rfile, proxy):\n    \"\"\"Reads data from stdin in separate thread (asynchronously).\"\"\"\n    CONTENT_LENGTH_PATTERN = re.compile(rb'^Content-Length: (\\d+)\\r\\n$')\n    # Initialize message buffer\n    message = []\n    content_length = 0\n    while not stop_event.is_set() and not rfile.closed:\n        # Read a header line\n        header = await loop.run_in_executor(executor, rfile.readline)",
        "detail": "bundled.libs.pygls.server",
        "documentation": {}
    },
    {
        "label": "from_fs_path",
        "kind": 2,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "def from_fs_path(path):\n    \"\"\"Returns a URI for the given filesystem path.\"\"\"\n    try:\n        scheme = 'file'\n        params, query, fragment = '', '', ''\n        path, netloc = _normalize_win_path(path)\n        return urlunparse((scheme, netloc, path, params, query, fragment))\n    except (AttributeError, TypeError):\n        return None\ndef to_fs_path(uri):",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "to_fs_path",
        "kind": 2,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "def to_fs_path(uri):\n    \"\"\"Returns the filesystem path of the given URI.\n    Will handle UNC paths and normalize windows drive letters to lower-case.\n    Also uses the platform specific path separator. Will *not* validate the\n    path for invalid characters and semantics.\n    Will *not* look at the scheme of this URI.\n    \"\"\"\n    try:\n        # scheme://netloc/path;parameters?query#fragment\n        scheme, netloc, path, _params, _query, _fragment = urlparse(uri)",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "uri_scheme",
        "kind": 2,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "def uri_scheme(uri):\n    try:\n        return urlparse(uri)[0]\n    except (TypeError, IndexError):\n        return None\ndef uri_with(uri, scheme=None, netloc=None, path=None, params=None, query=None, fragment=None):\n    \"\"\"Return a URI with the given part(s) replaced.\n    Parts are decoded / encoded.\n    \"\"\"\n    old_scheme, old_netloc, old_path, old_params, old_query, old_fragment = \\",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "uri_with",
        "kind": 2,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "def uri_with(uri, scheme=None, netloc=None, path=None, params=None, query=None, fragment=None):\n    \"\"\"Return a URI with the given part(s) replaced.\n    Parts are decoded / encoded.\n    \"\"\"\n    old_scheme, old_netloc, old_path, old_params, old_query, old_fragment = \\\n        urlparse(uri)\n    path, _netloc = _normalize_win_path(path)\n    return urlunparse((\n        scheme or old_scheme,\n        netloc or old_netloc,",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "kind": 2,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "def urlparse(uri):\n    \"\"\"Parse and decode the parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parse.urlparse(uri)\n    return (\n        parse.unquote(scheme),\n        parse.unquote(netloc),\n        parse.unquote(path),\n        parse.unquote(params),\n        parse.unquote(query),\n        parse.unquote(fragment)",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "urlunparse",
        "kind": 2,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "def urlunparse(parts):\n    \"\"\"Unparse and encode parts of a URI.\"\"\"\n    scheme, netloc, path, params, query, fragment = parts\n    # Avoid encoding the windows drive letter colon\n    if RE_DRIVE_LETTER_PATH.match(path):\n        quoted_path = path[:3] + parse.quote(path[3:])\n    else:\n        quoted_path = parse.quote(path)\n    return parse.urlunparse((\n        parse.quote(scheme),",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "RE_DRIVE_LETTER_PATH",
        "kind": 5,
        "importPath": "bundled.libs.pygls.uris",
        "description": "bundled.libs.pygls.uris",
        "peekOfCode": "RE_DRIVE_LETTER_PATH = re.compile(r'^\\/[a-zA-Z]:')\ndef _normalize_win_path(path):\n    netloc = ''\n    # normalize to fwd-slashes on windows,\n    # on other systems bwd-slashes are valid\n    # filename character, eg /f\\oo/ba\\r.txt\n    if IS_WIN:\n        path = path.replace('\\\\', '/')\n    # check for authority as used in UNC shares\n    # or use the path as given",
        "detail": "bundled.libs.pygls.uris",
        "documentation": {}
    },
    {
        "label": "Document",
        "kind": 6,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "class Document(object):\n    def __init__(\n        self,\n        uri: str,\n        source: Optional[str] = None,\n        version: Optional[int] = None,\n        language_id: Optional[str] = None,\n        local: bool = True,\n        sync_kind: TextDocumentSyncKind = TextDocumentSyncKind.Incremental\n    ):",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "Workspace",
        "kind": 6,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "class Workspace(object):\n    def __init__(self, root_uri, sync_kind=None, workspace_folders=None):\n        self._root_uri = root_uri\n        self._root_uri_scheme = uri_scheme(self._root_uri)\n        self._root_path = to_fs_path(self._root_uri)\n        self._sync_kind = sync_kind\n        self._folders = {}\n        self._docs = {}\n        if workspace_folders is not None:\n            for folder in workspace_folders:",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "utf16_unit_offset",
        "kind": 2,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "def utf16_unit_offset(chars: str):\n    \"\"\"Calculate the number of characters which need two utf-16 code units.\n    Arguments:\n        chars (str): The string to count occurrences of utf-16 code units for.\n    \"\"\"\n    return sum(ord(ch) > 0xFFFF for ch in chars)\ndef utf16_num_units(chars: str):\n    \"\"\"Calculate the length of `str` in utf-16 code units.\n    Arguments:\n        chars (str): The string to return the length in utf-16 code units for.",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "utf16_num_units",
        "kind": 2,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "def utf16_num_units(chars: str):\n    \"\"\"Calculate the length of `str` in utf-16 code units.\n    Arguments:\n        chars (str): The string to return the length in utf-16 code units for.\n    \"\"\"\n    return len(chars) + utf16_unit_offset(chars)\ndef position_from_utf16(lines: List[str], position: Position) -> Position:\n    \"\"\"Convert the position.character from utf-16 code units to utf-32.\n    A python application can't use the character member of `Position`\n    directly as per specification it is represented as a zero-based line and",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "position_from_utf16",
        "kind": 2,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "def position_from_utf16(lines: List[str], position: Position) -> Position:\n    \"\"\"Convert the position.character from utf-16 code units to utf-32.\n    A python application can't use the character member of `Position`\n    directly as per specification it is represented as a zero-based line and\n    character offset based on a UTF-16 string representation.\n    All characters whose code point exceeds the Basic Multilingual Plane are\n    represented by 2 UTF-16 code units.\n    The offset of the closing quotation mark in x=\"\" is\n    - 5 in UTF-16 representation\n    - 4 in UTF-32 representation",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "position_to_utf16",
        "kind": 2,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "def position_to_utf16(lines: List[str], position: Position) -> Position:\n    \"\"\"Convert the position.character from utf-32 to utf-16 code units.\n    A python application can't use the character member of `Position`\n    directly as per specification it is represented as a zero-based line and\n    character offset based on a UTF-16 string representation.\n    All characters whose code point exceeds the Basic Multilingual Plane are\n    represented by 2 UTF-16 code units.\n    The offset of the closing quotation mark in x=\"\" is\n    - 5 in UTF-16 representation\n    - 4 in UTF-32 representation",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "range_from_utf16",
        "kind": 2,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "def range_from_utf16(lines: List[str], range: Range) -> Range:\n    \"\"\"Convert range.[start|end].character from utf-16 code units to utf-32.\n    Arguments:\n        lines (list):\n            The content of the document which the range refers to.\n        range (Range):\n            The line and character offset in utf-32 code units.\n    Returns:\n        The range with `character` offsets being converted to utf-16 code units.\n    \"\"\"",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "range_to_utf16",
        "kind": 2,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "def range_to_utf16(lines: List[str], range: Range) -> Range:\n    \"\"\"Convert range.[start|end].character from utf-32 to utf-16 code units.\n    Arguments:\n        lines (list):\n            The content of the document which the range refers to.\n        range (Range):\n            The line and character offset in utf-16 code units.\n    Returns:\n        The range with `character` offsets being converted to utf-32 code units.\n    \"\"\"",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "RE_END_WORD",
        "kind": 5,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "RE_END_WORD = re.compile('^[A-Za-z_0-9]*')\nRE_START_WORD = re.compile('[A-Za-z_0-9]*$')\nlog = logging.getLogger(__name__)\ndef utf16_unit_offset(chars: str):\n    \"\"\"Calculate the number of characters which need two utf-16 code units.\n    Arguments:\n        chars (str): The string to count occurrences of utf-16 code units for.\n    \"\"\"\n    return sum(ord(ch) > 0xFFFF for ch in chars)\ndef utf16_num_units(chars: str):",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "RE_START_WORD",
        "kind": 5,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "RE_START_WORD = re.compile('[A-Za-z_0-9]*$')\nlog = logging.getLogger(__name__)\ndef utf16_unit_offset(chars: str):\n    \"\"\"Calculate the number of characters which need two utf-16 code units.\n    Arguments:\n        chars (str): The string to count occurrences of utf-16 code units for.\n    \"\"\"\n    return sum(ord(ch) > 0xFFFF for ch in chars)\ndef utf16_num_units(chars: str):\n    \"\"\"Calculate the length of `str` in utf-16 code units.",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "bundled.libs.pygls.workspace",
        "description": "bundled.libs.pygls.workspace",
        "peekOfCode": "log = logging.getLogger(__name__)\ndef utf16_unit_offset(chars: str):\n    \"\"\"Calculate the number of characters which need two utf-16 code units.\n    Arguments:\n        chars (str): The string to count occurrences of utf-16 code units for.\n    \"\"\"\n    return sum(ord(ch) > 0xFFFF for ch in chars)\ndef utf16_num_units(chars: str):\n    \"\"\"Calculate the length of `str` in utf-16 code units.\n    Arguments:",
        "detail": "bundled.libs.pygls.workspace",
        "documentation": {}
    },
    {
        "label": "TypeguardTransformer",
        "kind": 6,
        "importPath": "bundled.libs.typeguard.importhook",
        "description": "bundled.libs.typeguard.importhook",
        "peekOfCode": "class TypeguardTransformer(ast.NodeVisitor):\n    def __init__(self) -> None:\n        self._parents = []\n    def visit_Module(self, node: ast.Module):\n        # Insert \"import typeguard\" after any \"from __future__ ...\" imports\n        for i, child in enumerate(node.body):\n            if isinstance(child, ast.ImportFrom) and child.module == '__future__':\n                continue\n            elif isinstance(child, ast.Expr) and isinstance(child.value, ast.Str):\n                continue  # module docstring",
        "detail": "bundled.libs.typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "TypeguardLoader",
        "kind": 6,
        "importPath": "bundled.libs.typeguard.importhook",
        "description": "bundled.libs.typeguard.importhook",
        "peekOfCode": "class TypeguardLoader(SourceFileLoader):\n    def source_to_code(self, data, path, *, _optimize=-1):\n        source = decode_source(data)\n        tree = _call_with_frames_removed(compile, source, path, 'exec', ast.PyCF_ONLY_AST,\n                                         dont_inherit=True, optimize=_optimize)\n        tree = TypeguardTransformer().visit(tree)\n        ast.fix_missing_locations(tree)\n        return _call_with_frames_removed(compile, tree, path, 'exec',\n                                         dont_inherit=True, optimize=_optimize)\n    def exec_module(self, module):",
        "detail": "bundled.libs.typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "TypeguardFinder",
        "kind": 6,
        "importPath": "bundled.libs.typeguard.importhook",
        "description": "bundled.libs.typeguard.importhook",
        "peekOfCode": "class TypeguardFinder(MetaPathFinder):\n    \"\"\"\n    Wraps another path finder and instruments the module with ``@typechecked`` if\n    :meth:`should_instrument` returns ``True``.\n    Should not be used directly, but rather via :func:`~.install_import_hook`.\n    .. versionadded:: 2.6\n    \"\"\"\n    def __init__(self, packages, original_pathfinder):\n        self.packages = packages\n        self._original_pathfinder = original_pathfinder",
        "detail": "bundled.libs.typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "ImportHookManager",
        "kind": 6,
        "importPath": "bundled.libs.typeguard.importhook",
        "description": "bundled.libs.typeguard.importhook",
        "peekOfCode": "class ImportHookManager:\n    def __init__(self, hook: MetaPathFinder):\n        self.hook = hook\n    def __enter__(self):\n        pass\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.uninstall()\n    def uninstall(self):\n        try:\n            sys.meta_path.remove(self.hook)",
        "detail": "bundled.libs.typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "optimized_cache_from_source",
        "kind": 2,
        "importPath": "bundled.libs.typeguard.importhook",
        "description": "bundled.libs.typeguard.importhook",
        "peekOfCode": "def optimized_cache_from_source(path, debug_override=None):\n    return cache_from_source(path, debug_override, optimization='typeguard')\nclass TypeguardTransformer(ast.NodeVisitor):\n    def __init__(self) -> None:\n        self._parents = []\n    def visit_Module(self, node: ast.Module):\n        # Insert \"import typeguard\" after any \"from __future__ ...\" imports\n        for i, child in enumerate(node.body):\n            if isinstance(child, ast.ImportFrom) and child.module == '__future__':\n                continue",
        "detail": "bundled.libs.typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "install_import_hook",
        "kind": 2,
        "importPath": "bundled.libs.typeguard.importhook",
        "description": "bundled.libs.typeguard.importhook",
        "peekOfCode": "def install_import_hook(packages: Iterable[str], *,\n                        cls: Type[TypeguardFinder] = TypeguardFinder) -> ImportHookManager:\n    \"\"\"\n    Install an import hook that decorates classes and functions with ``@typechecked``.\n    This only affects modules loaded **after** this hook has been installed.\n    :return: a context manager that uninstalls the hook on exit (or when you call ``.uninstall()``)\n    .. versionadded:: 2.6\n    \"\"\"\n    if isinstance(packages, str):\n        packages = [packages]",
        "detail": "bundled.libs.typeguard.importhook",
        "documentation": {}
    },
    {
        "label": "pytest_addoption",
        "kind": 2,
        "importPath": "bundled.libs.typeguard.pytest_plugin",
        "description": "bundled.libs.typeguard.pytest_plugin",
        "peekOfCode": "def pytest_addoption(parser):\n    group = parser.getgroup('typeguard')\n    group.addoption('--typeguard-packages', action='store',\n                    help='comma separated name list of packages and modules to instrument for '\n                         'type checking')\ndef pytest_configure(config):\n    value = config.getoption(\"typeguard_packages\")\n    if not value:\n        return\n    packages = [pkg.strip() for pkg in value.split(\",\")]",
        "detail": "bundled.libs.typeguard.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "bundled.libs.typeguard.pytest_plugin",
        "description": "bundled.libs.typeguard.pytest_plugin",
        "peekOfCode": "def pytest_configure(config):\n    value = config.getoption(\"typeguard_packages\")\n    if not value:\n        return\n    packages = [pkg.strip() for pkg in value.split(\",\")]\n    already_imported_packages = sorted(\n        package for package in packages if package in sys.modules\n    )\n    if already_imported_packages:\n        message = (",
        "detail": "bundled.libs.typeguard.pytest_plugin",
        "documentation": {}
    },
    {
        "label": "update_sys_path",
        "kind": 2,
        "importPath": "bundled.tool._debug_server",
        "description": "bundled.tool._debug_server",
        "peekOfCode": "def update_sys_path(path_to_add: str) -> None:\n    \"\"\"Add given path to `sys.path`.\"\"\"\n    if path_to_add not in sys.path and os.path.isdir(path_to_add):\n        sys.path.append(path_to_add)\n# Ensure debugger is loaded before we load anything else, to debug initialization.\ndebugger_path = os.getenv(\"DEBUGPY_PATH\", None)\nif debugger_path:\n    if debugger_path.endswith(\"debugpy\"):\n        debugger_path = os.fspath(pathlib.Path(debugger_path).parent)\n    update_sys_path(debugger_path)",
        "detail": "bundled.tool._debug_server",
        "documentation": {}
    },
    {
        "label": "debugger_path",
        "kind": 5,
        "importPath": "bundled.tool._debug_server",
        "description": "bundled.tool._debug_server",
        "peekOfCode": "debugger_path = os.getenv(\"DEBUGPY_PATH\", None)\nif debugger_path:\n    if debugger_path.endswith(\"debugpy\"):\n        debugger_path = os.fspath(pathlib.Path(debugger_path).parent)\n    update_sys_path(debugger_path)\n    # pylint: disable=wrong-import-position,import-error\n    import debugpy\n    # 5678 is the default port, If you need to change it update it here\n    # and in launch.json.\n    debugpy.connect(5678)",
        "detail": "bundled.tool._debug_server",
        "documentation": {}
    },
    {
        "label": "SERVER_PATH",
        "kind": 5,
        "importPath": "bundled.tool._debug_server",
        "description": "bundled.tool._debug_server",
        "peekOfCode": "SERVER_PATH = os.fspath(pathlib.Path(__file__).parent / \"server.py\")\n# NOTE: Set breakpoint in `server.py` before continuing.\nrunpy.run_path(SERVER_PATH, run_name=\"__main__\")",
        "detail": "bundled.tool._debug_server",
        "documentation": {}
    },
    {
        "label": "StreamClosedException",
        "kind": 6,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "class StreamClosedException(Exception):\n    \"\"\"JSON RPC stream is closed.\"\"\"\n    pass  # pylint: disable=unnecessary-pass\nclass JsonWriter:\n    \"\"\"Manages writing JSON-RPC messages to the writer stream.\"\"\"\n    def __init__(self, writer: io.TextIOWrapper):\n        self._writer = writer\n        self._lock = threading.Lock()\n    def close(self):\n        \"\"\"Closes the underlying writer stream.\"\"\"",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "JsonWriter",
        "kind": 6,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "class JsonWriter:\n    \"\"\"Manages writing JSON-RPC messages to the writer stream.\"\"\"\n    def __init__(self, writer: io.TextIOWrapper):\n        self._writer = writer\n        self._lock = threading.Lock()\n    def close(self):\n        \"\"\"Closes the underlying writer stream.\"\"\"\n        with self._lock:\n            if not self._writer.closed:\n                self._writer.close()",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "JsonReader",
        "kind": 6,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "class JsonReader:\n    \"\"\"Manages reading JSON-RPC messages from stream.\"\"\"\n    def __init__(self, reader: io.TextIOWrapper):\n        self._reader = reader\n    def close(self):\n        \"\"\"Closes the underlying reader stream.\"\"\"\n        if not self._reader.closed:\n            self._reader.close()\n    def read(self):\n        \"\"\"Reads data from the stream in JSON-RPC format.\"\"\"",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "JsonRpc",
        "kind": 6,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "class JsonRpc:\n    \"\"\"Manages sending and receiving data over JSON-RPC.\"\"\"\n    def __init__(self, reader: io.TextIOWrapper, writer: io.TextIOWrapper):\n        self._reader = JsonReader(reader)\n        self._writer = JsonWriter(writer)\n    def close(self):\n        \"\"\"Closes the underlying streams.\"\"\"\n        try:\n            self._reader.close()\n        except:  # pylint: disable=bare-except",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "ProcessManager",
        "kind": 6,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "class ProcessManager:\n    \"\"\"Manages sub-processes launched for running tools.\"\"\"\n    def __init__(self):\n        self._args: Dict[str, Sequence[str]] = {}\n        self._processes: Dict[str, subprocess.Popen] = {}\n        self._rpc: Dict[str, JsonRpc] = {}\n        self._lock = threading.Lock()\n        self._thread_pool = ThreadPoolExecutor(10)\n        atexit.register(self.stop_all_processes)\n    def stop_all_processes(self):",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "RpcRunResult",
        "kind": 6,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "class RpcRunResult:\n    \"\"\"Object to hold result from running tool over RPC.\"\"\"\n    def __init__(self, stdout: str, stderr: str, exception: Optional[str] = None):\n        self.stdout: str = stdout\n        self.stderr: str = stderr\n        self.exception: Optional[str] = exception\n# pylint: disable=too-many-arguments\ndef run_over_json_rpc(\n    workspace: str,\n    interpreter: Sequence[str],",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "to_str",
        "kind": 2,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "def to_str(text) -> str:\n    \"\"\"Convert bytes to string as needed.\"\"\"\n    return text.decode(\"utf-8\") if isinstance(text, bytes) else text\nclass StreamClosedException(Exception):\n    \"\"\"JSON RPC stream is closed.\"\"\"\n    pass  # pylint: disable=unnecessary-pass\nclass JsonWriter:\n    \"\"\"Manages writing JSON-RPC messages to the writer stream.\"\"\"\n    def __init__(self, writer: io.TextIOWrapper):\n        self._writer = writer",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "create_json_rpc",
        "kind": 2,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "def create_json_rpc(readable: BinaryIO, writable: BinaryIO) -> JsonRpc:\n    \"\"\"Creates JSON-RPC wrapper for the readable and writable streams.\"\"\"\n    return JsonRpc(readable, writable)\nclass ProcessManager:\n    \"\"\"Manages sub-processes launched for running tools.\"\"\"\n    def __init__(self):\n        self._args: Dict[str, Sequence[str]] = {}\n        self._processes: Dict[str, subprocess.Popen] = {}\n        self._rpc: Dict[str, JsonRpc] = {}\n        self._lock = threading.Lock()",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "get_or_start_json_rpc",
        "kind": 2,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "def get_or_start_json_rpc(\n    workspace: str, interpreter: Sequence[str], cwd: str\n) -> Union[JsonRpc, None]:\n    \"\"\"Gets an existing JSON-RPC connection or starts one and return it.\"\"\"\n    res = _get_json_rpc(workspace)\n    if not res:\n        args = [*interpreter, RUNNER_SCRIPT]\n        _process_manager.start_process(workspace, args, cwd)\n        res = _get_json_rpc(workspace)\n    return res",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "run_over_json_rpc",
        "kind": 2,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "def run_over_json_rpc(\n    workspace: str,\n    interpreter: Sequence[str],\n    module: str,\n    argv: Sequence[str],\n    use_stdin: bool,\n    cwd: str,\n    source: str = None,\n) -> RpcRunResult:\n    \"\"\"Uses JSON-RPC to execute a command.\"\"\"",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "shutdown_json_rpc",
        "kind": 2,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "def shutdown_json_rpc():\n    \"\"\"Shutdown all JSON-RPC processes.\"\"\"\n    _process_manager.stop_all_processes()",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "CONTENT_LENGTH",
        "kind": 5,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "CONTENT_LENGTH = \"Content-Length: \"\nRUNNER_SCRIPT = str(pathlib.Path(__file__).parent / \"runner.py\")\ndef to_str(text) -> str:\n    \"\"\"Convert bytes to string as needed.\"\"\"\n    return text.decode(\"utf-8\") if isinstance(text, bytes) else text\nclass StreamClosedException(Exception):\n    \"\"\"JSON RPC stream is closed.\"\"\"\n    pass  # pylint: disable=unnecessary-pass\nclass JsonWriter:\n    \"\"\"Manages writing JSON-RPC messages to the writer stream.\"\"\"",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "RUNNER_SCRIPT",
        "kind": 5,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "RUNNER_SCRIPT = str(pathlib.Path(__file__).parent / \"runner.py\")\ndef to_str(text) -> str:\n    \"\"\"Convert bytes to string as needed.\"\"\"\n    return text.decode(\"utf-8\") if isinstance(text, bytes) else text\nclass StreamClosedException(Exception):\n    \"\"\"JSON RPC stream is closed.\"\"\"\n    pass  # pylint: disable=unnecessary-pass\nclass JsonWriter:\n    \"\"\"Manages writing JSON-RPC messages to the writer stream.\"\"\"\n    def __init__(self, writer: io.TextIOWrapper):",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "_process_manager",
        "kind": 5,
        "importPath": "bundled.tool.jsonrpc",
        "description": "bundled.tool.jsonrpc",
        "peekOfCode": "_process_manager = ProcessManager()\ndef _get_json_rpc(workspace: str) -> Union[JsonRpc, None]:\n    try:\n        return _process_manager.get_json_rpc(workspace)\n    except StreamClosedException:\n        return None\n    except KeyError:\n        return None\ndef get_or_start_json_rpc(\n    workspace: str, interpreter: Sequence[str], cwd: str",
        "detail": "bundled.tool.jsonrpc",
        "documentation": {}
    },
    {
        "label": "update_sys_path",
        "kind": 2,
        "importPath": "bundled.tool.runner",
        "description": "bundled.tool.runner",
        "peekOfCode": "def update_sys_path(path_to_add: str, strategy: str) -> None:\n    \"\"\"Add given path to `sys.path`.\"\"\"\n    if path_to_add not in sys.path and os.path.isdir(path_to_add):\n        if strategy == \"useBundled\":\n            sys.path.insert(0, path_to_add)\n        elif strategy == \"fromEnvironment\":\n            sys.path.append(path_to_add)\n# Ensure that we can import LSP libraries, and other bundled libraries.\nupdate_sys_path(\n    os.fspath(pathlib.Path(__file__).parent.parent / \"libs\"),",
        "detail": "bundled.tool.runner",
        "documentation": {}
    },
    {
        "label": "RPC",
        "kind": 5,
        "importPath": "bundled.tool.runner",
        "description": "bundled.tool.runner",
        "peekOfCode": "RPC = jsonrpc.create_json_rpc(sys.stdin.buffer, sys.stdout.buffer)\nEXIT_NOW = False\nwhile not EXIT_NOW:\n    msg = RPC.receive_data()\n    method = msg[\"method\"]\n    if method == \"exit\":\n        EXIT_NOW = True\n        continue\n    if method == \"run\":\n        is_exception = False",
        "detail": "bundled.tool.runner",
        "documentation": {}
    },
    {
        "label": "EXIT_NOW",
        "kind": 5,
        "importPath": "bundled.tool.runner",
        "description": "bundled.tool.runner",
        "peekOfCode": "EXIT_NOW = False\nwhile not EXIT_NOW:\n    msg = RPC.receive_data()\n    method = msg[\"method\"]\n    if method == \"exit\":\n        EXIT_NOW = True\n        continue\n    if method == \"run\":\n        is_exception = False\n        # This is needed to preserve sys.path, pylint modifies",
        "detail": "bundled.tool.runner",
        "documentation": {}
    },
    {
        "label": "update_sys_path",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def update_sys_path(path_to_add: str, strategy: str) -> None:\n    \"\"\"Add given path to `sys.path`.\"\"\"\n    if path_to_add not in sys.path and os.path.isdir(path_to_add):\n        if strategy == \"useBundled\":\n            sys.path.insert(0, path_to_add)\n        elif strategy == \"fromEnvironment\":\n            sys.path.append(path_to_add)\n# Ensure that we can import LSP libraries, and other bundled libraries.\nupdate_sys_path(\n    os.fspath(pathlib.Path(__file__).parent.parent / \"libs\"),",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "did_open",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def did_open(params: lsp.DidOpenTextDocumentParams) -> None:\n    \"\"\"LSP handler for textDocument/didOpen request.\"\"\"\n    document = LSP_SERVER.workspace.get_document(params.text_document.uri)\n    diagnostics: list[lsp.Diagnostic] = _linting_helper(document)\n    LSP_SERVER.publish_diagnostics(document.uri, diagnostics)\n@LSP_SERVER.feature(lsp.TEXT_DOCUMENT_DID_SAVE)\ndef did_save(params: lsp.DidSaveTextDocumentParams) -> None:\n    \"\"\"LSP handler for textDocument/didSave request.\"\"\"\n    document = LSP_SERVER.workspace.get_document(params.text_document.uri)\n    diagnostics: list[lsp.Diagnostic] = _linting_helper(document)",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "did_save",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def did_save(params: lsp.DidSaveTextDocumentParams) -> None:\n    \"\"\"LSP handler for textDocument/didSave request.\"\"\"\n    document = LSP_SERVER.workspace.get_document(params.text_document.uri)\n    diagnostics: list[lsp.Diagnostic] = _linting_helper(document)\n    LSP_SERVER.publish_diagnostics(document.uri, diagnostics)\n@LSP_SERVER.feature(lsp.TEXT_DOCUMENT_DID_CLOSE)\ndef did_close(params: lsp.DidCloseTextDocumentParams) -> None:\n    \"\"\"LSP handler for textDocument/didClose request.\"\"\"\n    document = LSP_SERVER.workspace.get_document(params.text_document.uri)\n    # Publishing empty diagnostics to clear the entries for this file.",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "did_close",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def did_close(params: lsp.DidCloseTextDocumentParams) -> None:\n    \"\"\"LSP handler for textDocument/didClose request.\"\"\"\n    document = LSP_SERVER.workspace.get_document(params.text_document.uri)\n    # Publishing empty diagnostics to clear the entries for this file.\n    LSP_SERVER.publish_diagnostics(document.uri, [])\ndef _linting_helper(document: workspace.Document) -> list[lsp.Diagnostic]:\n    # TODO: Determine if your tool supports passing file content via stdin.\n    # If you want to support linting on change then your tool will need to\n    # support linting over stdin to be effective. Read, and update\n    # _run_tool_on_document and _run_tool functions as needed for your project.",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "formatting",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def formatting(params: lsp.DocumentFormattingParams) -> list[lsp.TextEdit] | None:\n    \"\"\"LSP handler for textDocument/formatting request.\"\"\"\n    # If your tool is a formatter you can use this handler to provide\n    # formatting support on save. You have to return an array of lsp.TextEdit\n    # objects, to provide your formatted results.\n    document = LSP_SERVER.workspace.get_document(params.text_document.uri)\n    edits = _formatting_helper(document)\n    if edits:\n        return edits\n    # NOTE: If you provide [] array, VS Code will clear the file of all contents.",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def initialize(params: lsp.InitializeParams) -> None:\n    \"\"\"LSP handler for initialize request.\"\"\"\n    log_to_output(f\"CWD Server: {os.getcwd()}\")\n    paths = \"\\r\\n   \".join(sys.path)\n    log_to_output(f\"sys.path used to run Server:\\r\\n   {paths}\")\n    settings = params.initialization_options[\"settings\"]\n    _update_workspace_settings(settings)\n    log_to_output(\n        f\"Settings used to run Server:\\r\\n{json.dumps(settings, indent=4, ensure_ascii=False)}\\r\\n\"\n    )",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "on_exit",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def on_exit():\n    \"\"\"Handle clean up on exit.\"\"\"\n    jsonrpc.shutdown_json_rpc()\n# *****************************************************\n# Internal functional and settings management APIs.\n# *****************************************************\ndef _update_workspace_settings(settings):\n    for setting in settings:\n        key = uris.to_fs_path(setting[\"workspace\"])\n        WORKSPACE_SETTINGS[key] = {",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "log_to_output",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def log_to_output(\n    message: str, msg_type: lsp.MessageType = lsp.MessageType.Log\n) -> None:\n    LSP_SERVER.show_message_log(message, msg_type)\ndef log_error(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Error)\n    if os.getenv(\"LS_SHOW_NOTIFICATION\", \"off\") in [\"onError\", \"onWarning\", \"always\"]:\n        LSP_SERVER.show_message(message, lsp.MessageType.Error)\ndef log_warning(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Warning)",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "log_error",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def log_error(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Error)\n    if os.getenv(\"LS_SHOW_NOTIFICATION\", \"off\") in [\"onError\", \"onWarning\", \"always\"]:\n        LSP_SERVER.show_message(message, lsp.MessageType.Error)\ndef log_warning(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Warning)\n    if os.getenv(\"LS_SHOW_NOTIFICATION\", \"off\") in [\"onWarning\", \"always\"]:\n        LSP_SERVER.show_message(message, lsp.MessageType.Warning)\ndef log_always(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Info)",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "log_warning",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def log_warning(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Warning)\n    if os.getenv(\"LS_SHOW_NOTIFICATION\", \"off\") in [\"onWarning\", \"always\"]:\n        LSP_SERVER.show_message(message, lsp.MessageType.Warning)\ndef log_always(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Info)\n    if os.getenv(\"LS_SHOW_NOTIFICATION\", \"off\") in [\"always\"]:\n        LSP_SERVER.show_message(message, lsp.MessageType.Info)\n# *****************************************************\n# Start the server.",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "log_always",
        "kind": 2,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "def log_always(message: str) -> None:\n    LSP_SERVER.show_message_log(message, lsp.MessageType.Info)\n    if os.getenv(\"LS_SHOW_NOTIFICATION\", \"off\") in [\"always\"]:\n        LSP_SERVER.show_message(message, lsp.MessageType.Info)\n# *****************************************************\n# Start the server.\n# *****************************************************\nif __name__ == \"__main__\":\n    LSP_SERVER.start_io()",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "WORKSPACE_SETTINGS",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "WORKSPACE_SETTINGS = {}\nRUNNER = pathlib.Path(__file__).parent / \"runner.py\"\nMAX_WORKERS = 5\n# TODO: Update the language server name and version.\nLSP_SERVER = server.LanguageServer(name=\"StoryGraph\", version=\"<server version>\", max_workers=MAX_WORKERS)\n# **********************************************************\n# Tool specific code goes below this.\n# **********************************************************\n# Reference:\n#  LS Protocol:",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "RUNNER",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "RUNNER = pathlib.Path(__file__).parent / \"runner.py\"\nMAX_WORKERS = 5\n# TODO: Update the language server name and version.\nLSP_SERVER = server.LanguageServer(name=\"StoryGraph\", version=\"<server version>\", max_workers=MAX_WORKERS)\n# **********************************************************\n# Tool specific code goes below this.\n# **********************************************************\n# Reference:\n#  LS Protocol:\n#  https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "MAX_WORKERS",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "MAX_WORKERS = 5\n# TODO: Update the language server name and version.\nLSP_SERVER = server.LanguageServer(name=\"StoryGraph\", version=\"<server version>\", max_workers=MAX_WORKERS)\n# **********************************************************\n# Tool specific code goes below this.\n# **********************************************************\n# Reference:\n#  LS Protocol:\n#  https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/\n#",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "LSP_SERVER",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "LSP_SERVER = server.LanguageServer(name=\"StoryGraph\", version=\"<server version>\", max_workers=MAX_WORKERS)\n# **********************************************************\n# Tool specific code goes below this.\n# **********************************************************\n# Reference:\n#  LS Protocol:\n#  https://microsoft.github.io/language-server-protocol/specifications/specification-3-16/\n#\n#  Sample implementations:\n#  Pylint: https://github.com/microsoft/vscode-pylint/blob/main/bundled/tool",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "TOOL_MODULE",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "TOOL_MODULE = \"storygraph\"\n# TODO: Update TOOL_DISPLAY with a display name for your tool.\n# e.g, TOOL_DISPLAY = \"Pylint\"\nTOOL_DISPLAY = \"StoryGraph\"\n# TODO: Update TOOL_ARGS with default argument you have to pass to your tool in\n# all scenarios.\nTOOL_ARGS = []  # default arguments always passed to your tool.\n# TODO: If your tool is a linter then update this section.\n# Delete \"Linting features\" section if your tool is NOT a linter.\n# **********************************************************",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "TOOL_DISPLAY",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "TOOL_DISPLAY = \"StoryGraph\"\n# TODO: Update TOOL_ARGS with default argument you have to pass to your tool in\n# all scenarios.\nTOOL_ARGS = []  # default arguments always passed to your tool.\n# TODO: If your tool is a linter then update this section.\n# Delete \"Linting features\" section if your tool is NOT a linter.\n# **********************************************************\n# Linting features start here\n# **********************************************************\n#  See `pylint` implementation for a full featured linter extension:",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "TOOL_ARGS",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "TOOL_ARGS = []  # default arguments always passed to your tool.\n# TODO: If your tool is a linter then update this section.\n# Delete \"Linting features\" section if your tool is NOT a linter.\n# **********************************************************\n# Linting features start here\n# **********************************************************\n#  See `pylint` implementation for a full featured linter extension:\n#  Pylint: https://github.com/microsoft/vscode-pylint/blob/main/bundled/tool\n@LSP_SERVER.feature(lsp.TEXT_DOCUMENT_DID_OPEN)\ndef did_open(params: lsp.DidOpenTextDocumentParams) -> None:",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "DIAGNOSTIC_RE",
        "kind": 5,
        "importPath": "bundled.tool.server",
        "description": "bundled.tool.server",
        "peekOfCode": "DIAGNOSTIC_RE = re.compile(r\"\")\ndef _parse_output_using_regex(content: str) -> list[lsp.Diagnostic]:\n    lines: list[str] = content.splitlines()\n    diagnostics: list[lsp.Diagnostic] = []\n    # TODO: Determine if your linter reports line numbers starting at 1 (True) or 0 (False).\n    line_at_1 = True\n    # TODO: Determine if your linter reports column numbers starting at 1 (True) or 0 (False).\n    column_at_1 = True\n    line_offset = 1 if line_at_1 else 0\n    col_offset = 1 if column_at_1 else 0",
        "detail": "bundled.tool.server",
        "documentation": {}
    },
    {
        "label": "RunResult",
        "kind": 6,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "class RunResult:\n    \"\"\"Object to hold result from running tool.\"\"\"\n    def __init__(self, stdout: str, stderr: str):\n        self.stdout: str = stdout\n        self.stderr: str = stderr\nclass CustomIO(io.TextIOWrapper):\n    \"\"\"Custom stream object to replace stdio.\"\"\"\n    name = None\n    def __init__(self, name, encoding=\"utf-8\", newline=None):\n        self._buffer = io.BytesIO()",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "CustomIO",
        "kind": 6,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "class CustomIO(io.TextIOWrapper):\n    \"\"\"Custom stream object to replace stdio.\"\"\"\n    name = None\n    def __init__(self, name, encoding=\"utf-8\", newline=None):\n        self._buffer = io.BytesIO()\n        self._buffer.name = name\n        super().__init__(self._buffer, encoding=encoding, newline=newline)\n    def close(self):\n        \"\"\"Provide this close method which is used by some tools.\"\"\"\n        # This is intentionally empty.",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "as_list",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def as_list(content: Union[Any, List[Any], Tuple[Any]]) -> Union[List[Any], Tuple[Any]]:\n    \"\"\"Ensures we always get a list\"\"\"\n    if isinstance(content, (list, tuple)):\n        return content\n    return [content]\n# pylint: disable-next=consider-using-generator\n_site_paths = tuple(\n    [\n        os.path.normcase(os.path.normpath(p))\n        for p in (as_list(site.getsitepackages()) + as_list(site.getusersitepackages()))",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "is_same_path",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def is_same_path(file_path1, file_path2) -> bool:\n    \"\"\"Returns true if two paths are the same.\"\"\"\n    return os.path.normcase(os.path.normpath(file_path1)) == os.path.normcase(\n        os.path.normpath(file_path2)\n    )\ndef is_current_interpreter(executable) -> bool:\n    \"\"\"Returns true if the executable path is same as the current interpreter.\"\"\"\n    return is_same_path(executable, sys.executable)\ndef is_stdlib_file(file_path) -> bool:\n    \"\"\"Return True if the file belongs to standard library.\"\"\"",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "is_current_interpreter",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def is_current_interpreter(executable) -> bool:\n    \"\"\"Returns true if the executable path is same as the current interpreter.\"\"\"\n    return is_same_path(executable, sys.executable)\ndef is_stdlib_file(file_path) -> bool:\n    \"\"\"Return True if the file belongs to standard library.\"\"\"\n    return os.path.normcase(os.path.normpath(file_path)).startswith(_site_paths)\n# pylint: disable-next=too-few-public-methods\nclass RunResult:\n    \"\"\"Object to hold result from running tool.\"\"\"\n    def __init__(self, stdout: str, stderr: str):",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "is_stdlib_file",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def is_stdlib_file(file_path) -> bool:\n    \"\"\"Return True if the file belongs to standard library.\"\"\"\n    return os.path.normcase(os.path.normpath(file_path)).startswith(_site_paths)\n# pylint: disable-next=too-few-public-methods\nclass RunResult:\n    \"\"\"Object to hold result from running tool.\"\"\"\n    def __init__(self, stdout: str, stderr: str):\n        self.stdout: str = stdout\n        self.stderr: str = stderr\nclass CustomIO(io.TextIOWrapper):",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "substitute_attr",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def substitute_attr(obj: Any, attribute: str, new_value: Any):\n    \"\"\"Manage object attributes context when using runpy.run_module().\"\"\"\n    old_value = getattr(obj, attribute)\n    setattr(obj, attribute, new_value)\n    yield\n    setattr(obj, attribute, old_value)\n@contextlib.contextmanager\ndef redirect_io(stream: str, new_stream):\n    \"\"\"Redirect stdio streams to a custom stream.\"\"\"\n    old_stream = getattr(sys, stream)",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "redirect_io",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def redirect_io(stream: str, new_stream):\n    \"\"\"Redirect stdio streams to a custom stream.\"\"\"\n    old_stream = getattr(sys, stream)\n    setattr(sys, stream, new_stream)\n    yield\n    setattr(sys, stream, old_stream)\n@contextlib.contextmanager\ndef change_cwd(new_cwd):\n    \"\"\"Change working directory before running code.\"\"\"\n    os.chdir(new_cwd)",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "change_cwd",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def change_cwd(new_cwd):\n    \"\"\"Change working directory before running code.\"\"\"\n    os.chdir(new_cwd)\n    yield\n    os.chdir(SERVER_CWD)\ndef _run_module(\n    module: str, argv: Sequence[str], use_stdin: bool, source: str = None\n) -> RunResult:\n    \"\"\"Runs as a module.\"\"\"\n    str_output = CustomIO(\"<stdout>\", encoding=\"utf-8\")",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "run_module",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def run_module(\n    module: str, argv: Sequence[str], use_stdin: bool, cwd: str, source: str = None\n) -> RunResult:\n    \"\"\"Runs as a module.\"\"\"\n    with CWD_LOCK:\n        if is_same_path(os.getcwd(), cwd):\n            return _run_module(module, argv, use_stdin, source)\n        with change_cwd(cwd):\n            return _run_module(module, argv, use_stdin, source)\ndef run_path(",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "run_path",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def run_path(\n    argv: Sequence[str], use_stdin: bool, cwd: str, source: str = None\n) -> RunResult:\n    \"\"\"Runs as an executable.\"\"\"\n    if use_stdin:\n        with subprocess.Popen(\n            argv,\n            encoding=\"utf-8\",\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "run_api",
        "kind": 2,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "def run_api(\n    callback: Callable[[Sequence[str], CustomIO, CustomIO, CustomIO | None], None],\n    argv: Sequence[str],\n    use_stdin: bool,\n    cwd: str,\n    source: str = None,\n) -> RunResult:\n    \"\"\"Run a API.\"\"\"\n    with CWD_LOCK:\n        if is_same_path(os.getcwd(), cwd):",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "SERVER_CWD",
        "kind": 5,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "SERVER_CWD = os.getcwd()\nCWD_LOCK = threading.Lock()\ndef as_list(content: Union[Any, List[Any], Tuple[Any]]) -> Union[List[Any], Tuple[Any]]:\n    \"\"\"Ensures we always get a list\"\"\"\n    if isinstance(content, (list, tuple)):\n        return content\n    return [content]\n# pylint: disable-next=consider-using-generator\n_site_paths = tuple(\n    [",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "CWD_LOCK",
        "kind": 5,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "CWD_LOCK = threading.Lock()\ndef as_list(content: Union[Any, List[Any], Tuple[Any]]) -> Union[List[Any], Tuple[Any]]:\n    \"\"\"Ensures we always get a list\"\"\"\n    if isinstance(content, (list, tuple)):\n        return content\n    return [content]\n# pylint: disable-next=consider-using-generator\n_site_paths = tuple(\n    [\n        os.path.normcase(os.path.normpath(p))",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "_site_paths",
        "kind": 5,
        "importPath": "bundled.tool.utils",
        "description": "bundled.tool.utils",
        "peekOfCode": "_site_paths = tuple(\n    [\n        os.path.normcase(os.path.normpath(p))\n        for p in (as_list(site.getsitepackages()) + as_list(site.getusersitepackages()))\n    ]\n)\ndef is_same_path(file_path1, file_path2) -> bool:\n    \"\"\"Returns true if two paths are the same.\"\"\"\n    return os.path.normcase(os.path.normpath(file_path1)) == os.path.normcase(\n        os.path.normpath(file_path2)",
        "detail": "bundled.tool.utils",
        "documentation": {}
    },
    {
        "label": "TEST_ROOT",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.constants",
        "description": "src.test.python_tests.lsp_test_client.constants",
        "peekOfCode": "TEST_ROOT = pathlib.Path(__file__).parent.parent\nPROJECT_ROOT = TEST_ROOT.parent.parent.parent\nTEST_DATA = TEST_ROOT / \"test_data\"",
        "detail": "src.test.python_tests.lsp_test_client.constants",
        "documentation": {}
    },
    {
        "label": "PROJECT_ROOT",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.constants",
        "description": "src.test.python_tests.lsp_test_client.constants",
        "peekOfCode": "PROJECT_ROOT = TEST_ROOT.parent.parent.parent\nTEST_DATA = TEST_ROOT / \"test_data\"",
        "detail": "src.test.python_tests.lsp_test_client.constants",
        "documentation": {}
    },
    {
        "label": "TEST_DATA",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.constants",
        "description": "src.test.python_tests.lsp_test_client.constants",
        "peekOfCode": "TEST_DATA = TEST_ROOT / \"test_data\"",
        "detail": "src.test.python_tests.lsp_test_client.constants",
        "documentation": {}
    },
    {
        "label": "VSCODE_DEFAULT_INITIALIZE",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.defaults",
        "description": "src.test.python_tests.lsp_test_client.defaults",
        "peekOfCode": "VSCODE_DEFAULT_INITIALIZE = {\n    \"processId\": os.getpid(),\n    \"clientInfo\": {\"name\": \"vscode\", \"version\": \"1.45.0\"},\n    \"rootPath\": str(PROJECT_ROOT),\n    \"rootUri\": as_uri(str(PROJECT_ROOT)),\n    \"capabilities\": {\n        \"workspace\": {\n            \"applyEdit\": True,\n            \"workspaceEdit\": {\n                \"documentChanges\": True,",
        "detail": "src.test.python_tests.lsp_test_client.defaults",
        "documentation": {}
    },
    {
        "label": "LspSession",
        "kind": 6,
        "importPath": "src.test.python_tests.lsp_test_client.session",
        "description": "src.test.python_tests.lsp_test_client.session",
        "peekOfCode": "class LspSession(MethodDispatcher):\n    \"\"\"Send and Receive messages over LSP as a test LS Client.\"\"\"\n    def __init__(self, cwd=None, script=None):\n        self.cwd = cwd if cwd else os.getcwd()\n        # pylint: disable=consider-using-with\n        self._thread_pool = ThreadPoolExecutor()\n        self._sub = None\n        self._writer = None\n        self._reader = None\n        self._endpoint = None",
        "detail": "src.test.python_tests.lsp_test_client.session",
        "documentation": {}
    },
    {
        "label": "LSP_EXIT_TIMEOUT",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.session",
        "description": "src.test.python_tests.lsp_test_client.session",
        "peekOfCode": "LSP_EXIT_TIMEOUT = 5000\nPUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\n# pylint: disable=too-many-instance-attributes\nclass LspSession(MethodDispatcher):\n    \"\"\"Send and Receive messages over LSP as a test LS Client.\"\"\"\n    def __init__(self, cwd=None, script=None):\n        self.cwd = cwd if cwd else os.getcwd()\n        # pylint: disable=consider-using-with",
        "detail": "src.test.python_tests.lsp_test_client.session",
        "documentation": {}
    },
    {
        "label": "PUBLISH_DIAGNOSTICS",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.session",
        "description": "src.test.python_tests.lsp_test_client.session",
        "peekOfCode": "PUBLISH_DIAGNOSTICS = \"textDocument/publishDiagnostics\"\nWINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\n# pylint: disable=too-many-instance-attributes\nclass LspSession(MethodDispatcher):\n    \"\"\"Send and Receive messages over LSP as a test LS Client.\"\"\"\n    def __init__(self, cwd=None, script=None):\n        self.cwd = cwd if cwd else os.getcwd()\n        # pylint: disable=consider-using-with\n        self._thread_pool = ThreadPoolExecutor()",
        "detail": "src.test.python_tests.lsp_test_client.session",
        "documentation": {}
    },
    {
        "label": "WINDOW_LOG_MESSAGE",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.session",
        "description": "src.test.python_tests.lsp_test_client.session",
        "peekOfCode": "WINDOW_LOG_MESSAGE = \"window/logMessage\"\nWINDOW_SHOW_MESSAGE = \"window/showMessage\"\n# pylint: disable=too-many-instance-attributes\nclass LspSession(MethodDispatcher):\n    \"\"\"Send and Receive messages over LSP as a test LS Client.\"\"\"\n    def __init__(self, cwd=None, script=None):\n        self.cwd = cwd if cwd else os.getcwd()\n        # pylint: disable=consider-using-with\n        self._thread_pool = ThreadPoolExecutor()\n        self._sub = None",
        "detail": "src.test.python_tests.lsp_test_client.session",
        "documentation": {}
    },
    {
        "label": "WINDOW_SHOW_MESSAGE",
        "kind": 5,
        "importPath": "src.test.python_tests.lsp_test_client.session",
        "description": "src.test.python_tests.lsp_test_client.session",
        "peekOfCode": "WINDOW_SHOW_MESSAGE = \"window/showMessage\"\n# pylint: disable=too-many-instance-attributes\nclass LspSession(MethodDispatcher):\n    \"\"\"Send and Receive messages over LSP as a test LS Client.\"\"\"\n    def __init__(self, cwd=None, script=None):\n        self.cwd = cwd if cwd else os.getcwd()\n        # pylint: disable=consider-using-with\n        self._thread_pool = ThreadPoolExecutor()\n        self._sub = None\n        self._writer = None",
        "detail": "src.test.python_tests.lsp_test_client.session",
        "documentation": {}
    },
    {
        "label": "PythonFile",
        "kind": 6,
        "importPath": "src.test.python_tests.lsp_test_client.utils",
        "description": "src.test.python_tests.lsp_test_client.utils",
        "peekOfCode": "class PythonFile:\n    \"\"\"Create python file on demand for testing.\"\"\"\n    def __init__(self, contents, root):\n        self.contents = contents\n        self.basename = \"\".join(\n            choice(\"abcdefghijklmnopqrstuvwxyz\") if i < 8 else \".py\" for i in range(9)\n        )\n        self.fullpath = os.path.join(root, self.basename)\n    def __enter__(self):\n        \"\"\"Creates a python file for  testing.\"\"\"",
        "detail": "src.test.python_tests.lsp_test_client.utils",
        "documentation": {}
    },
    {
        "label": "normalizecase",
        "kind": 2,
        "importPath": "src.test.python_tests.lsp_test_client.utils",
        "description": "src.test.python_tests.lsp_test_client.utils",
        "peekOfCode": "def normalizecase(path: str) -> str:\n    \"\"\"Fixes 'file' uri or path case for easier testing in windows.\"\"\"\n    if platform.system() == \"Windows\":\n        return path.lower()\n    return path\ndef as_uri(path: str) -> str:\n    \"\"\"Return 'file' uri as string.\"\"\"\n    return normalizecase(pathlib.Path(path).as_uri())\nclass PythonFile:\n    \"\"\"Create python file on demand for testing.\"\"\"",
        "detail": "src.test.python_tests.lsp_test_client.utils",
        "documentation": {}
    },
    {
        "label": "as_uri",
        "kind": 2,
        "importPath": "src.test.python_tests.lsp_test_client.utils",
        "description": "src.test.python_tests.lsp_test_client.utils",
        "peekOfCode": "def as_uri(path: str) -> str:\n    \"\"\"Return 'file' uri as string.\"\"\"\n    return normalizecase(pathlib.Path(path).as_uri())\nclass PythonFile:\n    \"\"\"Create python file on demand for testing.\"\"\"\n    def __init__(self, contents, root):\n        self.contents = contents\n        self.basename = \"\".join(\n            choice(\"abcdefghijklmnopqrstuvwxyz\") if i < 8 else \".py\" for i in range(9)\n        )",
        "detail": "src.test.python_tests.lsp_test_client.utils",
        "documentation": {}
    },
    {
        "label": "get_server_info_defaults",
        "kind": 2,
        "importPath": "src.test.python_tests.lsp_test_client.utils",
        "description": "src.test.python_tests.lsp_test_client.utils",
        "peekOfCode": "def get_server_info_defaults():\n    \"\"\"Returns server info from package.json\"\"\"\n    package_json_path = PROJECT_ROOT / \"package.json\"\n    package_json = json.loads(package_json_path.read_text())\n    return package_json[\"serverInfo\"]\ndef get_initialization_options():\n    \"\"\"Returns initialization options from package.json\"\"\"\n    package_json_path = PROJECT_ROOT / \"package.json\"\n    package_json = json.loads(package_json_path.read_text())\n    server_info = package_json[\"serverInfo\"]",
        "detail": "src.test.python_tests.lsp_test_client.utils",
        "documentation": {}
    },
    {
        "label": "get_initialization_options",
        "kind": 2,
        "importPath": "src.test.python_tests.lsp_test_client.utils",
        "description": "src.test.python_tests.lsp_test_client.utils",
        "peekOfCode": "def get_initialization_options():\n    \"\"\"Returns initialization options from package.json\"\"\"\n    package_json_path = PROJECT_ROOT / \"package.json\"\n    package_json = json.loads(package_json_path.read_text())\n    server_info = package_json[\"serverInfo\"]\n    server_id = server_info[\"module\"]\n    properties = package_json[\"contributes\"][\"configuration\"][\"properties\"]\n    setting = {}\n    for prop in properties:\n        name = prop[len(server_id) + 1 :]",
        "detail": "src.test.python_tests.lsp_test_client.utils",
        "documentation": {}
    },
    {
        "label": "test_linting_example",
        "kind": 2,
        "importPath": "src.test.python_tests.test_server",
        "description": "src.test.python_tests.test_server",
        "peekOfCode": "def test_linting_example():\n    \"\"\"Test to linting on file open.\"\"\"\n    contents = TEST_FILE_PATH.read_text()\n    actual = []\n    with session.LspSession() as ls_session:\n        ls_session.initialize(defaults.VSCODE_DEFAULT_INITIALIZE)\n        done = Event()\n        def _handler(params):\n            nonlocal actual\n            actual = params",
        "detail": "src.test.python_tests.test_server",
        "documentation": {}
    },
    {
        "label": "test_formatting_example",
        "kind": 2,
        "importPath": "src.test.python_tests.test_server",
        "description": "src.test.python_tests.test_server",
        "peekOfCode": "def test_formatting_example():\n    \"\"\"Test formatting a python file.\"\"\"\n    FORMATTED_TEST_FILE_PATH = constants.TEST_DATA / \"sample1\" / \"sample.py\"\n    UNFORMATTED_TEST_FILE_PATH = constants.TEST_DATA / \"sample1\" / \"sample.unformatted\"\n    contents = UNFORMATTED_TEST_FILE_PATH.read_text()\n    lines = contents.splitlines(keepends=False)\n    actual = []\n    with utils.python_file(contents, UNFORMATTED_TEST_FILE_PATH.parent) as pf:\n        uri = utils.as_uri(str(pf))\n        with session.LspSession() as ls_session:",
        "detail": "src.test.python_tests.test_server",
        "documentation": {}
    },
    {
        "label": "TEST_FILE_PATH",
        "kind": 5,
        "importPath": "src.test.python_tests.test_server",
        "description": "src.test.python_tests.test_server",
        "peekOfCode": "TEST_FILE_PATH = constants.TEST_DATA / \"sample1\" / \"sample.py\"\nTEST_FILE_URI = utils.as_uri(str(TEST_FILE_PATH))\nSERVER_INFO = utils.get_server_info_defaults()\nTIMEOUT = 10  # 10 seconds\ndef test_linting_example():\n    \"\"\"Test to linting on file open.\"\"\"\n    contents = TEST_FILE_PATH.read_text()\n    actual = []\n    with session.LspSession() as ls_session:\n        ls_session.initialize(defaults.VSCODE_DEFAULT_INITIALIZE)",
        "detail": "src.test.python_tests.test_server",
        "documentation": {}
    },
    {
        "label": "TEST_FILE_URI",
        "kind": 5,
        "importPath": "src.test.python_tests.test_server",
        "description": "src.test.python_tests.test_server",
        "peekOfCode": "TEST_FILE_URI = utils.as_uri(str(TEST_FILE_PATH))\nSERVER_INFO = utils.get_server_info_defaults()\nTIMEOUT = 10  # 10 seconds\ndef test_linting_example():\n    \"\"\"Test to linting on file open.\"\"\"\n    contents = TEST_FILE_PATH.read_text()\n    actual = []\n    with session.LspSession() as ls_session:\n        ls_session.initialize(defaults.VSCODE_DEFAULT_INITIALIZE)\n        done = Event()",
        "detail": "src.test.python_tests.test_server",
        "documentation": {}
    },
    {
        "label": "SERVER_INFO",
        "kind": 5,
        "importPath": "src.test.python_tests.test_server",
        "description": "src.test.python_tests.test_server",
        "peekOfCode": "SERVER_INFO = utils.get_server_info_defaults()\nTIMEOUT = 10  # 10 seconds\ndef test_linting_example():\n    \"\"\"Test to linting on file open.\"\"\"\n    contents = TEST_FILE_PATH.read_text()\n    actual = []\n    with session.LspSession() as ls_session:\n        ls_session.initialize(defaults.VSCODE_DEFAULT_INITIALIZE)\n        done = Event()\n        def _handler(params):",
        "detail": "src.test.python_tests.test_server",
        "documentation": {}
    },
    {
        "label": "TIMEOUT",
        "kind": 5,
        "importPath": "src.test.python_tests.test_server",
        "description": "src.test.python_tests.test_server",
        "peekOfCode": "TIMEOUT = 10  # 10 seconds\ndef test_linting_example():\n    \"\"\"Test to linting on file open.\"\"\"\n    contents = TEST_FILE_PATH.read_text()\n    actual = []\n    with session.LspSession() as ls_session:\n        ls_session.initialize(defaults.VSCODE_DEFAULT_INITIALIZE)\n        done = Event()\n        def _handler(params):\n            nonlocal actual",
        "detail": "src.test.python_tests.test_server",
        "documentation": {}
    },
    {
        "label": "setup",
        "kind": 2,
        "importPath": "noxfile",
        "description": "noxfile",
        "peekOfCode": "def setup(session: nox.Session) -> None:\n    \"\"\"Sets up the template for development.\"\"\"\n    _setup_template_environment(session)\n@nox.session()\ndef tests(session: nox.Session) -> None:\n    \"\"\"Runs all the tests for the extension.\"\"\"\n    session.install(\"-r\", \"src/test/python_tests/requirements.txt\")\n    session.run(\"pytest\", \"src/test/python_tests\")\n@nox.session()\ndef lint(session: nox.Session) -> None:",
        "detail": "noxfile",
        "documentation": {}
    },
    {
        "label": "tests",
        "kind": 2,
        "importPath": "noxfile",
        "description": "noxfile",
        "peekOfCode": "def tests(session: nox.Session) -> None:\n    \"\"\"Runs all the tests for the extension.\"\"\"\n    session.install(\"-r\", \"src/test/python_tests/requirements.txt\")\n    session.run(\"pytest\", \"src/test/python_tests\")\n@nox.session()\ndef lint(session: nox.Session) -> None:\n    \"\"\"Runs linter and formatter checks on python files.\"\"\"\n    session.install(\"-r\", \"./requirements.txt\")\n    session.install(\"-r\", \"src/test/python_tests/requirements.txt\")\n    session.install(\"pylint\")",
        "detail": "noxfile",
        "documentation": {}
    },
    {
        "label": "lint",
        "kind": 2,
        "importPath": "noxfile",
        "description": "noxfile",
        "peekOfCode": "def lint(session: nox.Session) -> None:\n    \"\"\"Runs linter and formatter checks on python files.\"\"\"\n    session.install(\"-r\", \"./requirements.txt\")\n    session.install(\"-r\", \"src/test/python_tests/requirements.txt\")\n    session.install(\"pylint\")\n    session.run(\"pylint\", \"-d\", \"W0511\", \"./bundled/tool\")\n    session.run(\n        \"pylint\",\n        \"-d\",\n        \"W0511\",",
        "detail": "noxfile",
        "documentation": {}
    },
    {
        "label": "build_package",
        "kind": 2,
        "importPath": "noxfile",
        "description": "noxfile",
        "peekOfCode": "def build_package(session: nox.Session) -> None:\n    \"\"\"Builds VSIX package for publishing.\"\"\"\n    _check_files([\"README.md\", \"LICENSE\", \"SECURITY.md\", \"SUPPORT.md\"])\n    _setup_template_environment(session)\n    session.run(\"npm\", \"install\", external=True)\n    session.run(\"npm\", \"run\", \"vsce-package\", external=True)\n@nox.session()\ndef update_packages(session: nox.Session) -> None:\n    \"\"\"Update pip and npm packages.\"\"\"\n    session.install(\"wheel\", \"pip-tools\")",
        "detail": "noxfile",
        "documentation": {}
    },
    {
        "label": "update_packages",
        "kind": 2,
        "importPath": "noxfile",
        "description": "noxfile",
        "peekOfCode": "def update_packages(session: nox.Session) -> None:\n    \"\"\"Update pip and npm packages.\"\"\"\n    session.install(\"wheel\", \"pip-tools\")\n    _update_pip_packages(session)\n    _update_npm_packages(session)",
        "detail": "noxfile",
        "documentation": {}
    }
]